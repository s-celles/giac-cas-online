<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Xcas Reactive Notebook</title>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  External dependencies (loaded from CDN)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script src="https://unpkg.com/mathlive"></script>
<script src="https://unpkg.com/@cortex-js/compute-engine"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css">
<script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Giac/Xcas engine (asm.js) â€” HOST giac.js LOCALLY
  Download: https://www-fourier.univ-grenoble-alpes.fr/~parisse/giacjs.tar.gz
  We bypass giacsimple.js and define a minimal Module object
  so giac.js (Emscripten asm.js build) can initialize.
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
var Module = {
  ready: false,
  preRun: [],
  postRun: [],
  print: function(text) { console.log('giac:', text); },
  printErr: function(text) { console.warn('giac:', text); },
  setStatus: function(text) { if (text) console.log('giac status:', text); },
  totalDependencies: 0,
  monitorRunDependencies: function(left) {
    this.totalDependencies = Math.max(this.totalDependencies, left);
  },
  onRuntimeInitialized: function() {
    console.log('Giac runtime initialized');
    Module.ready = true;
  }
};
// Minimal UI stub â€” giac.js references UI.* during some computations
var UI = {
  Datestart: Date.now(),
  disable3d: 0,
  warnpy: false,
  python_output: '',
  assistant_matr_maxrows: 100,
  assistant_matr_maxcols: 100,
  clean_for_html: function(s) { return s; },
  add_python_output: function(s) { UI.python_output += s; },
  set_config_width: function() {},
  open_sheet: function() {},
  sheet_recompute: function() {},
  sheet_set_ij: function() {}
};
</script>
<script src="giac.js"></script>

<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Newsreader:ital,opsz,wght@0,6..72,400;0,6..72,500;1,6..72,400&display=swap');

  :root {
    --bg:#f4f2ed;--surface:#fff;--border:#d9d4ca;--border-focus:#2563eb;
    --text:#1c1917;--text-muted:#78716c;--output-bg:#fafaf6;
    --accent:#2563eb;--accent-hover:#1d4ed8;--accent-light:#eff3ff;
    --success:#15803d;--error:#b91c1c;--warning:#ca8a04;
    --shadow-sm:0 1px 2px rgba(0,0,0,0.04);--shadow:0 2px 8px rgba(0,0,0,0.06);
    --radius:10px;
    --mono:'JetBrains Mono','Menlo','Consolas',monospace;
    --body:'Newsreader','Georgia',serif;
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:var(--body);background:var(--bg);color:var(--text);line-height:1.65}

  /* â•â•â•â•â•â•â• Header â•â•â•â•â•â•â• */
  .header{background:#0c0f1a;color:#eae8e0;padding:1.6rem 2rem 1.2rem;position:relative;overflow:hidden}
  .header::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse 500px 250px at 5% 90%,rgba(37,99,235,.12),transparent),radial-gradient(ellipse 350px 180px at 95% 10%,rgba(168,85,247,.08),transparent);pointer-events:none}
  .header-inner{position:relative;max-width:960px;margin:0 auto;display:flex;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;gap:.5rem}
  .header-left h1{font-family:var(--mono);font-size:1.35rem;font-weight:500;letter-spacing:-.3px}
  .header-left p{font-size:.82rem;opacity:.5;margin-top:.1rem;font-family:var(--mono)}
  .header-right{display:flex;align-items:center;gap:.75rem;margin-top:.2rem}
  #giac-status{display:inline-flex;align-items:center;gap:5px;font-family:var(--mono);font-size:.7rem;padding:4px 11px;border-radius:20px;background:rgba(255,255,255,.07);transition:background .3s}
  #giac-status .dot{width:7px;height:7px;border-radius:50%;background:#facc15;transition:background .3s}
  #giac-status.ready .dot{background:#4ade80}
  #giac-status.error .dot{background:#f87171}
  .lang-select{font-family:var(--mono);font-size:.7rem;padding:3px 8px;border-radius:5px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.06);color:#eae8e0;cursor:pointer;outline:none}
  .lang-select:hover{border-color:rgba(255,255,255,.3)}
  .lang-select option{background:#1c1917;color:#eae8e0}

  /* â•â•â•â•â•â•â• Toolbar â•â•â•â•â•â•â• */
  .toolbar-wrap{border-bottom:1px solid var(--border);background:var(--surface);padding:0 2rem}
  .toolbar{max-width:960px;margin:0 auto;display:flex;gap:.4rem;padding:.6rem 0;flex-wrap:wrap;align-items:center}
  .toolbar button{font-family:var(--mono);font-size:.72rem;padding:5px 12px;border:1px solid var(--border);border-radius:6px;background:var(--bg);color:var(--text);cursor:pointer;transition:all .15s;white-space:nowrap}
  .toolbar button:hover{background:var(--accent);color:#fff;border-color:var(--accent)}
  .toolbar button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
  .toolbar button.primary:hover{background:var(--accent-hover)}
  .toolbar .sep{width:1px;height:20px;background:var(--border);margin:0 .15rem}

  /* â•â•â•â•â•â•â• Notebook â•â•â•â•â•â•â• */
  .notebook{max-width:960px;margin:1.2rem auto;padding:0 1rem 5rem}

  /* â•â•â•â•â•â•â• Cell â•â•â•â•â•â•â• */
  .cell{background:var(--surface);border:1.5px solid var(--border);border-radius:var(--radius);margin-bottom:.6rem;box-shadow:var(--shadow-sm);transition:border-color .2s,box-shadow .2s}
  .cell:focus-within{border-color:var(--border-focus);box-shadow:0 0 0 3px rgba(37,99,235,.07)}
  .cell.running{border-color:var(--warning)}
  .cell-head{display:flex;align-items:center;padding:.3rem .7rem;border-bottom:1px solid var(--border);background:#fafaf7;border-radius:var(--radius) var(--radius) 0 0;gap:.45rem;min-height:30px}
  .cell-idx{font-family:var(--mono);font-size:.66rem;color:var(--text-muted);min-width:44px}
  .cell-badge{font-family:var(--mono);font-size:.6rem;padding:1px 7px;border-radius:4px;color:#fff;letter-spacing:.3px;text-transform:uppercase}
  .cell-badge.math{background:#7c3aed}.cell-badge.text{background:#d97706}.cell-badge.raw{background:#64748b}
  .mode-toggle{font-family:var(--mono);font-size:.63rem;display:flex;border:1px solid var(--border);border-radius:4px;overflow:hidden;margin-left:.2rem}
  .mode-toggle button{padding:2px 7px;border:none;background:transparent;color:var(--text-muted);cursor:pointer;font-family:inherit;font-size:inherit;transition:all .15s}
  .mode-toggle button.active{background:var(--accent);color:#fff}
  .mode-toggle button:hover:not(.active){background:var(--accent-light)}
  .cell-actions{margin-left:auto;display:flex;gap:3px;opacity:0;transition:opacity .15s}
  .cell:hover .cell-actions{opacity:1}
  .cell-actions button{font-size:.66rem;padding:2px 7px;border:none;border-radius:3px;background:transparent;color:var(--text-muted);cursor:pointer;font-family:var(--mono)}
  .cell-actions button:hover{background:#eee;color:var(--text)}
  .cell-actions button.del:hover{background:#fee;color:var(--error)}

  /* â•â•â•â•â•â•â• Input â•â•â•â•â•â•â• */
  .cell-input{padding:.65rem .8rem;min-height:46px}
  .cell-input math-field{width:100%;font-size:1.2rem;border:none;outline:none;--caret-color:var(--accent);--selection-background-color:rgba(37,99,235,.12)}
  .cell-input textarea{width:100%;min-height:34px;border:none;outline:none;font-family:var(--mono);font-size:.8rem;color:var(--text);background:transparent;resize:vertical;line-height:1.55}

  /* â•â•â•â•â•â•â• Debug â•â•â•â•â•â•â• */
  .cell-debug{padding:.3rem .8rem;background:#f7f6f2;border-top:1px dashed var(--border);font-family:var(--mono);font-size:.65rem;color:var(--text-muted);display:none;overflow-x:auto;word-break:break-all}
  .cell-debug.visible{display:block}
  .cell-debug .lbl{font-weight:500;color:var(--accent);margin-right:.3rem}
  .cell-debug .xcas-out{color:var(--success);margin-left:.4rem}

  /* â•â•â•â•â•â•â• Output â•â•â•â•â•â•â• */
  .cell-output{padding:.65rem .8rem;background:var(--output-bg);border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);min-height:26px;overflow-x:auto}
  .cell-output:empty{display:none}
  .cell-output .err{color:var(--error);font-family:var(--mono);font-size:.78rem}
  .cell-output .katex-display{margin:.2rem 0;text-align:left}
  .cell-output .raw-res{font-family:var(--mono);font-size:.72rem;color:var(--text-muted);margin-top:.3rem;white-space:pre-wrap}
  .cell-output .md-out{font-family:var(--body);font-size:.93rem}
  .cell-output .md-out h1{font-size:1.35rem;margin:.35rem 0}
  .cell-output .md-out h2{font-size:1.1rem;margin:.3rem 0}
  .cell-output .md-out h3{font-size:.95rem;margin:.25rem 0}
  .cell-output .md-out p{margin:.3rem 0}
  .cell-output .md-out code{background:#eee;padding:1px 5px;border-radius:3px;font-family:var(--mono);font-size:.83em}
  .spinner{display:inline-block;width:12px;height:12px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .5s linear infinite;vertical-align:middle;margin-right:5px}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* â•â•â•â•â•â•â• Plot â•â•â•â•â•â•â• */
  .plot-container{margin:.3rem 0;position:relative}
  .plot-container canvas{max-width:100%;height:auto;display:block;border:1px solid var(--border);border-radius:4px}
  .plot-svg{overflow:hidden}
  .plot-svg svg{max-width:100%;height:auto;display:block}
  .plot-tooltip{position:absolute;background:rgba(0,0,0,.8);color:#fff;font-family:var(--mono);font-size:.65rem;padding:2px 6px;border-radius:3px;pointer-events:none;white-space:nowrap;z-index:5;display:none}
  .plot-3d-msg{font-family:var(--mono);font-size:.78rem;color:var(--warning);padding:.4rem;background:#fffbeb;border:1px solid #fde68a;border-radius:4px}
  .jxgbox-container{margin:.3rem 0}
  .jxgbox-container .jxgbox{width:100%;aspect-ratio:4/3;max-width:600px;border-radius:4px}

  /* â•â•â•â•â•â•â• Bottom bar â•â•â•â•â•â•â• */
  .bottombar{position:fixed;bottom:0;left:0;right:0;background:var(--surface);border-top:1px solid var(--border);padding:.4rem 1.5rem;font-family:var(--mono);font-size:.63rem;color:var(--text-muted);display:flex;gap:1.4rem;align-items:center;z-index:10}
  .bottombar kbd{background:#eeede8;padding:1px 5px;border-radius:3px;border:1px solid var(--border);font-size:.62rem}
  .bottombar label{display:flex;align-items:center;gap:4px;cursor:pointer}
  .bottombar input[type="checkbox"]{accent-color:var(--accent)}
</style>
</head>
<body>

<div class="header"><div class="header-inner">
  <div class="header-left">
    <h1>ğŸ““ <span data-i18n="title">Xcas Notebook</span></h1>
    <p data-i18n="subtitle">Reactive CAS â€” MathJSON â†” Giac via WebAssembly</p>
  </div>
  <div class="header-right">
    <select class="lang-select" id="lang-select" onchange="setLocale(this.value)">
      <option value="en">English</option>
      <option value="fr">FranÃ§ais</option>
      <option value="es">EspaÃ±ol</option>
      <option value="de">Deutsch</option>
    </select>
    <div id="giac-status">
      <span class="dot"></span>
      <span class="text" data-i18n="giacLoading">Loading Giacâ€¦</span>
    </div>
  </div>
</div></div>

<div class="toolbar-wrap"><div class="toolbar">
  <button onclick="addCell('math')" data-i18n="addMath">+ Math</button>
  <button onclick="addCell('raw')" data-i18n="addRaw">+ Xcas raw</button>
  <button onclick="addCell('text')" data-i18n="addText">+ Text</button>
  <div class="sep"></div>
  <button class="primary" onclick="runAll()" data-i18n="runAll">â–¶ Run all</button>
  <button onclick="clearAllOutputs()" data-i18n="clearOutputs">âœ• Clear outputs</button>
  <div class="sep"></div>
  <button onclick="exportNotebook()" data-i18n="exportBtn">ğŸ’¾ Export</button>
  <button onclick="importNotebook()" data-i18n="importBtn">ğŸ“‚ Import</button>
</div></div>

<div class="notebook" id="notebook"></div>

<div class="bottombar">
  <span><kbd>Shift</kbd>+<kbd>Enter</kbd> <span data-i18n="shortcutRun">Run</span></span>
  <span><kbd>Ctrl</kbd>+<kbd>Enter</kbd> <span data-i18n="shortcutRunNew">Run + new cell</span></span>
  <label><input type="checkbox" id="toggle-debug" onchange="toggleAllDebug(this.checked)">
    <span data-i18n="showMathJSON">Show MathJSON</span></label>
</div>

<script>
'use strict';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 1 â€” INTERNATIONALIZATION (i18n)
//
// All user-facing strings live in LOCALES. Any element with
// data-i18n="key" is auto-updated when the locale changes.
//
// To add a language:
//   1. Add an entry to LOCALES
//   2. Add an <option> in #lang-select
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const LOCALES = {
  en: {
    title: 'Xcas Notebook',
    subtitle: 'Reactive CAS â€” MathJSON â†” Giac via WebAssembly',
    giacLoading: 'Loading Giacâ€¦',
    giacReady: 'Giac ready',
    giacError: 'Giac init error',
    giacDemo: 'Demo mode (Giac not loaded)',
    addMath: '+ Math', addRaw: '+ Xcas raw', addText: '+ Text',
    runAll: 'â–¶ Run all', clearOutputs: 'âœ• Clear outputs',
    exportBtn: 'ğŸ’¾ Export', importBtn: 'ğŸ“‚ Import',
    shortcutRun: 'Run', shortcutRunNew: 'Run + new cell',
    showMathJSON: 'Show MathJSON',
    cellMath: 'Math', cellRaw: 'Xcas', cellText: 'Text',
    placeholderRaw: 'Xcas syntax (e.g. factor(x^4-1))',
    placeholderText: 'Notes, Markdownâ€¦',
    computing: 'Computingâ€¦',
    giacNotReady: 'â³ Giac is still loadingâ€¦',
    errorPrefix: 'âœ— Error:',
    moveUp: 'Move up', moveDown: 'Move down',
    deleteCell: 'Delete', runCell: 'Run',
    modeVisual: 'Visual math input', modeRaw: 'Raw Xcas syntax',
    invalidJson: 'Invalid JSON file',
    welcomeTitle: '# Welcome to the Xcas Notebook',
    welcomeBody: 'Type math visually (MathJSON) or use raw Xcas syntax.\nTick **Show MathJSON** at the bottom to inspect the conversion pipeline.',
    plot3dNotSupported: '3D plots are not yet supported. Use 2D plot commands instead.',
    plotCoordinates: 'Coordinates',
  },
  fr: {
    title: 'Notebook Xcas',
    subtitle: 'Calcul formel rÃ©actif â€” MathJSON â†” Giac via WebAssembly',
    giacLoading: 'Chargement de Giacâ€¦',
    giacReady: 'Giac prÃªt',
    giacError: 'Erreur init Giac',
    giacDemo: 'Mode dÃ©mo (Giac non chargÃ©)',
    addMath: '+ Math', addRaw: '+ Xcas brut', addText: '+ Texte',
    runAll: 'â–¶ Tout exÃ©cuter', clearOutputs: 'âœ• Effacer sorties',
    exportBtn: 'ğŸ’¾ Exporter', importBtn: 'ğŸ“‚ Importer',
    shortcutRun: 'ExÃ©cuter', shortcutRunNew: 'ExÃ©cuter + nouvelle cellule',
    showMathJSON: 'Afficher MathJSON',
    cellMath: 'Math', cellRaw: 'Xcas', cellText: 'Texte',
    placeholderRaw: 'Syntaxe Xcas (ex : factor(x^4-1))',
    placeholderText: 'Notes, Markdownâ€¦',
    computing: 'Calcul en coursâ€¦',
    giacNotReady: 'â³ Giac en chargementâ€¦',
    errorPrefix: 'âœ— Erreur :',
    moveUp: 'Monter', moveDown: 'Descendre',
    deleteCell: 'Supprimer', runCell: 'ExÃ©cuter',
    modeVisual: 'Saisie math visuelle', modeRaw: 'Syntaxe Xcas brute',
    invalidJson: 'Fichier JSON invalide',
    welcomeTitle: '# Bienvenue dans le Notebook Xcas',
    welcomeBody: 'Saisissez des maths visuellement (MathJSON) ou en syntaxe Xcas brute.\nCochez **Afficher MathJSON** en bas pour inspecter la conversion.',
    plot3dNotSupported: 'Les graphiques 3D ne sont pas encore pris en charge. Utilisez les commandes de tracÃ© 2D.',
    plotCoordinates: 'CoordonnÃ©es',
  },
  es: {
    title: 'Cuaderno Xcas',
    subtitle: 'CAS reactivo â€” MathJSON â†” Giac vÃ­a WebAssembly',
    giacLoading: 'Cargando Giacâ€¦',
    giacReady: 'Giac listo',
    giacError: 'Error al iniciar Giac',
    giacDemo: 'Modo demo (Giac no cargado)',
    addMath: '+ Mate', addRaw: '+ Xcas directo', addText: '+ Texto',
    runAll: 'â–¶ Ejecutar todo', clearOutputs: 'âœ• Limpiar salidas',
    exportBtn: 'ğŸ’¾ Exportar', importBtn: 'ğŸ“‚ Importar',
    shortcutRun: 'Ejecutar', shortcutRunNew: 'Ejecutar + nueva celda',
    showMathJSON: 'Mostrar MathJSON',
    cellMath: 'Mate', cellRaw: 'Xcas', cellText: 'Texto',
    placeholderRaw: 'Sintaxis Xcas (ej: factor(x^4-1))',
    placeholderText: 'Notas, Markdownâ€¦',
    computing: 'Calculandoâ€¦',
    giacNotReady: 'â³ Giac estÃ¡ cargandoâ€¦',
    errorPrefix: 'âœ— Error:',
    moveUp: 'Subir', moveDown: 'Bajar',
    deleteCell: 'Eliminar', runCell: 'Ejecutar',
    modeVisual: 'Entrada visual', modeRaw: 'Sintaxis Xcas directa',
    invalidJson: 'Archivo JSON no vÃ¡lido',
    welcomeTitle: '# Bienvenido al Cuaderno Xcas',
    welcomeBody: 'Escribe matemÃ¡ticas visualmente (MathJSON) o usa sintaxis Xcas directa.\nMarca **Mostrar MathJSON** abajo para inspeccionar la conversiÃ³n.',
    plot3dNotSupported: 'Los grÃ¡ficos 3D aÃºn no son compatibles. Usa comandos de grÃ¡ficos 2D.',
    plotCoordinates: 'Coordenadas',
  },
  de: {
    title: 'Xcas Notizbuch',
    subtitle: 'Reaktives CAS â€” MathJSON â†” Giac via WebAssembly',
    giacLoading: 'Giac wird geladenâ€¦',
    giacReady: 'Giac bereit',
    giacError: 'Giac Init-Fehler',
    giacDemo: 'Demo-Modus (Giac nicht geladen)',
    addMath: '+ Mathe', addRaw: '+ Xcas direkt', addText: '+ Text',
    runAll: 'â–¶ Alles ausfÃ¼hren', clearOutputs: 'âœ• Ausgaben lÃ¶schen',
    exportBtn: 'ğŸ’¾ Exportieren', importBtn: 'ğŸ“‚ Importieren',
    shortcutRun: 'AusfÃ¼hren', shortcutRunNew: 'AusfÃ¼hren + neue Zelle',
    showMathJSON: 'MathJSON anzeigen',
    cellMath: 'Mathe', cellRaw: 'Xcas', cellText: 'Text',
    placeholderRaw: 'Xcas-Syntax (z.B. factor(x^4-1))',
    placeholderText: 'Notizen, Markdownâ€¦',
    computing: 'Berechnungâ€¦',
    giacNotReady: 'â³ Giac wird noch geladenâ€¦',
    errorPrefix: 'âœ— Fehler:',
    moveUp: 'Nach oben', moveDown: 'Nach unten',
    deleteCell: 'LÃ¶schen', runCell: 'AusfÃ¼hren',
    modeVisual: 'Visuelle Mathe-Eingabe', modeRaw: 'Direkte Xcas-Syntax',
    invalidJson: 'UngÃ¼ltige JSON-Datei',
    welcomeTitle: '# Willkommen im Xcas Notizbuch',
    welcomeBody: 'Gib Mathematik visuell ein (MathJSON) oder nutze direkte Xcas-Syntax.\nAktiviere **MathJSON anzeigen** unten, um die Konvertierung zu prÃ¼fen.',
    plot3dNotSupported: '3D-Grafiken werden noch nicht unterstÃ¼tzt. Verwenden Sie 2D-Plotbefehle.',
    plotCoordinates: 'Koordinaten',
  },
};

let currentLocale = 'en';

/** Look up a translation key; falls back to English */
function t(key) {
  return LOCALES[currentLocale]?.[key] ?? LOCALES.en[key] ?? key;
}

/** Refresh all data-i18n elements + dynamic placeholders */
function applyI18n() {
  document.querySelectorAll('[data-i18n]').forEach(el => {
    el.textContent = t(el.getAttribute('data-i18n'));
  });
  document.querySelectorAll('.cell').forEach(cell => {
    const ta = cell.querySelector('textarea');
    if (ta && cell.dataset.type === 'raw')  ta.placeholder = t('placeholderRaw');
    if (ta && cell.dataset.type === 'text') ta.placeholder = t('placeholderText');
  });
  document.documentElement.lang = currentLocale;
}

/** Set locale, refresh UI, persist preference */
function setLocale(locale) {
  if (!LOCALES[locale]) return;
  currentLocale = locale;
  document.getElementById('lang-select').value = locale;
  applyI18n();
  try { localStorage.setItem('xcas-nb-locale', locale); } catch(e) {}
}

/** Auto-detect from stored preference or browser language */
function detectLocale() {
  try {
    const s = localStorage.getItem('xcas-nb-locale');
    if (s && LOCALES[s]) return s;
  } catch(e) {}
  const lang = (navigator.language || '').slice(0, 2);
  return LOCALES[lang] ? lang : 'en';
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 2 â€” COMPUTE ENGINE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const ce = new ComputeEngine.ComputeEngine();


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 3 â€” GIAC INITIALIZATION
//
// Giac exposes:  extern "C" const char* caseval(const char*);
// Two loading strategies:
//   A) giacsimple.js â†’ UI.ready / UI.caseval
//   B) giacwasm.js   â†’ Module.cwrap('caseval','string',['string'])
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let giacReady = false;
let caseval = null;

function initGiac() {
  const el  = document.getElementById('giac-status');
  const txt = el.querySelector('.text');

  if (typeof Module === 'undefined') {
    // No Module at all â€” demo mode
    txt.textContent = t('giacDemo');
    el.classList.add('error');
    caseval = (expr) => '[DEMO] ' + expr;
    giacReady = true;
    return;
  }

  // Poll until Module.ready (set by onRuntimeInitialized)
  const poll = setInterval(() => {
    if (Module.ready) {
      clearInterval(poll);
      try {
        caseval = Module.cwrap('caseval', 'string', ['string']);
        giacReady = true;
        txt.textContent = t('giacReady');
        el.classList.add('ready');
      } catch (e) {
        txt.textContent = t('giacError');
        el.classList.add('error');
        console.error('Giac init error:', e);
      }
    }
  }, 200);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 4 â€” MATHJSON â†’ XCAS CONVERTER
//
// MathJSON (CortexJS) uses PascalCase function names:
//   ["Add", 1, 2]  â†’  1+2
//   ["D", f, x]    â†’  diff(f, x)
//
// The converter walks the AST recursively and emits a
// Xcas-compatible string for caseval().
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SYMBOL_MAP = {
  Pi: 'pi', ExponentialE: 'e', ImaginaryUnit: 'i',
  Infinity: '+infinity', NegativeInfinity: '-infinity',
  True: 'true', False: 'false', Nothing: 'undef', Half: '1/2',
};

/**
 * Convert a MathJSON expression to a Xcas-compatible string.
 * @param {*} expr - MathJSON node (number | string | array | object)
 * @returns {string}
 */
function mathJsonToXcas(expr) {
  if (expr == null) return '';
  if (typeof expr === 'number') return String(expr);
  if (typeof expr === 'string') return SYMBOL_MAP[expr] ?? expr;

  // Object literal form: { num, sym, str, fn }
  if (typeof expr === 'object' && !Array.isArray(expr)) {
    if ('num' in expr) return expr.num;
    if ('sym' in expr) return mathJsonToXcas(expr.sym);
    if ('str' in expr) return '"' + expr.str + '"';
    if ('fn'  in expr) return mathJsonToXcas(expr.fn);
    return JSON.stringify(expr);
  }

  if (!Array.isArray(expr) || expr.length === 0) return '';

  const [head, ...args] = expr;
  const c   = (i) => mathJsonToXcas(args[i]);
  const all = ()  => args.map(mathJsonToXcas);
  const w   = (s) => '(' + s + ')';

  // Helper: unwrap CortexJS ["Function", ["Block", body], var] pattern
  function unwrapFn(node) {
    if (!Array.isArray(node) || node[0] !== 'Function') return null;
    let body = node[1];
    if (Array.isArray(body) && body[0] === 'Block') body = body[1];
    const v = node.length >= 3 ? mathJsonToXcas(node[2]) : 'x';
    return { body: mathJsonToXcas(body), v };
  }
  function isNothing(node) {
    return node == null || node === 'Nothing' ||
      (typeof node === 'object' && !Array.isArray(node) && node.sym === 'Nothing');
  }

  switch (head) {

    // â•â•â•â•â•â• Arithmetic â•â•â•â•â•â•
    case 'Add': case 'Sum':
      return w(all().join('+'));
    case 'Subtract':
      return args.length === 1 ? '(-' + w(c(0)) + ')' : w(c(0) + '-' + w(c(1)));
    case 'Negate':
      return '(-' + w(c(0)) + ')';
    case 'Multiply':
      return w(all().join('*'));
    case 'Divide':
      return '(' + w(c(0)) + '/' + w(c(1)) + ')';
    case 'Rational':
      return '(' + c(0) + '/' + c(1) + ')';
    case 'Power':
      return '(' + w(c(0)) + '^' + w(c(1)) + ')';
    case 'Sqrt':
      return 'sqrt(' + c(0) + ')';
    case 'Root':
      return args.length >= 2
        ? '(' + w(c(0)) + '^(1/' + w(c(1)) + '))'
        : 'sqrt(' + c(0) + ')';
    case 'Abs':       return 'abs(' + c(0) + ')';
    case 'Factorial': return '(' + c(0) + ')!';

    // â•â•â•â•â•â• Trigonometric â•â•â•â•â•â•
    case 'Sin': return 'sin(' + c(0) + ')';
    case 'Cos': return 'cos(' + c(0) + ')';
    case 'Tan': return 'tan(' + c(0) + ')';
    case 'Sec': return '(1/cos(' + c(0) + '))';
    case 'Csc': return '(1/sin(' + c(0) + '))';
    case 'Cot': return '(1/tan(' + c(0) + '))';
    case 'Arcsin': return 'asin(' + c(0) + ')';
    case 'Arccos': return 'acos(' + c(0) + ')';
    case 'Arctan': return 'atan(' + c(0) + ')';
    case 'Sinh': return 'sinh(' + c(0) + ')';
    case 'Cosh': return 'cosh(' + c(0) + ')';
    case 'Tanh': return 'tanh(' + c(0) + ')';

    // â•â•â•â•â•â• Log / Exp â•â•â•â•â•â•
    case 'Ln':  return 'ln(' + c(0) + ')';
    case 'Exp': return 'exp(' + c(0) + ')';
    case 'Log':
      return args.length >= 2 ? 'log(' + c(0) + ',' + c(1) + ')' : 'ln(' + c(0) + ')';
    case 'Log2':  return 'log(' + c(0) + ',2)';
    case 'Log10': return 'log(' + c(0) + ',10)';

    // â•â•â•â•â•â• Calculus â•â•â•â•â•â•
    case 'D': case 'Derivative': {
      const diffFn = unwrapFn(args[0]);
      if (diffFn) return 'diff(' + diffFn.body + ',' + diffFn.v + ')';
      return args.length >= 2 ? 'diff(' + c(0) + ',' + c(1) + ')' : 'diff(' + c(0) + ',x)';
    }

    case 'Integrate': {
      // CortexJS pattern: ["Integrate", ["Function", ["Block", body], var], ["Limits", var, lo, hi]]
      const intFn = unwrapFn(args[0]);
      if (intFn) {
        if (Array.isArray(args[1]) && args[1][0] === 'Limits') {
          const lo = args[1][2], hi = args[1][3];
          if (isNothing(lo) && isNothing(hi)) {
            return 'int(' + intFn.body + ',' + intFn.v + ')';
          }
          return 'int(' + intFn.body + ',' + intFn.v + ',' + mathJsonToXcas(lo) + ',' + mathJsonToXcas(hi) + ')';
        }
        return 'int(' + intFn.body + ',' + intFn.v + ')';
      }
      if (args.length === 1) return 'int(' + c(0) + ',x)';
      // Definite integral: ["Integrate", f, ["Triple", var, lo, hi]]
      if (Array.isArray(args[1]) &&
          ['Triple','Tuple'].includes(args[1][0]) &&
          args[1].length === 4) {
        const [, v, lo, hi] = args[1].map(mathJsonToXcas);
        return 'int(' + c(0) + ',' + v + ',' + lo + ',' + hi + ')';
      }
      if (args.length === 2) return 'int(' + c(0) + ',' + c(1) + ')';
      if (args.length === 4) return 'int(' + c(0) + ',' + c(1) + ',' + c(2) + ',' + c(3) + ')';
      return 'int(' + all().join(',') + ')';
    }

    case 'Limit': {
      // CortexJS pattern: ["Limit", ["Function", ["Block", body], var], point]
      const limFn = unwrapFn(args[0]);
      if (limFn) {
        if (args.length >= 2) return 'limit(' + limFn.body + ',' + limFn.v + ',' + c(1) + ')';
        return 'limit(' + limFn.body + ',' + limFn.v + ')';
      }
      if (args.length >= 3) return 'limit(' + c(0) + ',' + c(1) + '=' + c(2) + ')';
      if (args.length === 2) return 'limit(' + c(0) + ',' + c(1) + ')';
      return 'limit(' + c(0) + ')';
    }

    case 'Series': case 'Taylor':
      return 'series(' + all().join(',') + ')';

    // â•â•â•â•â•â• Algebra â•â•â•â•â•â•
    case 'Solve':    return 'solve(' + all().join(',') + ')';
    case 'Factor':   return 'factor(' + c(0) + ')';
    case 'Simplify': return 'simplify(' + c(0) + ')';
    case 'Expand':   return 'expand(' + c(0) + ')';

    // â•â•â•â•â•â• Linear algebra â•â•â•â•â•â•
    case 'Determinant': case 'Det': return 'det(' + c(0) + ')';
    case 'Inverse':      return 'inv(' + c(0) + ')';
    case 'Transpose':    return 'tran(' + c(0) + ')';
    case 'Eigenvalues':  return 'eigenvalues(' + c(0) + ')';
    case 'Eigenvectors': return 'eigenvects(' + c(0) + ')';

    // â•â•â•â•â•â• Relations â•â•â•â•â•â•
    case 'Equal':        return c(0) + '=' + c(1);
    case 'Less':         return c(0) + '<' + c(1);
    case 'LessEqual':    return c(0) + '<=' + c(1);
    case 'Greater':      return c(0) + '>' + c(1);
    case 'GreaterEqual': return c(0) + '>=' + c(1);
    case 'NotEqual':     return c(0) + '!=' + c(1);

    // â•â•â•â•â•â• Data structures â•â•â•â•â•â•
    case 'List':   return '[' + all().join(',') + ']';
    case 'Matrix': {
      const rows = args.map(r =>
        Array.isArray(r) && r[0] === 'List'
          ? '[' + r.slice(1).map(mathJsonToXcas).join(',') + ']'
          : mathJsonToXcas(r));
      return '[' + rows.join(',') + ']';
    }
    case 'Tuple': case 'Triple': case 'Pair': case 'Sequence':
      return all().join(',');
    case 'Set':       return '{' + all().join(',') + '}';
    case 'Range':     return c(0) + '..' + c(1);
    case 'Delimiter':
      return args.length === 1 && Array.isArray(args[0])
        ? w(mathJsonToXcas(args[0])) : w(all().join(','));

    // â•â•â•â•â•â• Special functions â•â•â•â•â•â•
    case 'Floor': return 'floor(' + c(0) + ')';
    case 'Ceil':  return 'ceil(' + c(0) + ')';
    case 'Round': return 'round(' + c(0) + ')';
    case 'Max':   return 'max(' + all().join(',') + ')';
    case 'Min':   return 'min(' + all().join(',') + ')';
    case 'Gcd':   return 'gcd(' + all().join(',') + ')';
    case 'Lcm':   return 'lcm(' + all().join(',') + ')';
    case 'Mod':   return 'irem(' + c(0) + ',' + c(1) + ')';
    case 'Binomial': case 'Choose':
      return 'comb(' + c(0) + ',' + c(1) + ')';

    // â•â•â•â•â•â• CortexJS wrappers â•â•â•â•â•â•
    case 'Block':    return args.length >= 1 ? c(0) : '';
    case 'Function': return args.length >= 1 ? c(0) : '';
    case 'Limits':   return args.length >= 1 ? c(0) : '';

    // â•â•â•â•â•â• Misc â•â•â•â•â•â•
    case 'Assign': return c(0) + ':=' + c(1);
    case 'Plot':   return 'plot(' + all().join(',') + ')';

    // â•â•â•â•â•â• Unknown â†’ attempt direct Xcas call â•â•â•â•â•â•
    default: {
      const fn = head.charAt(0).toLowerCase() + head.slice(1);
      return args.length === 0 ? fn : fn + '(' + all().join(',') + ')';
    }
  }
}

/**
 * Full pipeline: LaTeX (from math-field) â†’ MathJSON â†’ Xcas string.
 */
function latexToXcas(latex) {
  try {
    return mathJsonToXcas(ce.parse(latex, { canonical: false }).json);
  } catch (e) {
    console.warn('LaTeXâ†’MathJSON error:', e);
    return latex; // Giac can parse some LaTeX directly
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 5 â€” CELL MANAGEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let cellCounter = 0;
let cells = [];
let showDebug = false;

function addCell(type = 'math', initialLatex = '', initialRaw = '') {
  cellCounter++;
  const id = 'cell-' + cellCounter;
  const nb = document.getElementById('notebook');
  const div = document.createElement('div');
  div.className = 'cell'; div.id = id; div.dataset.type = type;

  const badge = { math:'cellMath', raw:'cellRaw', text:'cellText' }[type];
  const idx   = type === 'text' ? `Txt[${cellCounter}]` : `In[${cellCounter}]`;

  div.innerHTML = `
    <div class="cell-head">
      <span class="cell-idx">${idx}</span>
      <span class="cell-badge ${type}" data-i18n="${badge}">${t(badge)}</span>
      ${type === 'math' ? `<div class="mode-toggle">
        <button class="active" onclick="setCellMode('${id}','math')" title="${t('modeVisual')}">ğ‘“(ğ‘¥)</button>
        <button onclick="setCellMode('${id}','raw')" title="${t('modeRaw')}">{ }</button>
      </div>` : ''}
      <div class="cell-actions">
        <button onclick="runSingleCell('${id}')" title="${t('runCell')}">â–¶</button>
        <button onclick="moveCell('${id}',-1)" title="${t('moveUp')}">â†‘</button>
        <button onclick="moveCell('${id}',1)" title="${t('moveDown')}">â†“</button>
        <button class="del" onclick="deleteCell('${id}')" title="${t('deleteCell')}">âœ•</button>
      </div>
    </div>
    <div class="cell-input"></div>
    <div class="cell-debug ${showDebug?'visible':''}"></div>
    <div class="cell-output" id="${id}-output"></div>`;

  nb.appendChild(div);
  const inp = div.querySelector('.cell-input');

  if (type === 'math') {
    const mf = document.createElement('math-field');
    mf.value = initialLatex || '';
    mf.setAttribute('virtual-keyboard-mode', 'manual');
    mf.addEventListener('input', () => updateDebug(id));
    mf.addEventListener('keydown', (e) => cellKey(e, id, 'math'));
    inp.appendChild(mf);
    setTimeout(() => updateDebug(id), 100);
  } else {
    const ph = type === 'raw' ? t('placeholderRaw') : t('placeholderText');
    const ta = mkTextarea(ph, initialRaw);
    ta.rows = type === 'text' ? 3 : 2;
    ta.addEventListener('keydown', (e) => cellKey(e, id, type));
    inp.appendChild(ta);
  }

  cells.push({ id, type, element: div });
  return id;
}

function mkTextarea(ph, val) {
  const ta = document.createElement('textarea');
  ta.placeholder = ph; ta.value = val || '';
  ta.addEventListener('input', () => { ta.style.height = 'auto'; ta.style.height = ta.scrollHeight + 'px'; });
  return ta;
}

function cellKey(e, id, type) {
  if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); runSingleCell(id); }
  if (e.key === 'Enter' && e.ctrlKey)  { e.preventDefault(); runSingleCell(id); addCell(type === 'text' ? 'text' : 'math'); }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 6 â€” DEBUG PANEL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function updateDebug(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  const dbg = cell.querySelector('.cell-debug');
  const mf  = cell.querySelector('math-field');
  if (!mf || !dbg) return;
  try {
    const json = ce.parse(mf.value, { canonical: false }).json;
    const xcas = mathJsonToXcas(json);
    dbg.innerHTML =
      '<span class="lbl">MathJSON:</span><code>' + esc(JSON.stringify(json)) + '</code>' +
      '<span class="xcas-out">â†’ Xcas: <code>' + esc(xcas) + '</code></span>';
  } catch (e) {
    dbg.innerHTML = '<span class="lbl">Error:</span> ' + esc(e.message);
  }
}

function toggleAllDebug(show) {
  showDebug = show;
  document.querySelectorAll('.cell-debug').forEach(d => d.classList.toggle('visible', show));
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 7 â€” MODE SWITCHING (math â†” raw)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function setCellMode(cellId, mode) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  const inp  = cell.querySelector('.cell-input');
  const btns = cell.querySelectorAll('.mode-toggle button');

  if (mode === 'raw') {
    const mf = cell.querySelector('math-field');
    const xcas = mf ? latexToXcas(mf.value) : '';
    inp.innerHTML = '';
    const ta = mkTextarea(t('placeholderRaw'), xcas);
    ta.addEventListener('keydown', (e) => cellKey(e, cellId, 'raw'));
    inp.appendChild(ta);
    cell.dataset.mode = 'raw';
    btns[0].classList.remove('active'); btns[1].classList.add('active');
  } else {
    const ta = cell.querySelector('textarea');
    inp.innerHTML = '';
    const mf = document.createElement('math-field');
    mf.value = ta ? ta.value : '';
    mf.setAttribute('virtual-keyboard-mode', 'manual');
    mf.addEventListener('input', () => updateDebug(cellId));
    mf.addEventListener('keydown', (e) => cellKey(e, cellId, 'math'));
    inp.appendChild(mf);
    cell.dataset.mode = 'math';
    btns[0].classList.add('active'); btns[1].classList.remove('active');
    setTimeout(() => updateDebug(cellId), 100);
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 8 â€” EXECUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getXcasExpr(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell || cell.dataset.type === 'text') return '';
  const mode = cell.dataset.mode || cell.dataset.type;
  if (cell.dataset.type === 'raw' || mode === 'raw') {
    return cell.querySelector('textarea')?.value.trim() || '';
  }
  const mf = cell.querySelector('math-field');
  return mf ? latexToXcas(mf.value) : '';
}

function runSingleCell(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  if (cell.dataset.type === 'text') { renderTextCell(cellId); return; }

  const expr = getXcasExpr(cellId);
  const out  = document.getElementById(cellId + '-output');
  if (!expr) { out.innerHTML = ''; return; }
  if (!giacReady) { out.innerHTML = '<span class="err">' + t('giacNotReady') + '</span>'; return; }

  cell.classList.add('running');
  out.innerHTML = '<span class="spinner"></span> ' + t('computing');

  setTimeout(() => {
    try {
      const raw = caseval(expr);
      const plotFmt = detectPlotFormat(raw);

      // Clean up any previous JSXGraph boards in this output
      cleanupJSXGraphInElement(out);
      out.innerHTML = '';

      if (plotFmt === 'svg') {
        var jsxDone = false;
        if (jsxGraphAvailable()) {
          try {
            var plotData = parseSvgPlotData(stripQuotes(raw));
            if (plotData && plotData.curves.length > 0) {
              renderJSXGraphPlot(out, plotData);
              jsxDone = true;
            }
          } catch(e) { /* JSXGraph parse failed, fall back to raw SVG */ }
        }
        if (!jsxDone) renderSvgPlot(out, stripQuotes(raw));
      } else if (plotFmt === 'gr2d') {
        var jsxDone = false;
        if (jsxGraphAvailable()) {
          try {
            var plotData = parseGr2dLogoData(raw);
            if (plotData && plotData.curves.length > 0) {
              renderJSXGraphPlot(out, plotData);
              jsxDone = true;
            }
          } catch(e) { console.warn('JSXGraph gr2d parse failed, falling back:', e); }
        }
        if (!jsxDone) renderGr2dPlot(out, raw);
      } else if (plotFmt === 'gl3d') {
        renderGl3dMessage(out);
      } else {
        // Text/LaTeX path (existing behavior)
        let latex = '';
        try { latex = caseval('latex(' + expr + ')').replace(/^"|"$/g, ''); } catch(e) {}
        if (latex && typeof katex !== 'undefined') {
          const d = document.createElement('div');
          try {
            katex.render(latex, d, { displayMode: true, throwOnError: false, trust: true });
            out.appendChild(d);
          } catch(e) { out.innerHTML = '<div class="raw-res">' + esc(raw) + '</div>'; }
        } else {
          out.innerHTML = '<div class="raw-res">' + esc(raw) + '</div>';
        }
      }
      // Show raw result beneath â€” but not for plot outputs (too verbose)
      if (plotFmt === 'text') {
        const r = document.createElement('div');
        r.className = 'raw-res'; r.textContent = 'â†’ ' + raw;
        out.appendChild(r);
      }
    } catch (err) {
      out.innerHTML = '<span class="err">' + t('errorPrefix') + ' ' + esc(String(err)) + '</span>';
    }
    cell.classList.remove('running');
  }, 10);
}

function renderTextCell(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  const ta = cell.querySelector('textarea');
  const out = document.getElementById(cellId + '-output');
  if (!ta || !ta.value.trim()) { out.innerHTML = ''; return; }
  let h = esc(ta.value)
    .replace(/^### (.+)$/gm, '<h3>$1</h3>')
    .replace(/^## (.+)$/gm,  '<h2>$1</h2>')
    .replace(/^# (.+)$/gm,   '<h1>$1</h1>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g,     '<em>$1</em>')
    .replace(/`(.+?)`/g,       '<code>$1</code>')
    .replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>');
  out.innerHTML = '<div class="md-out"><p>' + h + '</p></div>';
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 9 â€” GLOBAL ACTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function runAll() { cells.forEach(c => runSingleCell(c.id)); }
function clearAllOutputs() { cells.forEach(c => { const o = document.getElementById(c.id+'-output'); if(o) o.innerHTML=''; }); }
function deleteCell(id) { document.getElementById(id)?.remove(); cells = cells.filter(c => c.id !== id); }
function moveCell(id, dir) {
  const i = cells.findIndex(c => c.id === id);
  if (i < 0) return;
  const j = i + dir;
  if (j < 0 || j >= cells.length) return;
  [cells[i], cells[j]] = [cells[j], cells[i]];
  const nb = document.getElementById('notebook');
  nb.innerHTML = '';
  cells.forEach(c => nb.appendChild(c.element));
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 10 â€” EXPORT / IMPORT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function exportNotebook() {
  const data = {
    locale: currentLocale,
    cells: cells.map(c => {
      const el = c.element;
      const mode = el.dataset.mode || el.dataset.type;
      const mf = el.querySelector('math-field');
      const ta = el.querySelector('textarea');
      return {
        type: el.dataset.type,
        mode,
        content: (mode === 'math' && mf) ? mf.value : (ta ? ta.value : '')
      };
    })
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'xcas-notebook.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

function importNotebook() {
  const inp = document.createElement('input');
  inp.type = 'file'; inp.accept = '.json';
  inp.onchange = (e) => {
    const f = e.target.files[0]; if (!f) return;
    const r = new FileReader();
    r.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.locale && LOCALES[data.locale]) setLocale(data.locale);
        document.getElementById('notebook').innerHTML = '';
        cells = []; cellCounter = 0;
        (Array.isArray(data) ? data : data.cells).forEach(item => {
          item.type === 'math' ? addCell('math', item.content) : addCell(item.type, '', item.content);
        });
      } catch(err) { alert(t('invalidJson')); }
    };
    r.readAsText(f);
  };
  inp.click();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 11 â€” UTILITIES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 12 â€” BOOT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

document.addEventListener('DOMContentLoaded', () => {
  setLocale(detectLocale());
  initGiac();

  // Demo cells
  addCell('text', '', t('welcomeTitle') + '\n\n' + t('welcomeBody'));
  addCell('math', '\\frac{x^4-1}{x^2+1}');
  addCell('math', '\\int \\frac{1}{x^2+1}\\, dx');
  addCell('math', '\\frac{d}{dx}\\left(\\sin(x)\\cdot e^x\\right)');
  addCell('math', '\\lim_{x \\to 0} \\frac{\\sin(x)}{x}');
  addCell('raw',  '', 'solve(x^2 - 3*x + 2 = 0, x)');
  addCell('raw',  '', 'eigenvalues([[1,2],[3,4]])');
  addCell('raw',  '', 'plot(sin(x))');
  addCell('raw',  '', 'plotfunc([sin(x),cos(x)],x)');
  addCell('raw',  '', 'plot([sin(x),sin(x-pi/3),sin(x-2*pi/3)],x)');
});


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 13 â€” PLOT RENDERING
//
// Detects graphical output from Giac (SVG, gr2d, gl3d) and
// renders plots inline in cell output areas.
// Ported from giacsimple.js with adaptations for the notebook.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const PLOT_COLORS = [
  'black','red','green','yellow','blue','magenta','cyan','white',
  'silver','gray','maroon','purple','fuchsia','lime','olive','navy',
  'teal','aqua','antiquewhite','aquamarine','azure','beige','bisque',
  'blanchedalmond','blueviolet','brown','burlywood','cadetblue',
  'chartreuse','chocolate','coral','cornflowerblue','cornsilk','crimson',
  'cyan','darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen',
  'darkgrey','darkkhaki','darkmagenta','darkolivegreen','darkorange',
  'darkorchid','darkred','darksalmon','darkseagreen','darkslateblue',
  'darkslategray','darkslategrey','darkturquoise','darkviolet','deeppink',
  'deepskyblue','dimgray','dimgrey','dodgerblue','firebrick','floralwhite',
  'forestgreen','gainsboro','ghostwhite','gold','goldenrod','greenyellow',
  'grey','honeydew','hotpink','indianred','indigo','ivory','khaki',
  'lavender','lavenderblush','lawngreen','lemonchiffon','lightblue',
  'lightcoral','lightcyan','lightgoldenrodyellow','lightgray','lightgreen',
  'lightgrey','lightpink','lightsalmon','lightseagreen','lightskyblue',
  'lightslategray','lightslategrey','lightsteelblue','lightyellow',
  'limegreen','linen','mediumaquamarine','mediumblue','mediumorchid',
  'mediumpurple','mediumseagreen','mediumslateblue','mediumspringgreen',
  'mediumturquoise','mediumvioletred','midnightblue','mintcream',
  'mistyrose','moccasin','navajowhite','oldlace','olivedrab','orangered',
  'orchid','palegoldenrod','palegreen','paleturquoise','palevioletred',
  'papayawhip','peachpuff','peru','pink','plum','powderblue','rosybrown',
  'royalblue','saddlebrown','salmon','sandybrown','seagreen','seashell',
  'sienna','skyblue','slateblue','slategray','slategrey','snow',
  'springgreen','steelblue','tan','thistle','tomato','turquoise','violet',
  'wheat','whitesmoke','yellowgreen'
];

function plotRainbowColor(k) {
  var r, g, b;
  k += 21;
  k %= 126;
  if (k < 0) k += 126;
  if (k < 21) { r = 251; g = 0; b = 12 * k; }
  if (k >= 21 && k < 42) { r = 251 - 12 * (k - 21); g = 0; b = 251; }
  if (k >= 42 && k < 63) { r = 0; g = (k - 42) * 12; b = 251; }
  if (k >= 63 && k < 84) { r = 0; g = 251; b = 251 - (k - 63) * 12; }
  if (k >= 84 && k < 105) { r = (k - 84) * 12; g = 251; b = 0; }
  if (k >= 105 && k < 126) { r = 251; g = 251 - (k - 105) * 12; b = 0; }
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}

function plotResolveColor(c) {
  if (c >= 0x100) {
    if (c < 0x17e) return plotRainbowColor(c);
    var r = 8 * ((c >> 11) & 0x1f);
    var g = 4 * ((c >> 5) & 0x3f);
    var b = 8 * (c & 0x1f);
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  }
  return PLOT_COLORS[c] || 'black';
}

function detectPlotFormat(raw) {
  if (!raw || raw.length < 5) return 'text';
  if (raw.substr(0, 4) === '<svg' || (raw.charAt(0) === '"' && raw.substr(1, 4) === '<svg')) return 'svg';
  if (raw.substr(0, 5) === 'gr2d(') return 'gr2d';
  if (raw.substr(0, 5) === 'gl3d ') return 'gl3d';
  return 'text';
}

/** Strip surrounding quotes from Giac output if present */
function stripQuotes(s) {
  if (s.length >= 2 && s.charAt(0) === '"' && s.charAt(s.length - 1) === '"')
    return s.substring(1, s.length - 1);
  return s;
}

// T008: SVG plot renderer
function renderSvgPlot(outputEl, svgString) {
  var container = document.createElement('div');
  container.className = 'plot-container plot-svg';
  container.innerHTML = svgString;
  outputEl.appendChild(container);
}

// T009: Pixon (pixel) renderer â€” ported from giacsimple.js
function plotPixonDraw(canvas, dataString) {
  var v;
  try { v = JSON.parse(dataString); } catch(e) {
    try { v = (0, eval)(dataString); } catch(e2) { return; }
  }
  if (!Array.isArray(v) || v.length < 2) return;
  var l = v.length, w = 0, h = 0;
  var scale = v[0];
  for (var k = 1; k < l; k++) {
    var cur = v[k];
    var x = cur[0], y = cur[1];
    if (cur.length === 3 && typeof cur[2] !== 'number') { x += 100; y += 16; }
    if (cur.length === 4) {
      var tmp = cur[3];
      if (typeof tmp === 'number') { if (tmp > 0) y += tmp; else x -= tmp; }
      else { x += 100; y += 16; }
    }
    if (x > w) w = x;
    if (y > h) h = y;
  }
  w = (w + 1) * scale;
  h = (h + 1) * scale;
  canvas.width = w; canvas.height = h;
  var ctx = canvas.getContext('2d');
  if (!ctx) return;
  for (var k = 1; k < l; k++) {
    var cur = v[k], cl;
    if (!Array.isArray(cur) || (cl = cur.length) < 2) continue;
    var x = cur[0] * scale, y = cur[1] * scale;
    if (cl > 2 && typeof cur[2] === 'string') {
      ctx.font = '16px serif'; ctx.fillStyle = 'black';
      ctx.fillText(cur[2], x, y + 16, 100); continue;
    }
    ctx.fillStyle = (cl > 2) ? plotResolveColor(cur[2]) : 'black';
    if (cl < 4) { ctx.fillRect(x, y, scale, scale); continue; }
    if (typeof cur[3] === 'string') {
      ctx.font = '16px serif'; ctx.fillText(cur[3], x, y + 16, 100); continue;
    }
    var ph = cur[3] * scale, pw = scale;
    if (ph < 0) { pw = -ph; ph = scale; }
    ctx.fillRect(x, y, pw, ph);
  }
}

// T010: Logo (turtle) renderer â€” ported from giacsimple.js
function plotLogoDraw(canvas, dataString, zoom, dx, dy) {
  var v;
  try { v = JSON.parse(dataString); } catch(e) {
    try { v = (0, eval)(dataString); } catch(e2) { return; }
  }
  if (!Array.isArray(v) || v.length < 2) return;
  var w = canvas.width, h = canvas.height;
  var ctx = canvas.getContext('2d');
  if (!ctx) return;
  var turtlezoom = zoom || 1, turtlex = dx || 0, turtley = dy || 0;

  // Background
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, w, h);

  // Dot grid
  ctx.fillStyle = '#ddd';
  var xdecal = Math.floor(turtlex / 10.0) * 10;
  var ydecal = Math.floor(turtley / 10.0) * 10;
  for (var i = xdecal; i < w / turtlezoom + xdecal; i += 10) {
    for (var j = ydecal; j < h / turtlezoom + ydecal; j += 10) {
      var X = Math.floor((i - turtlex) * turtlezoom + .5);
      var Y = Math.floor((j - turtley) * turtlezoom + .5);
      ctx.fillRect(X, h - Y, 1, 1);
    }
  }

  var l = v.length;
  // v[i]=[x,y,cap,status,r,chaine]
  // color=status>>11, pen_down=status&1, visible=status&2
  for (var k = 1; k < l; k++) {
    var prec = v[k - 1], cur = v[k];
    var preccouleur = prec[3] >> 11;
    var curcouleur = cur[3] >> 11;
    if (cur[5] && cur[5].length) {
      ctx.font = cur[4] + 'px serif';
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(curcouleur);
      ctx.fillText(cur[5], turtlezoom * (cur[0] - turtlex), h - turtlezoom * (cur[1] - turtley));
      continue;
    }
    var radius = cur[4], precradius = prec[4];
    var x1 = Math.floor(turtlezoom * (prec[0] - turtlex) + .5),
        y1 = Math.floor(turtlezoom * (prec[1] - turtley) + .5),
        x2 = Math.floor(turtlezoom * (cur[0] - turtlex) + .5),
        y2 = Math.floor(turtlezoom * (cur[1] - turtley) + .5);
    if (radius > 0) {
      var r = radius & 0x1ff;
      var theta1 = prec[2] + ((radius >> 9) & 0x1ff);
      var theta2 = prec[2] + ((radius >> 18) & 0x1ff);
      var rempli = (radius >> 27) & 1;
      var seg = (radius >> 28) & 1;
      var R = Math.floor(turtlezoom * r + .5);
      var angle1 = Math.PI / 180 * (theta1 - 90);
      var angle2 = Math.PI / 180 * (theta2 - 90);
      var cx = Math.floor(turtlezoom * (cur[0] - turtlex - r * Math.cos(angle2)) + .5);
      var cy = Math.floor(turtlezoom * (cur[1] - turtley - r * Math.sin(angle2)) + .5);
      ctx.beginPath();
      if (seg) ctx.moveTo(x2, h - y2);
      else { ctx.moveTo(cx, h - cy); ctx.lineTo(x2, h - y2); }
      ctx.arc(cx, h - cy, R, -angle2, -angle1);
      ctx.closePath();
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(curcouleur);
      if (rempli) ctx.fill(); else ctx.stroke();
      continue;
    }
    if (prec[3] & 1) {
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(preccouleur);
      ctx.beginPath();
      ctx.moveTo(x1, h - y1); ctx.lineTo(x2, h - y2);
      ctx.closePath(); ctx.stroke();
    }
    if (radius < -1 && k + radius >= 0) {
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(curcouleur);
      ctx.beginPath();
      ctx.moveTo(x2, h - y2);
      for (var i = -1; i >= radius; i--) {
        var pv = v[k + i];
        ctx.lineTo(
          Math.floor(turtlezoom * (pv[0] - turtlex) + .5),
          h - Math.floor(turtlezoom * (pv[1] - turtley) + .5)
        );
      }
      ctx.closePath(); ctx.fill();
    }
  }
  // Draw turtle icon if visible
  var last = v[l - 1];
  if (last[3] & 2) {
    var tx = Math.floor(turtlezoom * (last[0] - turtlex) + .5);
    var ty = Math.floor(turtlezoom * (last[1] - turtley) + .5);
    var cost = Math.cos(last[2] * Math.PI / 180);
    var sint = Math.sin(last[2] * Math.PI / 180);
    var tlen = (last[3] >> 3) & 0xff;
    var Dx = Math.floor(turtlezoom * tlen * cost / 2 + .5);
    var Dy = Math.floor(turtlezoom * tlen * sint / 2 + .5);
    ctx.strokeStyle = plotResolveColor(last[3] >> 11);
    ctx.beginPath(); ctx.moveTo(tx + Dy, h - (ty - Dx)); ctx.lineTo(tx - Dy, h - (ty + Dx)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx + Dy, h - (ty - Dx)); ctx.lineTo(tx + 3 * Dx, h - (ty + 3 * Dy)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx - Dy, h - (ty + Dx)); ctx.lineTo(tx + 3 * Dx, h - (ty + 3 * Dy)); ctx.stroke();
  }
}

// T011: gr2d dispatcher â€” creates canvas and routes to logo or pixon
var plotCanvasCounter = 0;
var plotCanvasStates = {};

function renderGr2dPlot(outputEl, gr2dString) {
  var inner = gr2dString.substr(5, gr2dString.length - 6); // strip "gr2d(" and ")"
  var container = document.createElement('div');
  container.className = 'plot-container';
  var canvasId = 'plot-canvas-' + (++plotCanvasCounter);
  var canvas = document.createElement('canvas');
  canvas.id = canvasId;
  canvas.width = 600; canvas.height = 400;
  container.appendChild(canvas);
  outputEl.appendChild(container);

  if (inner.length > 6 && inner.substr(0, 6) === 'pixon(') {
    plotPixonDraw(canvas, inner.substr(6, inner.length - 7));
  } else if (inner.length > 5 && inner.substr(0, 5) === 'logo(') {
    var logoData = inner.substr(5, inner.length - 6);
    plotLogoDraw(canvas, logoData, 1, 0, 0);
    plotCanvasStates[canvasId] = { rawData: logoData, zoom: 1, dx: 0, dy: 0 };
    attachPlotInteractivity(canvas, canvasId);
  }
}

// T016-T019: Interactive plot features (zoom, pan, coordinate hover)
function attachPlotInteractivity(canvas, canvasId) {
  var state = plotCanvasStates[canvasId];
  if (!state) return;
  var container = canvas.parentElement;

  // Tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'plot-tooltip';
  container.appendChild(tooltip);

  // T017: Zoom via mouse wheel
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    var s = plotCanvasStates[canvasId];
    if (!s) return;
    var factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
    // Zoom toward mouse position
    var rect = canvas.getBoundingClientRect();
    var mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    var my = (e.clientY - rect.top) * (canvas.height / rect.height);
    var mathX = mx / s.zoom + s.dx;
    var mathY = (canvas.height - my) / s.zoom + s.dy;
    s.zoom *= factor;
    s.dx = mathX - mx / s.zoom;
    s.dy = mathY - (canvas.height - my) / s.zoom;
    plotLogoDraw(canvas, s.rawData, s.zoom, s.dx, s.dy);
  }, { passive: false });

  // T018: Pan via mouse drag
  var dragging = false, lastX = 0, lastY = 0;
  canvas.addEventListener('mousedown', function(e) {
    dragging = true; lastX = e.clientX; lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  canvas.addEventListener('mousemove', function(e) {
    var s = plotCanvasStates[canvasId];
    if (!s) return;
    if (dragging) {
      var rect = canvas.getBoundingClientRect();
      var scaleX = canvas.width / rect.width;
      var scaleY = canvas.height / rect.height;
      s.dx -= (e.clientX - lastX) * scaleX / s.zoom;
      s.dy += (e.clientY - lastY) * scaleY / s.zoom;
      lastX = e.clientX; lastY = e.clientY;
      plotLogoDraw(canvas, s.rawData, s.zoom, s.dx, s.dy);
    }
    // T019: Coordinate hover
    var rect = canvas.getBoundingClientRect();
    var px = (e.clientX - rect.left) * (canvas.width / rect.width);
    var py = (e.clientY - rect.top) * (canvas.height / rect.height);
    var mx = px / s.zoom + s.dx;
    var my = (canvas.height - py) / s.zoom + s.dy;
    tooltip.textContent = '(' + mx.toFixed(2) + ', ' + my.toFixed(2) + ')';
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 12) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 8) + 'px';
  });
  canvas.addEventListener('mouseup', function() { dragging = false; canvas.style.cursor = 'crosshair'; });
  canvas.addEventListener('mouseleave', function() { dragging = false; canvas.style.cursor = 'crosshair'; tooltip.style.display = 'none'; });
  canvas.style.cursor = 'crosshair';
}

// â”€â”€ JSXGraph integration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Parses Giac SVG/gr2d output and renders interactive plots
// using JSXGraph when available, with canvas/SVG fallback.

function jsxGraphAvailable() {
  return typeof JXG !== 'undefined' && JXG.JSXGraph;
}

var jsxGraphBoardCounter = 0;
var jsxGraphBoards = {};

function cleanupJSXGraphBoard(boardId) {
  if (jsxGraphBoards[boardId]) {
    try { JXG.JSXGraph.freeBoard(jsxGraphBoards[boardId]); } catch(e) {}
    delete jsxGraphBoards[boardId];
  }
}

function cleanupJSXGraphInElement(el) {
  var boxes = el.querySelectorAll('.jxgbox');
  boxes.forEach(function(box) { cleanupJSXGraphBoard(box.id); });
}

/** Parse Giac SVG output into curve data for JSXGraph */
function parseSvgPlotData(svgString) {
  var parser = new DOMParser();
  // Use text/html (lenient) because Giac SVG may have malformed attributes (missing spaces)
  var doc = parser.parseFromString(svgString, 'text/html');
  var svg = doc.querySelector('svg');
  if (!svg) return null;

  // Giac SVG uses math coordinates directly in line/path elements.
  // A <g transform="scale(1,-1)"> handles the y-flip for SVG rendering.
  // We read the raw attribute values as math coordinates â€” no y-negation needed.

  var curves = [];
  var defaultColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'];
  var colorIdx = 0;

  // Group <line> elements by color+strokeWidth
  var lineGroups = {};
  var lines = svg.querySelectorAll('line');
  lines.forEach(function(ln) {
    var x1 = parseFloat(ln.getAttribute('x1')), y1 = parseFloat(ln.getAttribute('y1'));
    var x2 = parseFloat(ln.getAttribute('x2')), y2 = parseFloat(ln.getAttribute('y2'));
    if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) return;
    var color = ln.getAttribute('stroke') || 'black';
    var sw = parseFloat(ln.getAttribute('stroke-width')) || 1;
    var key = color + '|' + sw;
    if (!lineGroups[key]) lineGroups[key] = { color: color, strokeWidth: sw, segments: [] };
    lineGroups[key].segments.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
  });

  // Build curves from line groups â€” need many segments (skip axes/borders)
  Object.keys(lineGroups).forEach(function(key) {
    var group = lineGroups[key];
    // Plot curves have many segments (50+), axis/border lines have few (<10)
    if (group.segments.length < 10) return;
    var segs = group.segments;
    var xs = [segs[0].x1], ys = [segs[0].y1];
    for (var i = 0; i < segs.length; i++) {
      xs.push(segs[i].x2); ys.push(segs[i].y2);
    }
    if (xs.length > 1) {
      curves.push({ xs: xs, ys: ys, color: group.color });
    }
  });

  // Extract polyline elements
  var polylines = svg.querySelectorAll('polyline');
  polylines.forEach(function(pl) {
    var pts = pl.getAttribute('points');
    if (!pts) return;
    var pairs = pts.trim().split(/\s+/);
    var xs = [], ys = [];
    pairs.forEach(function(p) {
      var xy = p.split(',');
      if (xy.length === 2) {
        xs.push(parseFloat(xy[0]));
        ys.push(parseFloat(xy[1]));
      }
    });
    if (xs.length > 1) {
      var color = pl.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
      curves.push({ xs: xs, ys: ys, color: color });
    }
  });

  // Extract path elements
  var paths = svg.querySelectorAll('path');
  paths.forEach(function(path) {
    var d = path.getAttribute('d');
    if (!d) return;
    var xs = [], ys = [];
    var commands = d.match(/[MLCQZ][^MLCQZ]*/gi);
    if (!commands) return;
    commands.forEach(function(cmd) {
      var type = cmd.charAt(0);
      var nums = cmd.slice(1).trim().split(/[\s,]+/).map(Number);
      if (type === 'M' || type === 'L') {
        for (var i = 0; i + 1 < nums.length; i += 2) {
          xs.push(nums[i]);
          ys.push(nums[i + 1]);
        }
      } else if (type === 'C') {
        for (var i = 0; i + 5 < nums.length; i += 6) {
          var px = xs.length > 0 ? xs[xs.length - 1] : 0;
          var py = ys.length > 0 ? ys[ys.length - 1] : 0;
          var cp1x = nums[i], cp1y = nums[i+1];
          var cp2x = nums[i+2], cp2y = nums[i+3];
          var ex = nums[i+4], ey = nums[i+5];
          for (var t = 1; t <= 20; t++) {
            var u = t / 20, u2 = u*u, u3 = u2*u, inv = 1-u, inv2 = inv*inv, inv3 = inv2*inv;
            xs.push(inv3*px + 3*inv2*u*cp1x + 3*inv*u2*cp2x + u3*ex);
            ys.push(inv3*py + 3*inv2*u*cp1y + 3*inv*u2*cp2y + u3*ey);
          }
        }
      } else if (type === 'Q') {
        for (var i = 0; i + 3 < nums.length; i += 4) {
          var px = xs.length > 0 ? xs[xs.length - 1] : 0;
          var py = ys.length > 0 ? ys[ys.length - 1] : 0;
          var cpx = nums[i], cpy = nums[i+1];
          var ex = nums[i+2], ey = nums[i+3];
          for (var t = 1; t <= 20; t++) {
            var u = t / 20, inv = 1-u;
            xs.push(inv*inv*px + 2*inv*u*cpx + u*u*ex);
            ys.push(inv*inv*py + 2*inv*u*cpy + u*u*ey);
          }
        }
      }
    });
    if (xs.length > 1) {
      var color = path.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
      curves.push({ xs: xs, ys: ys, color: color });
    }
  });

  if (curves.length === 0) return null;

  // Compute tight bounding box from actual curve data
  var allXs = [], allYs = [];
  curves.forEach(function(c) { allXs = allXs.concat(c.xs); allYs = allYs.concat(c.ys); });
  var dataXmin = Math.min.apply(null, allXs), dataXmax = Math.max.apply(null, allXs);
  var dataYmin = Math.min.apply(null, allYs), dataYmax = Math.max.apply(null, allYs);
  var padX = (dataXmax - dataXmin) * 0.08 || 1;
  var padY = (dataYmax - dataYmin) * 0.08 || 1;
  var bbox = {
    xmin: dataXmin - padX, xmax: dataXmax + padX,
    ymin: dataYmin - padY, ymax: dataYmax + padY
  };

  return { curves: curves, bbox: bbox };
}

/** Parse gr2d(logo(...)) output into curve data for JSXGraph */
function parseGr2dLogoData(gr2dString) {
  var inner = gr2dString.substr(5, gr2dString.length - 6); // strip "gr2d(" and ")"
  if (inner.length < 6 || inner.substr(0, 5) !== 'logo(') return null;
  var logoData = inner.substr(5, inner.length - 6);
  var v;
  try { v = JSON.parse(logoData); } catch(e) {
    try { v = (0, eval)(logoData); } catch(e2) { return null; }
  }
  if (!Array.isArray(v) || v.length < 2) return null;

  // Group consecutive pen-down vertices by color into curve segments
  var curves = [];
  var currentXs = [], currentYs = [], currentColor = null;

  for (var k = 1; k < v.length; k++) {
    var prec = v[k - 1], cur = v[k];
    // Skip text labels
    if (cur[5] && cur[5].length) continue;
    var penDown = prec[3] & 1;
    var colorIdx = prec[3] >> 11;
    var color = plotResolveColor(colorIdx);

    if (penDown && cur[4] === 0) { // Normal line segment (not arc/polygon)
      if (color !== currentColor) {
        // Flush previous segment
        if (currentXs.length > 1) {
          curves.push({ xs: currentXs.slice(), ys: currentYs.slice(), color: currentColor });
        }
        currentXs = [prec[0]]; currentYs = [prec[1]];
        currentColor = color;
      } else if (currentXs.length === 0) {
        currentXs.push(prec[0]); currentYs.push(prec[1]);
      }
      currentXs.push(cur[0]); currentYs.push(cur[1]);
    } else {
      // Flush on non-line segment
      if (currentXs.length > 1) {
        curves.push({ xs: currentXs.slice(), ys: currentYs.slice(), color: currentColor });
      }
      currentXs = []; currentYs = []; currentColor = null;

      // Handle arcs: sample points along the arc
      if (cur[4] > 0) {
        var radius = cur[4];
        var r = radius & 0x1ff;
        var theta1 = prec[2] + ((radius >> 9) & 0x1ff);
        var theta2 = prec[2] + ((radius >> 18) & 0x1ff);
        var angle1 = theta1 * Math.PI / 180;
        var angle2 = theta2 * Math.PI / 180;
        var cx = cur[0] - r * Math.cos((theta2 - 90) * Math.PI / 180);
        var cy = cur[1] - r * Math.sin((theta2 - 90) * Math.PI / 180);
        var arcColor = plotResolveColor(cur[3] >> 11);
        var arcXs = [], arcYs = [];
        var steps = Math.max(40, Math.abs(theta2 - theta1));
        for (var s = 0; s <= steps; s++) {
          var a = ((theta1 - 90) + (theta2 - theta1 - 90 + 90) * s / steps) * Math.PI / 180;
          // Simpler: linearly interpolate angle
          var aa = angle1 + (angle2 - angle1) * s / steps;
          arcXs.push(cx + r * Math.cos(aa));
          arcYs.push(cy + r * Math.sin(aa));
        }
        if (arcXs.length > 1) {
          curves.push({ xs: arcXs, ys: arcYs, color: arcColor });
        }
      }
    }
  }
  // Flush final segment
  if (currentXs.length > 1) {
    curves.push({ xs: currentXs.slice(), ys: currentYs.slice(), color: currentColor });
  }

  if (curves.length === 0) return null;

  // Compute bounding box
  var allXs = [], allYs = [];
  curves.forEach(function(c) { allXs = allXs.concat(c.xs); allYs = allYs.concat(c.ys); });
  var xmin = Math.min.apply(null, allXs), xmax = Math.max.apply(null, allXs);
  var ymin = Math.min.apply(null, allYs), ymax = Math.max.apply(null, allYs);
  var padX = (xmax - xmin) * 0.08 || 1;
  var padY = (ymax - ymin) * 0.08 || 1;

  return {
    curves: curves,
    bbox: { xmin: xmin - padX, xmax: xmax + padX, ymin: ymin - padY, ymax: ymax + padY }
  };
}

/** Render plot data using JSXGraph */
function renderJSXGraphPlot(outputEl, plotData) {
  var boardId = 'jsxgraph-' + (++jsxGraphBoardCounter);
  var wrapper = document.createElement('div');
  wrapper.className = 'jxgbox-container';
  var box = document.createElement('div');
  box.id = boardId;
  box.className = 'jxgbox';
  wrapper.appendChild(box);
  outputEl.appendChild(wrapper);

  var bb = plotData.bbox;
  var board = JXG.JSXGraph.initBoard(boardId, {
    boundingbox: [bb.xmin, bb.ymax, bb.xmax, bb.ymin],
    axis: true,
    showCopyright: false,
    showNavigation: true,
    pan: { enabled: true },
    zoom: { enabled: true, wheel: true, pinch: true }
  });

  var defaultColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'];
  plotData.curves.forEach(function(curve, idx) {
    var color = curve.color || defaultColors[idx % defaultColors.length];
    board.create('curve', [curve.xs, curve.ys], {
      strokeColor: color,
      strokeWidth: 2,
      highlight: false
    });
  });

  jsxGraphBoards[boardId] = board;
  return board;
}

// T012: gl3d message
function renderGl3dMessage(outputEl) {
  var msg = document.createElement('div');
  msg.className = 'plot-3d-msg';
  msg.textContent = t('plot3dNotSupported');
  outputEl.appendChild(msg);
}

</script>
</body>
</html>
