<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Xcas Reactive Notebook</title>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  External dependencies (loaded from CDN)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script src="https://unpkg.com/mathlive"></script>
<script src="https://unpkg.com/@cortex-js/compute-engine"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css">
<script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
<script>
  // Observable Runtime â€” loaded dynamically to avoid timing issues with module scripts
  window._ObservableRuntime = null;
  window._observableReady = new Promise(function(resolve) {
    window._observableResolve = resolve;
  });
  import('https://cdn.jsdelivr.net/npm/@observablehq/runtime@6/+esm').then(function(mod) {
    window._ObservableRuntime = mod.Runtime;
    window._observableResolve();
    console.log('Observable Runtime loaded');
  }).catch(function(e) {
    console.warn('Observable Runtime failed to load:', e);
    window._observableResolve(); // resolve anyway so boot continues
  });
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Giac/Xcas engine (asm.js) â€” HOST giac.js LOCALLY
  Download: https://www-fourier.univ-grenoble-alpes.fr/~parisse/giacjs.tar.gz
  We bypass giacsimple.js and define a minimal Module object
  so giac.js (Emscripten asm.js build) can initialize.
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div style="position:absolute;left:-9999px;width:0;height:0;overflow:hidden"><canvas id="canvas" width="1" height="1"></canvas></div>
<script>
var Module = {
  ready: false,
  canvas: document.getElementById('canvas'),
  preRun: [],
  postRun: [],
  print: function(text) { console.log('giac:', text); },
  printErr: function(text) { console.warn('giac:', text); },
  setStatus: function(text) { if (text) console.log('giac status:', text); },
  totalDependencies: 0,
  monitorRunDependencies: function(left) {
    this.totalDependencies = Math.max(this.totalDependencies, left);
  },
  onRuntimeInitialized: function() {
    console.log('Giac runtime initialized');
    Module.ready = true;
  }
};
// Minimal UI stub â€” giac.js references UI.* during some computations
var UI = {
  Datestart: Date.now(),
  disable3d: 0,
  warnpy: false,
  python_output: '',
  assistant_matr_maxrows: 100,
  assistant_matr_maxcols: 100,
  clean_for_html: function(s) { return s; },
  add_python_output: function(s) { UI.python_output += s; },
  set_config_width: function() {},
  open_sheet: function() {},
  sheet_recompute: function() {},
  sheet_set_ij: function() {}
};
</script>
<script src="giac.js"></script>

<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Newsreader:ital,opsz,wght@0,6..72,400;0,6..72,500;1,6..72,400&display=swap');

  :root {
    --bg:#f4f2ed;--surface:#fff;--border:#d9d4ca;--border-focus:#2563eb;
    --text:#1c1917;--text-muted:#78716c;--output-bg:#fafaf6;
    --accent:#2563eb;--accent-hover:#1d4ed8;--accent-light:#eff3ff;
    --success:#15803d;--error:#b91c1c;--warning:#ca8a04;
    --shadow-sm:0 1px 2px rgba(0,0,0,0.04);--shadow:0 2px 8px rgba(0,0,0,0.06);
    --radius:10px;
    --mono:'JetBrains Mono','Menlo','Consolas',monospace;
    --body:'Newsreader','Georgia',serif;
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:var(--body);background:var(--bg);color:var(--text);line-height:1.65}

  /* â•â•â•â•â•â•â• Header â•â•â•â•â•â•â• */
  .header{background:#0c0f1a;color:#eae8e0;padding:1.6rem 2rem 1.2rem;position:relative;overflow:hidden}
  .header::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse 500px 250px at 5% 90%,rgba(37,99,235,.12),transparent),radial-gradient(ellipse 350px 180px at 95% 10%,rgba(168,85,247,.08),transparent);pointer-events:none}
  .header-inner{position:relative;max-width:960px;margin:0 auto;display:flex;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;gap:.5rem}
  .header-left h1{font-family:var(--mono);font-size:1.35rem;font-weight:500;letter-spacing:-.3px}
  .header-left p{font-size:.82rem;opacity:.5;margin-top:.1rem;font-family:var(--mono)}
  .header-right{display:flex;align-items:center;gap:.75rem;margin-top:.2rem}
  #giac-status{display:inline-flex;align-items:center;gap:5px;font-family:var(--mono);font-size:.7rem;padding:4px 11px;border-radius:20px;background:rgba(255,255,255,.07);transition:background .3s}
  #giac-status .dot{width:7px;height:7px;border-radius:50%;background:#facc15;transition:background .3s}
  #giac-status.ready .dot{background:#4ade80}
  #giac-status.error .dot{background:#f87171}
  .lang-select{font-family:var(--mono);font-size:.7rem;padding:3px 8px;border-radius:5px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.06);color:#eae8e0;cursor:pointer;outline:none}
  .lang-select:hover{border-color:rgba(255,255,255,.3)}
  .lang-select option{background:#1c1917;color:#eae8e0}

  /* â•â•â•â•â•â•â• Toolbar â•â•â•â•â•â•â• */
  .toolbar-wrap{border-bottom:1px solid var(--border);background:var(--surface);padding:0 2rem}
  .toolbar{max-width:960px;margin:0 auto;display:flex;gap:.4rem;padding:.6rem 0;flex-wrap:wrap;align-items:center}
  .toolbar button{font-family:var(--mono);font-size:.72rem;padding:5px 12px;border:1px solid var(--border);border-radius:6px;background:var(--bg);color:var(--text);cursor:pointer;transition:all .15s;white-space:nowrap}
  .toolbar button:hover{background:var(--accent);color:#fff;border-color:var(--accent)}
  .toolbar button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
  .toolbar button.primary:hover{background:var(--accent-hover)}
  .toolbar .sep{width:1px;height:20px;background:var(--border);margin:0 .15rem}

  /* â•â•â•â•â•â•â• Notebook â•â•â•â•â•â•â• */
  .notebook{max-width:960px;margin:1.2rem auto;padding:0 1rem 5rem}

  /* â•â•â•â•â•â•â• Cell â•â•â•â•â•â•â• */
  .cell{background:var(--surface);border:1.5px solid var(--border);border-radius:var(--radius);margin-bottom:.6rem;box-shadow:var(--shadow-sm);transition:border-color .2s,box-shadow .2s}
  .cell:focus-within{border-color:var(--border-focus);box-shadow:0 0 0 3px rgba(37,99,235,.07)}
  .cell.running{border-color:var(--warning)}
  .cell-head{display:flex;align-items:center;padding:.3rem .7rem;border-bottom:1px solid var(--border);background:#fafaf7;border-radius:var(--radius) var(--radius) 0 0;gap:.45rem;min-height:30px}
  .cell-idx{font-family:var(--mono);font-size:.66rem;color:var(--text-muted);min-width:44px}
  .cell-badge{font-family:var(--mono);font-size:.6rem;padding:1px 7px;border-radius:4px;color:#fff;letter-spacing:.3px;text-transform:uppercase}
  .cell-badge.math{background:#7c3aed}.cell-badge.text{background:#d97706}.cell-badge.raw{background:#64748b}
  .mode-toggle{font-family:var(--mono);font-size:.63rem;display:flex;border:1px solid var(--border);border-radius:4px;overflow:hidden;margin-left:.2rem}
  .mode-toggle button{padding:2px 7px;border:none;background:transparent;color:var(--text-muted);cursor:pointer;font-family:inherit;font-size:inherit;transition:all .15s}
  .mode-toggle button.active{background:var(--accent);color:#fff}
  .mode-toggle button:hover:not(.active){background:var(--accent-light)}
  .cell-actions{margin-left:auto;display:flex;gap:3px;opacity:0;transition:opacity .15s}
  .cell:hover .cell-actions{opacity:1}
  .cell-actions button{font-size:.66rem;padding:2px 7px;border:none;border-radius:3px;background:transparent;color:var(--text-muted);cursor:pointer;font-family:var(--mono)}
  .cell-actions button:hover{background:#eee;color:var(--text)}
  .cell-actions button.del:hover{background:#fee;color:var(--error)}

  /* â•â•â•â•â•â•â• Input â•â•â•â•â•â•â• */
  .cell-input{padding:.65rem .8rem;min-height:46px}
  .cell-input math-field{width:100%;font-size:1.2rem;border:none;outline:none;--caret-color:var(--accent);--selection-background-color:rgba(37,99,235,.12)}
  .cell-input textarea{width:100%;min-height:34px;border:none;outline:none;font-family:var(--mono);font-size:.8rem;color:var(--text);background:transparent;resize:vertical;line-height:1.55}

  /* â•â•â•â•â•â•â• Debug â•â•â•â•â•â•â• */
  .cell-debug{padding:.3rem .8rem;background:#f7f6f2;border-top:1px dashed var(--border);font-family:var(--mono);font-size:.65rem;color:var(--text-muted);display:none;overflow-x:auto;word-break:break-all}
  .cell-debug.visible{display:block}
  .cell-debug .lbl{font-weight:500;color:var(--accent);margin-right:.3rem}
  .cell-debug .xcas-out{color:var(--success);margin-left:.4rem}

  /* â•â•â•â•â•â•â• Output â•â•â•â•â•â•â• */
  .cell-output{padding:.65rem .8rem;background:var(--output-bg);border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);min-height:26px;overflow-x:auto}
  .cell-output:empty{display:none}
  .cell-output .err{color:var(--error);font-family:var(--mono);font-size:.78rem}
  .cell-output .katex-display{margin:.2rem 0;text-align:left}
  .cell-output .raw-res{font-family:var(--mono);font-size:.72rem;color:var(--text-muted);margin-top:.3rem;white-space:pre-wrap}
  .cell-output .md-out{font-family:var(--body);font-size:.93rem}
  .cell-output .md-out h1{font-size:1.35rem;margin:.35rem 0}
  .cell-output .md-out h2{font-size:1.1rem;margin:.3rem 0}
  .cell-output .md-out h3{font-size:.95rem;margin:.25rem 0}
  .cell-output .md-out p{margin:.3rem 0}
  .cell-output .md-out code{background:#eee;padding:1px 5px;border-radius:3px;font-family:var(--mono);font-size:.83em}
  .spinner{display:inline-block;width:12px;height:12px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .5s linear infinite;vertical-align:middle;margin-right:5px}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* â•â•â•â•â•â•â• Plot â•â•â•â•â•â•â• */
  .plot-container{margin:.3rem 0;position:relative}
  .plot-container canvas{max-width:100%;height:auto;display:block;border:1px solid var(--border);border-radius:4px}
  .plot-svg{overflow:hidden}
  .plot-svg svg{max-width:100%;height:auto;display:block}
  .plot-tooltip{position:absolute;background:rgba(0,0,0,.8);color:#fff;font-family:var(--mono);font-size:.65rem;padding:2px 6px;border-radius:3px;pointer-events:none;white-space:nowrap;z-index:5;display:none}
  .plot-3d-msg{font-family:var(--mono);font-size:.78rem;color:var(--warning);padding:.4rem;background:#fffbeb;border:1px solid #fde68a;border-radius:4px}
  .jxgbox-container{margin:.3rem 0}
  .jxgbox-container .jxgbox{width:100%;aspect-ratio:4/3;max-width:600px;border-radius:4px}
  .gl3d-container{margin:.3rem 0;position:relative}
  .gl3d-container canvas{max-width:100%;height:auto;display:block;border:1px solid var(--border);border-radius:4px;cursor:grab}
  .gl3d-container canvas:active{cursor:grabbing}

  /* â•â•â•â•â•â•â• Reactive DAG â•â•â•â•â•â•â• */
  .cell.dep-upstream{border-color:#7c3aed;box-shadow:0 0 0 2px rgba(124,58,237,.15)}
  .cell.dep-downstream{border-color:#059669;box-shadow:0 0 0 2px rgba(5,150,105,.15)}
  .cell.cell-pending{border-color:var(--warning);opacity:.7}
  .cell.cell-pending::after{content:'';position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,var(--warning),transparent);animation:pendingPulse 1.5s ease-in-out infinite}
  @keyframes pendingPulse{0%,100%{opacity:.3}50%{opacity:1}}
  .cell.cell-stale{border-color:var(--warning);border-style:dashed}
  .cell.cell-error .cell-output{border-left:3px solid var(--error)}
  .reactive-toggle{display:inline-flex;align-items:center;gap:4px;font-family:var(--mono);font-size:.72rem;cursor:pointer}
  .reactive-toggle input[type="checkbox"]{accent-color:var(--success);cursor:pointer}
  .reactive-toggle .reactive-label{color:var(--text-muted);transition:color .2s}
  .reactive-toggle input:checked+.reactive-label{color:var(--success);font-weight:500}
  .dep-warning{font-family:var(--mono);font-size:.72rem;padding:.3rem .5rem;border-radius:4px;margin:.2rem 0}
  .dep-warning.cycle{background:#fef2f2;color:var(--error);border:1px solid #fecaca}
  .dep-warning.broken{background:#fffbeb;color:var(--warning);border:1px solid #fde68a}
  .dep-warning.duplicate{background:#eff6ff;color:var(--accent);border:1px solid #bfdbfe}
  .stale-banner{background:#fffbeb;border:1px solid #fde68a;border-radius:6px;padding:.5rem 1rem;margin:.5rem 0;display:flex;align-items:center;gap:.5rem;font-family:var(--mono);font-size:.75rem;color:var(--warning)}
  .stale-banner button{font-family:var(--mono);font-size:.7rem;padding:3px 10px;border:1px solid var(--warning);border-radius:4px;background:transparent;color:var(--warning);cursor:pointer}
  .stale-banner button:hover{background:var(--warning);color:#fff}

  /* â•â•â•â•â•â•â• Bottom bar â•â•â•â•â•â•â• */
  .bottombar{position:fixed;bottom:0;left:0;right:0;background:var(--surface);border-top:1px solid var(--border);padding:.4rem 1.5rem;font-family:var(--mono);font-size:.63rem;color:var(--text-muted);display:flex;gap:1.4rem;align-items:center;z-index:10}
  .bottombar kbd{background:#eeede8;padding:1px 5px;border-radius:3px;border:1px solid var(--border);font-size:.62rem}
  .bottombar label{display:flex;align-items:center;gap:4px;cursor:pointer}
  .bottombar input[type="checkbox"]{accent-color:var(--accent)}
</style>
</head>
<body>

<div class="header"><div class="header-inner">
  <div class="header-left">
    <h1>ğŸ““ <span data-i18n="title">Xcas Notebook</span></h1>
    <p data-i18n="subtitle">Reactive CAS â€” MathJSON â†” Giac via WebAssembly</p>
    <a href="https://github.com/s-celles/giac-cas-online" target="_blank" rel="noopener" style="font-size:.85rem;opacity:.7;text-decoration:none;color:inherit"><svg height="16" width="16" viewBox="0 0 24 24" style="vertical-align:text-bottom;margin-right:.3em;fill:none;stroke:currentColor;stroke-width:2;stroke-linecap:round;stroke-linejoin:round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>Source code</a>
  </div>
  <div class="header-right">
    <select class="lang-select" id="lang-select" onchange="setLocale(this.value)">
      <option value="en">English</option>
      <option value="fr">FranÃ§ais</option>
      <option value="es">EspaÃ±ol</option>
      <option value="de">Deutsch</option>
    </select>
    <div id="giac-status">
      <span class="dot"></span>
      <span class="text" data-i18n="giacLoading">Loading Giacâ€¦</span>
    </div>
  </div>
</div></div>

<div class="toolbar-wrap"><div class="toolbar">
  <button onclick="addCell('math')" data-i18n="addMath">+ Math</button>
  <button onclick="addCell('raw')" data-i18n="addRaw">+ Xcas raw</button>
  <button onclick="addCell('text')" data-i18n="addText">+ Text</button>
  <div class="sep"></div>
  <button class="primary" onclick="runAll()" data-i18n="runAll">â–¶ Run all</button>
  <button onclick="clearAllOutputs()" data-i18n="clearOutputs">âœ• Clear outputs</button>
  <div class="sep"></div>
  <button onclick="exportNotebook()" data-i18n="exportBtn">ğŸ’¾ Export</button>
  <button onclick="importNotebook()" data-i18n="importBtn">ğŸ“‚ Import</button>
  <div class="sep"></div>
  <label class="reactive-toggle"><input type="checkbox" id="reactive-toggle" checked onchange="toggleReactiveMode(this.checked)"><span class="reactive-label" data-i18n="reactiveToggle">Reactive</span></label>
</div></div>

<div class="notebook" id="notebook"></div>

<div class="bottombar">
  <span><kbd>Shift</kbd>+<kbd>Enter</kbd> <span data-i18n="shortcutRun">Run</span></span>
  <span><kbd>Ctrl</kbd>+<kbd>Enter</kbd> <span data-i18n="shortcutRunNew">Run + new cell</span></span>
  <span><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Enter</kbd> Run (no cascade)</span>
  <label><input type="checkbox" id="toggle-debug" onchange="toggleAllDebug(this.checked)">
    <span data-i18n="showMathJSON">Show MathJSON</span></label>
</div>

<script>
'use strict';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 1 â€” INTERNATIONALIZATION (i18n)
//
// All user-facing strings live in LOCALES. Any element with
// data-i18n="key" is auto-updated when the locale changes.
//
// To add a language:
//   1. Add an entry to LOCALES
//   2. Add an <option> in #lang-select
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const LOCALES = {
  en: {
    title: 'Xcas Notebook',
    subtitle: 'Reactive CAS â€” MathJSON â†” Giac via WebAssembly',
    giacLoading: 'Loading Giacâ€¦',
    giacReady: 'Giac ready',
    giacError: 'Giac init error',
    giacDemo: 'Demo mode (Giac not loaded)',
    addMath: '+ Math', addRaw: '+ Xcas raw', addText: '+ Text',
    runAll: 'â–¶ Run all', clearOutputs: 'âœ• Clear outputs',
    exportBtn: 'ğŸ’¾ Export', importBtn: 'ğŸ“‚ Import',
    shortcutRun: 'Run', shortcutRunNew: 'Run + new cell',
    showMathJSON: 'Show MathJSON',
    cellMath: 'Math', cellRaw: 'Xcas', cellText: 'Text',
    placeholderRaw: 'Xcas syntax (e.g. factor(x^4-1))',
    placeholderText: 'Notes, Markdownâ€¦',
    computing: 'Computingâ€¦',
    giacNotReady: 'â³ Giac is still loadingâ€¦',
    errorPrefix: 'âœ— Error:',
    moveUp: 'Move up', moveDown: 'Move down',
    deleteCell: 'Delete', runCell: 'Run',
    modeVisual: 'Visual math input', modeRaw: 'Raw Xcas syntax',
    invalidJson: 'Invalid JSON file',
    welcomeTitle: '# Welcome to the Xcas Notebook',
    welcomeBody: 'Type math visually (MathJSON) or use raw Xcas syntax.\nTick **Show MathJSON** at the bottom to inspect the conversion pipeline.',
    plot3dNotSupported: '3D plots are not yet supported. Use 2D plot commands instead.',
    plotCoordinates: 'Coordinates',
    reactiveToggle: 'Reactive',
    pendingEvaluation: 'Pendingâ€¦',
    dependencyError: 'Dependency error: upstream cell failed',
    cyclicDependency: 'Circular dependency detected',
    duplicateVariable: 'Duplicate variable definition',
    brokenDependency: 'Broken dependency: upstream cell deleted',
    staleOutputWarning: 'Some outputs may be stale. Re-evaluate all?',
    reEvalAll: 'Re-evaluate all',
    cancelCascade: 'Cancel',
    reactiveReady: 'Reactive mode enabled. Click "Run all" to build the dependency graph and evaluate.',
    runAllReactive: 'â–¶ Run all (reactive)',
  },
  fr: {
    title: 'Notebook Xcas',
    subtitle: 'Calcul formel rÃ©actif â€” MathJSON â†” Giac via WebAssembly',
    giacLoading: 'Chargement de Giacâ€¦',
    giacReady: 'Giac prÃªt',
    giacError: 'Erreur init Giac',
    giacDemo: 'Mode dÃ©mo (Giac non chargÃ©)',
    addMath: '+ Math', addRaw: '+ Xcas brut', addText: '+ Texte',
    runAll: 'â–¶ Tout exÃ©cuter', clearOutputs: 'âœ• Effacer sorties',
    exportBtn: 'ğŸ’¾ Exporter', importBtn: 'ğŸ“‚ Importer',
    shortcutRun: 'ExÃ©cuter', shortcutRunNew: 'ExÃ©cuter + nouvelle cellule',
    showMathJSON: 'Afficher MathJSON',
    cellMath: 'Math', cellRaw: 'Xcas', cellText: 'Texte',
    placeholderRaw: 'Syntaxe Xcas (ex : factor(x^4-1))',
    placeholderText: 'Notes, Markdownâ€¦',
    computing: 'Calcul en coursâ€¦',
    giacNotReady: 'â³ Giac en chargementâ€¦',
    errorPrefix: 'âœ— Erreur :',
    moveUp: 'Monter', moveDown: 'Descendre',
    deleteCell: 'Supprimer', runCell: 'ExÃ©cuter',
    modeVisual: 'Saisie math visuelle', modeRaw: 'Syntaxe Xcas brute',
    invalidJson: 'Fichier JSON invalide',
    welcomeTitle: '# Bienvenue dans le Notebook Xcas',
    welcomeBody: 'Saisissez des maths visuellement (MathJSON) ou en syntaxe Xcas brute.\nCochez **Afficher MathJSON** en bas pour inspecter la conversion.',
    plot3dNotSupported: 'Les graphiques 3D ne sont pas encore pris en charge. Utilisez les commandes de tracÃ© 2D.',
    plotCoordinates: 'CoordonnÃ©es',
    reactiveToggle: 'RÃ©actif',
    pendingEvaluation: 'En attenteâ€¦',
    dependencyError: 'Erreur de dÃ©pendance : la cellule amont a Ã©chouÃ©',
    cyclicDependency: 'DÃ©pendance circulaire dÃ©tectÃ©e',
    duplicateVariable: 'DÃ©finition de variable en double',
    brokenDependency: 'DÃ©pendance cassÃ©e : cellule amont supprimÃ©e',
    staleOutputWarning: 'Certaines sorties peuvent Ãªtre obsolÃ¨tes. Tout rÃ©Ã©valuer ?',
    reEvalAll: 'Tout rÃ©Ã©valuer',
    cancelCascade: 'Annuler',
    reactiveReady: 'Mode rÃ©actif activÃ©. Cliquez sur Â« Tout exÃ©cuter Â» pour construire le graphe de dÃ©pendances et Ã©valuer.',
    runAllReactive: 'â–¶ Tout exÃ©cuter (rÃ©actif)',
  },
  es: {
    title: 'Cuaderno Xcas',
    subtitle: 'CAS reactivo â€” MathJSON â†” Giac vÃ­a WebAssembly',
    giacLoading: 'Cargando Giacâ€¦',
    giacReady: 'Giac listo',
    giacError: 'Error al iniciar Giac',
    giacDemo: 'Modo demo (Giac no cargado)',
    addMath: '+ Mate', addRaw: '+ Xcas directo', addText: '+ Texto',
    runAll: 'â–¶ Ejecutar todo', clearOutputs: 'âœ• Limpiar salidas',
    exportBtn: 'ğŸ’¾ Exportar', importBtn: 'ğŸ“‚ Importar',
    shortcutRun: 'Ejecutar', shortcutRunNew: 'Ejecutar + nueva celda',
    showMathJSON: 'Mostrar MathJSON',
    cellMath: 'Mate', cellRaw: 'Xcas', cellText: 'Texto',
    placeholderRaw: 'Sintaxis Xcas (ej: factor(x^4-1))',
    placeholderText: 'Notas, Markdownâ€¦',
    computing: 'Calculandoâ€¦',
    giacNotReady: 'â³ Giac estÃ¡ cargandoâ€¦',
    errorPrefix: 'âœ— Error:',
    moveUp: 'Subir', moveDown: 'Bajar',
    deleteCell: 'Eliminar', runCell: 'Ejecutar',
    modeVisual: 'Entrada visual', modeRaw: 'Sintaxis Xcas directa',
    invalidJson: 'Archivo JSON no vÃ¡lido',
    welcomeTitle: '# Bienvenido al Cuaderno Xcas',
    welcomeBody: 'Escribe matemÃ¡ticas visualmente (MathJSON) o usa sintaxis Xcas directa.\nMarca **Mostrar MathJSON** abajo para inspeccionar la conversiÃ³n.',
    plot3dNotSupported: 'Los grÃ¡ficos 3D aÃºn no son compatibles. Usa comandos de grÃ¡ficos 2D.',
    plotCoordinates: 'Coordenadas',
    reactiveToggle: 'Reactivo',
    pendingEvaluation: 'Pendienteâ€¦',
    dependencyError: 'Error de dependencia: la celda anterior fallÃ³',
    cyclicDependency: 'Dependencia circular detectada',
    duplicateVariable: 'DefiniciÃ³n de variable duplicada',
    brokenDependency: 'Dependencia rota: celda anterior eliminada',
    staleOutputWarning: 'Algunas salidas pueden estar desactualizadas. Â¿Reevaluar todo?',
    reEvalAll: 'Reevaluar todo',
    cancelCascade: 'Cancelar',
    reactiveReady: 'Modo reactivo activado. Haga clic en "Ejecutar todo" para construir el grafo de dependencias y evaluar.',
    runAllReactive: 'â–¶ Ejecutar todo (reactivo)',
  },
  de: {
    title: 'Xcas Notizbuch',
    subtitle: 'Reaktives CAS â€” MathJSON â†” Giac via WebAssembly',
    giacLoading: 'Giac wird geladenâ€¦',
    giacReady: 'Giac bereit',
    giacError: 'Giac Init-Fehler',
    giacDemo: 'Demo-Modus (Giac nicht geladen)',
    addMath: '+ Mathe', addRaw: '+ Xcas direkt', addText: '+ Text',
    runAll: 'â–¶ Alles ausfÃ¼hren', clearOutputs: 'âœ• Ausgaben lÃ¶schen',
    exportBtn: 'ğŸ’¾ Exportieren', importBtn: 'ğŸ“‚ Importieren',
    shortcutRun: 'AusfÃ¼hren', shortcutRunNew: 'AusfÃ¼hren + neue Zelle',
    showMathJSON: 'MathJSON anzeigen',
    cellMath: 'Mathe', cellRaw: 'Xcas', cellText: 'Text',
    placeholderRaw: 'Xcas-Syntax (z.B. factor(x^4-1))',
    placeholderText: 'Notizen, Markdownâ€¦',
    computing: 'Berechnungâ€¦',
    giacNotReady: 'â³ Giac wird noch geladenâ€¦',
    errorPrefix: 'âœ— Fehler:',
    moveUp: 'Nach oben', moveDown: 'Nach unten',
    deleteCell: 'LÃ¶schen', runCell: 'AusfÃ¼hren',
    modeVisual: 'Visuelle Mathe-Eingabe', modeRaw: 'Direkte Xcas-Syntax',
    invalidJson: 'UngÃ¼ltige JSON-Datei',
    welcomeTitle: '# Willkommen im Xcas Notizbuch',
    welcomeBody: 'Gib Mathematik visuell ein (MathJSON) oder nutze direkte Xcas-Syntax.\nAktiviere **MathJSON anzeigen** unten, um die Konvertierung zu prÃ¼fen.',
    plot3dNotSupported: '3D-Grafiken werden noch nicht unterstÃ¼tzt. Verwenden Sie 2D-Plotbefehle.',
    plotCoordinates: 'Koordinaten',
    reactiveToggle: 'Reaktiv',
    pendingEvaluation: 'Ausstehendâ€¦',
    dependencyError: 'AbhÃ¤ngigkeitsfehler: vorgelagerte Zelle fehlgeschlagen',
    cyclicDependency: 'ZirkulÃ¤re AbhÃ¤ngigkeit erkannt',
    duplicateVariable: 'Doppelte Variablendefinition',
    brokenDependency: 'AbhÃ¤ngigkeit unterbrochen: vorgelagerte Zelle gelÃ¶scht',
    staleOutputWarning: 'Einige Ausgaben kÃ¶nnten veraltet sein. Alle neu auswerten?',
    reEvalAll: 'Alle neu auswerten',
    cancelCascade: 'Abbrechen',
    reactiveReady: 'Reaktiver Modus aktiviert. Klicken Sie auf â€Alles ausfÃ¼hren", um den AbhÃ¤ngigkeitsgraphen aufzubauen und auszuwerten.',
    runAllReactive: 'â–¶ Alles ausfÃ¼hren (reaktiv)',
  },
};

let currentLocale = 'en';

/** Look up a translation key; falls back to English */
function t(key) {
  return LOCALES[currentLocale]?.[key] ?? LOCALES.en[key] ?? key;
}

/** Refresh all data-i18n elements + dynamic placeholders */
function applyI18n() {
  document.querySelectorAll('[data-i18n]').forEach(el => {
    el.textContent = t(el.getAttribute('data-i18n'));
  });
  document.querySelectorAll('.cell').forEach(cell => {
    const ta = cell.querySelector('textarea');
    if (ta && cell.dataset.type === 'raw')  ta.placeholder = t('placeholderRaw');
    if (ta && cell.dataset.type === 'text') ta.placeholder = t('placeholderText');
  });
  document.documentElement.lang = currentLocale;
}

/** Set locale, refresh UI, persist preference */
function setLocale(locale) {
  if (!LOCALES[locale]) return;
  currentLocale = locale;
  document.getElementById('lang-select').value = locale;
  applyI18n();
  try { localStorage.setItem('xcas-nb-locale', locale); } catch(e) {}
}

/** Auto-detect from stored preference or browser language */
function detectLocale() {
  try {
    const s = localStorage.getItem('xcas-nb-locale');
    if (s && LOCALES[s]) return s;
  } catch(e) {}
  const lang = (navigator.language || '').slice(0, 2);
  return LOCALES[lang] ? lang : 'en';
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 2 â€” COMPUTE ENGINE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const ce = new ComputeEngine.ComputeEngine();


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 3 â€” GIAC INITIALIZATION
//
// Giac exposes:  extern "C" const char* caseval(const char*);
// Two loading strategies:
//   A) giacsimple.js â†’ UI.ready / UI.caseval
//   B) giacwasm.js   â†’ Module.cwrap('caseval','string',['string'])
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let giacReady = false;
let caseval = null;

function initGiac() {
  const el  = document.getElementById('giac-status');
  const txt = el.querySelector('.text');

  if (typeof Module === 'undefined') {
    // No Module at all â€” demo mode
    txt.textContent = t('giacDemo');
    el.classList.add('error');
    caseval = (expr) => '[DEMO] ' + expr;
    giacReady = true;
    return;
  }

  // Poll until Module.ready (set by onRuntimeInitialized)
  const poll = setInterval(() => {
    if (Module.ready) {
      clearInterval(poll);
      try {
        caseval = Module.cwrap('caseval', 'string', ['string']);
        giacReady = true;
        txt.textContent = t('giacReady');
        el.classList.add('ready');
      } catch (e) {
        txt.textContent = t('giacError');
        el.classList.add('error');
        console.error('Giac init error:', e);
      }
    }
  }, 200);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 4 â€” MATHJSON â†’ XCAS CONVERTER
//
// MathJSON (CortexJS) uses PascalCase function names:
//   ["Add", 1, 2]  â†’  1+2
//   ["D", f, x]    â†’  diff(f, x)
//
// The converter walks the AST recursively and emits a
// Xcas-compatible string for caseval().
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SYMBOL_MAP = {
  Pi: 'pi', ExponentialE: 'e', ImaginaryUnit: 'i',
  Infinity: '+infinity', NegativeInfinity: '-infinity',
  True: 'true', False: 'false', Nothing: 'undef', Half: '1/2',
};

/**
 * Convert a MathJSON expression to a Xcas-compatible string.
 * @param {*} expr - MathJSON node (number | string | array | object)
 * @returns {string}
 */
function mathJsonToXcas(expr) {
  if (expr == null) return '';
  if (typeof expr === 'number') return String(expr);
  if (typeof expr === 'string') return SYMBOL_MAP[expr] ?? expr;

  // Object literal form: { num, sym, str, fn }
  if (typeof expr === 'object' && !Array.isArray(expr)) {
    if ('num' in expr) return expr.num;
    if ('sym' in expr) return mathJsonToXcas(expr.sym);
    if ('str' in expr) return '"' + expr.str + '"';
    if ('fn'  in expr) return mathJsonToXcas(expr.fn);
    return JSON.stringify(expr);
  }

  if (!Array.isArray(expr) || expr.length === 0) return '';

  const [head, ...args] = expr;
  const c   = (i) => mathJsonToXcas(args[i]);
  const all = ()  => args.map(mathJsonToXcas);
  const w   = (s) => '(' + s + ')';

  // Helper: unwrap CortexJS ["Function", ["Block", body], var] pattern
  function unwrapFn(node) {
    if (!Array.isArray(node) || node[0] !== 'Function') return null;
    let body = node[1];
    if (Array.isArray(body) && body[0] === 'Block') body = body[1];
    const v = node.length >= 3 ? mathJsonToXcas(node[2]) : 'x';
    return { body: mathJsonToXcas(body), v };
  }
  function isNothing(node) {
    return node == null || node === 'Nothing' ||
      (typeof node === 'object' && !Array.isArray(node) && node.sym === 'Nothing');
  }

  switch (head) {

    // â•â•â•â•â•â• Arithmetic â•â•â•â•â•â•
    case 'Add': case 'Sum':
      return w(all().join('+'));
    case 'Subtract':
      return args.length === 1 ? '(-' + w(c(0)) + ')' : w(c(0) + '-' + w(c(1)));
    case 'Negate':
      return '(-' + w(c(0)) + ')';
    case 'Multiply':
      return w(all().join('*'));
    case 'Divide':
      return '(' + w(c(0)) + '/' + w(c(1)) + ')';
    case 'Rational':
      return '(' + c(0) + '/' + c(1) + ')';
    case 'Power':
      return '(' + w(c(0)) + '^' + w(c(1)) + ')';
    case 'Sqrt':
      return 'sqrt(' + c(0) + ')';
    case 'Root':
      return args.length >= 2
        ? '(' + w(c(0)) + '^(1/' + w(c(1)) + '))'
        : 'sqrt(' + c(0) + ')';
    case 'Abs':       return 'abs(' + c(0) + ')';
    case 'Factorial': return '(' + c(0) + ')!';

    // â•â•â•â•â•â• Trigonometric â•â•â•â•â•â•
    case 'Sin': return 'sin(' + c(0) + ')';
    case 'Cos': return 'cos(' + c(0) + ')';
    case 'Tan': return 'tan(' + c(0) + ')';
    case 'Sec': return '(1/cos(' + c(0) + '))';
    case 'Csc': return '(1/sin(' + c(0) + '))';
    case 'Cot': return '(1/tan(' + c(0) + '))';
    case 'Arcsin': return 'asin(' + c(0) + ')';
    case 'Arccos': return 'acos(' + c(0) + ')';
    case 'Arctan': return 'atan(' + c(0) + ')';
    case 'Sinh': return 'sinh(' + c(0) + ')';
    case 'Cosh': return 'cosh(' + c(0) + ')';
    case 'Tanh': return 'tanh(' + c(0) + ')';

    // â•â•â•â•â•â• Log / Exp â•â•â•â•â•â•
    case 'Ln':  return 'ln(' + c(0) + ')';
    case 'Exp': return 'exp(' + c(0) + ')';
    case 'Log':
      return args.length >= 2 ? 'log(' + c(0) + ',' + c(1) + ')' : 'ln(' + c(0) + ')';
    case 'Log2':  return 'log(' + c(0) + ',2)';
    case 'Log10': return 'log(' + c(0) + ',10)';

    // â•â•â•â•â•â• Calculus â•â•â•â•â•â•
    case 'D': case 'Derivative': {
      const diffFn = unwrapFn(args[0]);
      if (diffFn) return 'diff(' + diffFn.body + ',' + diffFn.v + ')';
      return args.length >= 2 ? 'diff(' + c(0) + ',' + c(1) + ')' : 'diff(' + c(0) + ',x)';
    }

    case 'Integrate': {
      // CortexJS pattern: ["Integrate", ["Function", ["Block", body], var], ["Limits", var, lo, hi]]
      const intFn = unwrapFn(args[0]);
      if (intFn) {
        if (Array.isArray(args[1]) && args[1][0] === 'Limits') {
          const lo = args[1][2], hi = args[1][3];
          if (isNothing(lo) && isNothing(hi)) {
            return 'int(' + intFn.body + ',' + intFn.v + ')';
          }
          return 'int(' + intFn.body + ',' + intFn.v + ',' + mathJsonToXcas(lo) + ',' + mathJsonToXcas(hi) + ')';
        }
        return 'int(' + intFn.body + ',' + intFn.v + ')';
      }
      if (args.length === 1) return 'int(' + c(0) + ',x)';
      // Definite integral: ["Integrate", f, ["Triple", var, lo, hi]]
      if (Array.isArray(args[1]) &&
          ['Triple','Tuple'].includes(args[1][0]) &&
          args[1].length === 4) {
        const [, v, lo, hi] = args[1].map(mathJsonToXcas);
        return 'int(' + c(0) + ',' + v + ',' + lo + ',' + hi + ')';
      }
      if (args.length === 2) return 'int(' + c(0) + ',' + c(1) + ')';
      if (args.length === 4) return 'int(' + c(0) + ',' + c(1) + ',' + c(2) + ',' + c(3) + ')';
      return 'int(' + all().join(',') + ')';
    }

    case 'Limit': {
      // CortexJS pattern: ["Limit", ["Function", ["Block", body], var], point]
      const limFn = unwrapFn(args[0]);
      if (limFn) {
        if (args.length >= 2) return 'limit(' + limFn.body + ',' + limFn.v + ',' + c(1) + ')';
        return 'limit(' + limFn.body + ',' + limFn.v + ')';
      }
      if (args.length >= 3) return 'limit(' + c(0) + ',' + c(1) + '=' + c(2) + ')';
      if (args.length === 2) return 'limit(' + c(0) + ',' + c(1) + ')';
      return 'limit(' + c(0) + ')';
    }

    case 'Series': case 'Taylor':
      return 'series(' + all().join(',') + ')';

    // â•â•â•â•â•â• Algebra â•â•â•â•â•â•
    case 'Solve':    return 'solve(' + all().join(',') + ')';
    case 'Factor':   return 'factor(' + c(0) + ')';
    case 'Simplify': return 'simplify(' + c(0) + ')';
    case 'Expand':   return 'expand(' + c(0) + ')';

    // â•â•â•â•â•â• Linear algebra â•â•â•â•â•â•
    case 'Determinant': case 'Det': return 'det(' + c(0) + ')';
    case 'Inverse':      return 'inv(' + c(0) + ')';
    case 'Transpose':    return 'tran(' + c(0) + ')';
    case 'Eigenvalues':  return 'eigenvalues(' + c(0) + ')';
    case 'Eigenvectors': return 'eigenvects(' + c(0) + ')';

    // â•â•â•â•â•â• Relations â•â•â•â•â•â•
    case 'Equal':        return c(0) + '=' + c(1);
    case 'Less':         return c(0) + '<' + c(1);
    case 'LessEqual':    return c(0) + '<=' + c(1);
    case 'Greater':      return c(0) + '>' + c(1);
    case 'GreaterEqual': return c(0) + '>=' + c(1);
    case 'NotEqual':     return c(0) + '!=' + c(1);

    // â•â•â•â•â•â• Data structures â•â•â•â•â•â•
    case 'List':   return '[' + all().join(',') + ']';
    case 'Matrix': {
      const rows = args.map(r =>
        Array.isArray(r) && r[0] === 'List'
          ? '[' + r.slice(1).map(mathJsonToXcas).join(',') + ']'
          : mathJsonToXcas(r));
      return '[' + rows.join(',') + ']';
    }
    case 'Tuple': case 'Triple': case 'Pair': case 'Sequence':
      return all().join(',');
    case 'Set':       return '{' + all().join(',') + '}';
    case 'Range':     return c(0) + '..' + c(1);
    case 'Delimiter':
      return args.length === 1 && Array.isArray(args[0])
        ? w(mathJsonToXcas(args[0])) : w(all().join(','));

    // â•â•â•â•â•â• Special functions â•â•â•â•â•â•
    case 'Floor': return 'floor(' + c(0) + ')';
    case 'Ceil':  return 'ceil(' + c(0) + ')';
    case 'Round': return 'round(' + c(0) + ')';
    case 'Max':   return 'max(' + all().join(',') + ')';
    case 'Min':   return 'min(' + all().join(',') + ')';
    case 'Gcd':   return 'gcd(' + all().join(',') + ')';
    case 'Lcm':   return 'lcm(' + all().join(',') + ')';
    case 'Mod':   return 'irem(' + c(0) + ',' + c(1) + ')';
    case 'Binomial': case 'Choose':
      return 'comb(' + c(0) + ',' + c(1) + ')';

    // â•â•â•â•â•â• CortexJS wrappers â•â•â•â•â•â•
    case 'Block':    return args.length >= 1 ? c(0) : '';
    case 'Function': return args.length >= 1 ? c(0) : '';
    case 'Limits':   return args.length >= 1 ? c(0) : '';

    // â•â•â•â•â•â• Misc â•â•â•â•â•â•
    case 'Assign': return c(0) + ':=' + c(1);
    case 'Plot':   return 'plot(' + all().join(',') + ')';

    // â•â•â•â•â•â• Unknown â†’ attempt direct Xcas call â•â•â•â•â•â•
    default: {
      const fn = head.charAt(0).toLowerCase() + head.slice(1);
      return args.length === 0 ? fn : fn + '(' + all().join(',') + ')';
    }
  }
}

/**
 * Full pipeline: LaTeX (from math-field) â†’ MathJSON â†’ Xcas string.
 */
function latexToXcas(latex) {
  try {
    return mathJsonToXcas(ce.parse(latex, { canonical: false }).json);
  } catch (e) {
    console.warn('LaTeXâ†’MathJSON error:', e);
    return latex; // Giac can parse some LaTeX directly
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 5 â€” CELL MANAGEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let cellCounter = 0;
let cells = [];
let showDebug = false;
let reactiveMode = true;
let observableRuntime = null;
let observableModule = null;
let cellVariableMap = new Map();   // cellId â†’ { variable, defines, references }
let variableOwnerMap = new Map();  // variableName â†’ cellId

function addCell(type = 'math', initialLatex = '', initialRaw = '') {
  cellCounter++;
  const id = 'cell-' + cellCounter;
  const nb = document.getElementById('notebook');
  const div = document.createElement('div');
  div.className = 'cell'; div.id = id; div.dataset.type = type;
  div.dataset.cellId = id; div.dataset.defines = ''; div.dataset.references = '';

  const badge = { math:'cellMath', raw:'cellRaw', text:'cellText' }[type];
  const idx   = type === 'text' ? `Txt[${cellCounter}]` : `In[${cellCounter}]`;

  div.innerHTML = `
    <div class="cell-head">
      <span class="cell-idx">${idx}</span>
      <span class="cell-badge ${type}" data-i18n="${badge}">${t(badge)}</span>
      ${type === 'math' ? `<div class="mode-toggle">
        <button class="active" onclick="setCellMode('${id}','math')" title="${t('modeVisual')}">ğ‘“(ğ‘¥)</button>
        <button onclick="setCellMode('${id}','raw')" title="${t('modeRaw')}">{ }</button>
      </div>` : ''}
      <div class="cell-actions">
        <button onclick="runSingleCell('${id}')" title="${t('runCell')}">â–¶</button>
        <button onclick="moveCell('${id}',-1)" title="${t('moveUp')}">â†‘</button>
        <button onclick="moveCell('${id}',1)" title="${t('moveDown')}">â†“</button>
        <button class="del" onclick="deleteCell('${id}')" title="${t('deleteCell')}">âœ•</button>
      </div>
    </div>
    <div class="cell-input"></div>
    <div class="cell-debug ${showDebug?'visible':''}"></div>
    <div class="cell-output" id="${id}-output"></div>`;

  nb.appendChild(div);
  const inp = div.querySelector('.cell-input');

  if (type === 'math') {
    const mf = document.createElement('math-field');
    mf.value = initialLatex || '';
    mf.setAttribute('virtual-keyboard-mode', 'manual');
    mf.addEventListener('input', () => updateDebug(id));
    mf.addEventListener('keydown', (e) => cellKey(e, id, 'math'));
    inp.appendChild(mf);
    setTimeout(() => updateDebug(id), 100);
  } else {
    const ph = type === 'raw' ? t('placeholderRaw') : t('placeholderText');
    const ta = mkTextarea(ph, initialRaw);
    ta.rows = type === 'text' ? 3 : 2;
    ta.addEventListener('keydown', (e) => cellKey(e, id, type));
    inp.appendChild(ta);
  }

  // Dependency highlighting on focus/blur
  div.addEventListener('focusin', function() { if (reactiveMode) highlightDeps(id); });
  div.addEventListener('focusout', function() { clearDepHighlights(); });

  cells.push({ id, type, element: div });
  return id;
}

function mkTextarea(ph, val) {
  const ta = document.createElement('textarea');
  ta.placeholder = ph; ta.value = val || '';
  ta.addEventListener('input', () => { ta.style.height = 'auto'; ta.style.height = ta.scrollHeight + 'px'; });
  return ta;
}

function cellKey(e, id, type) {
  if (e.key === 'Enter' && e.ctrlKey && e.shiftKey) { e.preventDefault(); runSingleCell(id, true); return; }
  if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); runSingleCell(id); }
  if (e.key === 'Enter' && e.ctrlKey)  { e.preventDefault(); runSingleCell(id); addCell(type === 'text' ? 'text' : 'math'); }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 6 â€” DEBUG PANEL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function updateDebug(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  const dbg = cell.querySelector('.cell-debug');
  const mf  = cell.querySelector('math-field');
  if (!mf || !dbg) return;
  try {
    const json = ce.parse(mf.value, { canonical: false }).json;
    const xcas = mathJsonToXcas(json);
    dbg.innerHTML =
      '<span class="lbl">MathJSON:</span><code>' + esc(JSON.stringify(json)) + '</code>' +
      '<span class="xcas-out">â†’ Xcas: <code>' + esc(xcas) + '</code></span>';
  } catch (e) {
    dbg.innerHTML = '<span class="lbl">Error:</span> ' + esc(e.message);
  }
}

function toggleAllDebug(show) {
  showDebug = show;
  document.querySelectorAll('.cell-debug').forEach(d => d.classList.toggle('visible', show));
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 7 â€” MODE SWITCHING (math â†” raw)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function setCellMode(cellId, mode) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  const inp  = cell.querySelector('.cell-input');
  const btns = cell.querySelectorAll('.mode-toggle button');

  if (mode === 'raw') {
    const mf = cell.querySelector('math-field');
    const xcas = mf ? latexToXcas(mf.value) : '';
    inp.innerHTML = '';
    const ta = mkTextarea(t('placeholderRaw'), xcas);
    ta.addEventListener('keydown', (e) => cellKey(e, cellId, 'raw'));
    inp.appendChild(ta);
    cell.dataset.mode = 'raw';
    btns[0].classList.remove('active'); btns[1].classList.add('active');
  } else {
    const ta = cell.querySelector('textarea');
    inp.innerHTML = '';
    const mf = document.createElement('math-field');
    mf.value = ta ? ta.value : '';
    mf.setAttribute('virtual-keyboard-mode', 'manual');
    mf.addEventListener('input', () => updateDebug(cellId));
    mf.addEventListener('keydown', (e) => cellKey(e, cellId, 'math'));
    inp.appendChild(mf);
    cell.dataset.mode = 'math';
    btns[0].classList.add('active'); btns[1].classList.remove('active');
    setTimeout(() => updateDebug(cellId), 100);
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 8 â€” EXECUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getXcasExpr(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell || cell.dataset.type === 'text') return '';
  const mode = cell.dataset.mode || cell.dataset.type;
  if (cell.dataset.type === 'raw' || mode === 'raw') {
    return cell.querySelector('textarea')?.value.trim() || '';
  }
  const mf = cell.querySelector('math-field');
  return mf ? latexToXcas(mf.value) : '';
}

function runSingleCell(cellId, forceManual) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  if (cell.dataset.type === 'text') { renderTextCell(cellId); return; }

  const expr = getXcasExpr(cellId);
  const out  = document.getElementById(cellId + '-output');
  if (!expr) { out.innerHTML = ''; return; }
  if (!giacReady) { out.innerHTML = '<span class="err">' + t('giacNotReady') + '</span>'; return; }

  // Reactive mode: register/update in Observable graph (unless forced manual)
  if (reactiveMode && observableModule && !forceManual) {
    // The observer's pending() callback shows the spinner.
    // updateCell â†’ registerCell â†’ variable.define() triggers
    // Observable to (re-)evaluate this cell and all downstream dependents.
    try {
      updateCell(cellId, expr);
    } catch(err) {
      out.innerHTML = '<span class="err">' + t('errorPrefix') + ' ' + esc(String(err)) + '</span>';
      cell.classList.add('cell-error');
    }
    return;
  }

  cell.classList.add('running');
  out.innerHTML = '<span class="spinner"></span> ' + t('computing');

  setTimeout(() => {
    try {
      // Clean up any previous JSXGraph boards in this output
      cleanupJSXGraphInElement(out);
      out.innerHTML = '';

      // Try direct JSXGraph rendering from the input expression (no SVG parsing)
      if (jsxGraphAvailable() && tryDirectJSXGraph(expr, out)) {
        // Successfully rendered directly â€” done
      } else {
        // For potential 3D commands, pre-create canvas so Emscripten's SDL
        // initializes WebGL on the right canvas (not the hidden default)
        var preGl3dCanvas = null, preGl3dContainer = null, savedModuleCanvas = null;
        if (/\b(plotfunc|plotparam3d|plot3d)\s*\(/.test(expr)) {
          if (webglAvailable() && getGiacRenderer()) {
            preGl3dContainer = document.createElement('div');
            preGl3dContainer.className = 'gl3d-container';
            preGl3dCanvas = document.createElement('canvas');
            preGl3dCanvas.id = 'gl3d_pre_' + Date.now();
            var pcw = Math.min(out.clientWidth || 600, 600);
            preGl3dCanvas.width = pcw;
            preGl3dCanvas.height = Math.round(pcw * 2 / 3);
            preGl3dContainer.appendChild(preGl3dCanvas);
            out.appendChild(preGl3dContainer);
            savedModuleCanvas = Module.canvas;
            Module.canvas = preGl3dCanvas;
          }
        }

        // Fall back to caseval + format-based pipeline
        const raw = caseval(expr);
        const plotFmt = detectPlotFormat(raw);

        // Clean up pre-created gl3d canvas immediately if output is not gl3d
        if (plotFmt !== 'gl3d' && preGl3dCanvas && preGl3dContainer) {
          preGl3dContainer.remove();
          if (savedModuleCanvas) Module.canvas = savedModuleCanvas;
          preGl3dCanvas = null;
        }

        if (plotFmt === 'svg') {
          renderSvgPlot(out, stripQuotes(raw));
        } else if (plotFmt === 'gr2d') {
          var jsxDone = false;
          if (jsxGraphAvailable()) {
            try {
              var plotData = parseGr2dLogoData(raw);
              if (plotData && plotData.curves.length > 0) {
                renderJSXGraphPlot(out, plotData);
                jsxDone = true;
              }
            } catch(e) { console.warn('JSXGraph gr2d parse failed, falling back:', e); }
          }
          if (!jsxDone) renderGr2dPlot(out, raw);
        } else if (plotFmt === 'gl3d') {
          var sceneId = raw.substr(5).trim();
          if (preGl3dCanvas) {
            // Use pre-created canvas (Module.canvas already set)
            preGl3dCanvas.id = 'gl3d_' + sceneId;
            var gr = getGiacRenderer();
            try { gr(sceneId); } catch(e) {
              preGl3dContainer.innerHTML = '<div class="plot-3d-msg">' + t('plot3dNotSupported') + '</div>';
            }
            // Mouse interaction
            var pushed = false, lastX = 0, lastY = 0;
            preGl3dCanvas.addEventListener('mousedown', function(e) { pushed = true; lastX = e.clientX; lastY = e.clientY; e.preventDefault(); });
            preGl3dCanvas.addEventListener('mouseup', function() { pushed = false; });
            preGl3dCanvas.addEventListener('mouseleave', function() { pushed = false; });
            preGl3dCanvas.addEventListener('mousemove', function(e) {
              if (!pushed) return;
              var dx = e.clientX - lastX, dy = e.clientY - lastY;
              if (Math.abs(dx) > 2) gr((dx > 0 ? 'r' : 'l') + sceneId);
              if (Math.abs(dy) > 2) gr((dy > 0 ? 'd' : 'u') + sceneId);
              lastX = e.clientX; lastY = e.clientY; e.preventDefault();
            });
            // Cleanup SDL listeners
            try {
              var kle = Module['keyboardListeningElement'] || document;
              if (typeof SDL !== 'undefined' && SDL.receiveEvent) {
                kle.removeEventListener('keydown', SDL.receiveEvent);
                kle.removeEventListener('keyup', SDL.receiveEvent);
                kle.removeEventListener('keypress', SDL.receiveEvent);
              }
            } catch(e) {}
            preGl3dCanvas = null; // Mark as used
          } else {
            renderGl3dPlot(out, sceneId);
          }
        } else {
          // Text/LaTeX path
          let latex = '';
          try { latex = caseval('latex(' + expr + ')').replace(/^"|"$/g, ''); } catch(e) {}
          if (latex && typeof katex !== 'undefined') {
            const d = document.createElement('div');
            try {
              katex.render(latex, d, { displayMode: true, throwOnError: false, trust: true });
              out.appendChild(d);
            } catch(e) { out.innerHTML = '<div class="raw-res">' + esc(raw) + '</div>'; }
          } else {
            out.innerHTML = '<div class="raw-res">' + esc(raw) + '</div>';
          }
        }
        // Show raw result beneath â€” but not for plot outputs (too verbose)
        if (plotFmt === 'text') {
          const r = document.createElement('div');
          r.className = 'raw-res'; r.textContent = 'â†’ ' + raw;
          out.appendChild(r);
        }
        // Clean up pre-created gl3d canvas if it wasn't used
        if (preGl3dCanvas && preGl3dContainer) {
          preGl3dContainer.remove();
          if (savedModuleCanvas) Module.canvas = savedModuleCanvas;
        }
      }
    } catch (err) {
      out.innerHTML = '<span class="err">' + t('errorPrefix') + ' ' + esc(String(err)) + '</span>';
    }
    cell.classList.remove('running');
  }, 10);
}

function renderTextCell(cellId) {
  const cell = document.getElementById(cellId);
  if (!cell) return;
  const ta = cell.querySelector('textarea');
  const out = document.getElementById(cellId + '-output');
  if (!ta || !ta.value.trim()) { out.innerHTML = ''; return; }
  let h = esc(ta.value)
    .replace(/^### (.+)$/gm, '<h3>$1</h3>')
    .replace(/^## (.+)$/gm,  '<h2>$1</h2>')
    .replace(/^# (.+)$/gm,   '<h1>$1</h1>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g,     '<em>$1</em>')
    .replace(/`(.+?)`/g,       '<code>$1</code>')
    .replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>');
  out.innerHTML = '<div class="md-out"><p>' + h + '</p></div>';
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 9 â€” GLOBAL ACTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function runAll() {
  if (reactiveMode) {
    runAllReactive();
  } else {
    cells.forEach(function(c) { runSingleCell(c.id); });
  }
}
function clearAllOutputs() { cells.forEach(c => { const o = document.getElementById(c.id+'-output'); if(o) o.innerHTML=''; }); }
function deleteCell(id) {
  // Unregister from reactive graph before removing
  if (reactiveMode && observableModule) {
    var downstreamIds = getDownstreamCells(id);
    unregisterCell(id);
    // Mark downstream cells as having broken dependency
    downstreamIds.forEach(function(did) {
      var dout = document.getElementById(did + '-output');
      if (dout) {
        var warn = document.createElement('div');
        warn.className = 'dep-warning broken';
        warn.textContent = t('brokenDependency') + ' (' + id + ')';
        dout.prepend(warn);
      }
      var del = document.getElementById(did);
      if (del) del.classList.add('cell-stale');
    });
  }
  document.getElementById(id)?.remove();
  cells = cells.filter(c => c.id !== id);
}
function moveCell(id, dir) {
  const i = cells.findIndex(c => c.id === id);
  if (i < 0) return;
  const j = i + dir;
  if (j < 0 || j >= cells.length) return;
  [cells[i], cells[j]] = [cells[j], cells[i]];
  const nb = document.getElementById('notebook');
  nb.innerHTML = '';
  cells.forEach(c => nb.appendChild(c.element));
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 10 â€” EXPORT / IMPORT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function exportNotebook() {
  const data = {
    version: 2,
    locale: currentLocale,
    reactiveMode: reactiveMode,
    cells: cells.map(c => {
      const el = c.element;
      const mode = el.dataset.mode || el.dataset.type;
      const mf = el.querySelector('math-field');
      const ta = el.querySelector('textarea');
      const cellInfo = cellVariableMap.get(c.id);
      return {
        type: el.dataset.type,
        mode,
        content: (mode === 'math' && mf) ? mf.value : (ta ? ta.value : ''),
        defines: cellInfo ? cellInfo.defines : [],
        references: cellInfo ? cellInfo.references : []
      };
    })
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'xcas-notebook.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

function importNotebook() {
  const inp = document.createElement('input');
  inp.type = 'file'; inp.accept = '.json';
  inp.onchange = (e) => {
    const f = e.target.files[0]; if (!f) return;
    const r = new FileReader();
    r.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.locale && LOCALES[data.locale]) setLocale(data.locale);
        // Clear reactive graph
        cellVariableMap.forEach(function(info, cid) { unregisterCell(cid); });
        cellVariableMap.clear();
        variableOwnerMap.clear();
        document.getElementById('notebook').innerHTML = '';
        cells = []; cellCounter = 0;
        if (data.reactiveMode !== undefined) toggleReactiveMode(data.reactiveMode);
        var cellItems = Array.isArray(data) ? data : data.cells;
        cellItems.forEach(item => {
          var cid = item.type === 'math' ? addCell('math', item.content) : addCell(item.type, '', item.content);
          // v1 migration: extract deps if not present
          if (reactiveMode && observableModule && item.type !== 'text') {
            var expr = item.type === 'math' ? '' : (item.content || '');
            if (expr) registerCell(cid, expr);
          }
        });
      } catch(err) { alert(t('invalidJson')); }
    };
    r.readAsText(f);
  };
  inp.click();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 11 â€” UTILITIES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 12 â€” BOOT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

document.addEventListener('DOMContentLoaded', () => {
  setLocale(detectLocale());
  initGiac();

  // Demo cells
  addCell('text', '', t('welcomeTitle') + '\n\n' + t('welcomeBody'));

  // Reactive DAG demo cells
  addCell('raw', '', 'a := 5');
  addCell('raw', '', 'a^2');
  addCell('raw', '', 'b := a + 3');

  addCell('math', '\\frac{x^4-1}{x^2+1}');
  addCell('math', '\\int \\frac{1}{x^2+1}\\, dx');
  addCell('math', '\\frac{d}{dx}\\left(\\sin(x)\\cdot e^x\\right)');
  addCell('math', '\\lim_{x \\to 0} \\frac{\\sin(x)}{x}');
  addCell('raw',  '', 'solve(x^2 - 3*x + 2 = 0, x)');
  addCell('raw',  '', 'eigenvalues([[1,2],[3,4]])');
  addCell('raw',  '', 'plot(sin(x))');
  addCell('raw',  '', 'plotfunc([sin(x),cos(x)],x)');
  addCell('raw',  '', 'plot([sin(x),sin(x-pi/3),sin(x-2*pi/3)],x)');

  // Demo cells for all plot categories (pre-filled, not auto-executed)
  addCell('raw',  '', 'plotfunc(x^2+y^2,[x,y])');
  addCell('raw',  '', 'plotimplicit(x^2+y^2-1,x,y)');
  addCell('raw',  '', 'plotfield(sin(x*y),[x,y])');
  addCell('raw',  '', 'plotcontour(x^2+y^2,[x=-3..3,y=-3..3])');
  addCell('raw',  '', 'plotode(sin(t*y),[t,y],[0,1])');
  addCell('raw',  '', 'plotseq(cos(x),0.5,5)');
  addCell('raw',  '', 'histogram(seq(rand(100),k,1,200))');
  addCell('raw',  '', 'barplot([3,5,2,8,1])');
  addCell('raw',  '', 'camembert([["A",30],["B",50],["C",20]])');
  addCell('raw',  '', 'boxwhisker([1,2,3,4,5,6,7,8,9,10])');
  addCell('raw',  '', 'scatterplot([1,2,3,4,5],[2,4,5,4,5])');
  addCell('raw',  '', 'circle(0,2); segment([0,0],[2,0]); point(1,1)');
  addCell('raw',  '', 'plotfunc(sin(x)*cos(y),[x=-pi..pi,y=-pi..pi])');

  // Show reactive consent banner on boot (reactive mode is default)
  var notebook = document.getElementById('notebook');
  var banner = document.createElement('div');
  banner.id = 'reactive-banner';
  banner.className = 'stale-banner';
  banner.innerHTML = '<span>' + t('reactiveReady') + '</span>' +
    '<button onclick="runAllReactive()">' + t('runAllReactive') + '</button>' +
    '<button onclick="toggleReactiveMode(false)">' + t('cancelCascade') + '</button>';
  notebook.parentNode.insertBefore(banner, notebook);
});


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 13 â€” PLOT RENDERING
//
// Detects graphical output from Giac (SVG, gr2d, gl3d) and
// renders plots inline in cell output areas.
// Ported from giacsimple.js with adaptations for the notebook.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const PLOT_COLORS = [
  'black','red','green','yellow','blue','magenta','cyan','white',
  'silver','gray','maroon','purple','fuchsia','lime','olive','navy',
  'teal','aqua','antiquewhite','aquamarine','azure','beige','bisque',
  'blanchedalmond','blueviolet','brown','burlywood','cadetblue',
  'chartreuse','chocolate','coral','cornflowerblue','cornsilk','crimson',
  'cyan','darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen',
  'darkgrey','darkkhaki','darkmagenta','darkolivegreen','darkorange',
  'darkorchid','darkred','darksalmon','darkseagreen','darkslateblue',
  'darkslategray','darkslategrey','darkturquoise','darkviolet','deeppink',
  'deepskyblue','dimgray','dimgrey','dodgerblue','firebrick','floralwhite',
  'forestgreen','gainsboro','ghostwhite','gold','goldenrod','greenyellow',
  'grey','honeydew','hotpink','indianred','indigo','ivory','khaki',
  'lavender','lavenderblush','lawngreen','lemonchiffon','lightblue',
  'lightcoral','lightcyan','lightgoldenrodyellow','lightgray','lightgreen',
  'lightgrey','lightpink','lightsalmon','lightseagreen','lightskyblue',
  'lightslategray','lightslategrey','lightsteelblue','lightyellow',
  'limegreen','linen','mediumaquamarine','mediumblue','mediumorchid',
  'mediumpurple','mediumseagreen','mediumslateblue','mediumspringgreen',
  'mediumturquoise','mediumvioletred','midnightblue','mintcream',
  'mistyrose','moccasin','navajowhite','oldlace','olivedrab','orangered',
  'orchid','palegoldenrod','palegreen','paleturquoise','palevioletred',
  'papayawhip','peachpuff','peru','pink','plum','powderblue','rosybrown',
  'royalblue','saddlebrown','salmon','sandybrown','seagreen','seashell',
  'sienna','skyblue','slateblue','slategray','slategrey','snow',
  'springgreen','steelblue','tan','thistle','tomato','turquoise','violet',
  'wheat','whitesmoke','yellowgreen'
];

function plotRainbowColor(k) {
  var r, g, b;
  k += 21;
  k %= 126;
  if (k < 0) k += 126;
  if (k < 21) { r = 251; g = 0; b = 12 * k; }
  if (k >= 21 && k < 42) { r = 251 - 12 * (k - 21); g = 0; b = 251; }
  if (k >= 42 && k < 63) { r = 0; g = (k - 42) * 12; b = 251; }
  if (k >= 63 && k < 84) { r = 0; g = 251; b = 251 - (k - 63) * 12; }
  if (k >= 84 && k < 105) { r = (k - 84) * 12; g = 251; b = 0; }
  if (k >= 105 && k < 126) { r = 251; g = 251 - (k - 105) * 12; b = 0; }
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}

function plotResolveColor(c) {
  if (c >= 0x100) {
    if (c < 0x17e) return plotRainbowColor(c);
    var r = 8 * ((c >> 11) & 0x1f);
    var g = 4 * ((c >> 5) & 0x3f);
    var b = 8 * (c & 0x1f);
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  }
  return PLOT_COLORS[c] || 'black';
}

function detectPlotFormat(raw) {
  if (!raw || raw.length < 5) return 'text';
  if (raw.substr(0, 4) === '<svg' || (raw.charAt(0) === '"' && raw.substr(1, 4) === '<svg')) return 'svg';
  if (raw.substr(0, 5) === 'gr2d(') return 'gr2d';
  if (raw.substr(0, 5) === 'gl3d ') return 'gl3d';
  return 'text';
}

/** Strip surrounding quotes from Giac output if present */
function stripQuotes(s) {
  if (s.length >= 2 && s.charAt(0) === '"' && s.charAt(s.length - 1) === '"')
    return s.substring(1, s.length - 1);
  return s;
}

// T008: SVG plot renderer
function renderSvgPlot(outputEl, svgString) {
  var container = document.createElement('div');
  container.className = 'plot-container plot-svg';
  container.innerHTML = svgString;
  outputEl.appendChild(container);
}

// T009: Pixon (pixel) renderer â€” ported from giacsimple.js
function plotPixonDraw(canvas, dataString) {
  var v;
  try { v = JSON.parse(dataString); } catch(e) {
    try { v = (0, eval)(dataString); } catch(e2) { return; }
  }
  if (!Array.isArray(v) || v.length < 2) return;
  var l = v.length, w = 0, h = 0;
  var scale = v[0];
  for (var k = 1; k < l; k++) {
    var cur = v[k];
    var x = cur[0], y = cur[1];
    if (cur.length === 3 && typeof cur[2] !== 'number') { x += 100; y += 16; }
    if (cur.length === 4) {
      var tmp = cur[3];
      if (typeof tmp === 'number') { if (tmp > 0) y += tmp; else x -= tmp; }
      else { x += 100; y += 16; }
    }
    if (x > w) w = x;
    if (y > h) h = y;
  }
  w = (w + 1) * scale;
  h = (h + 1) * scale;
  canvas.width = w; canvas.height = h;
  var ctx = canvas.getContext('2d');
  if (!ctx) return;
  for (var k = 1; k < l; k++) {
    var cur = v[k], cl;
    if (!Array.isArray(cur) || (cl = cur.length) < 2) continue;
    var x = cur[0] * scale, y = cur[1] * scale;
    if (cl > 2 && typeof cur[2] === 'string') {
      ctx.font = '16px serif'; ctx.fillStyle = 'black';
      ctx.fillText(cur[2], x, y + 16, 100); continue;
    }
    ctx.fillStyle = (cl > 2) ? plotResolveColor(cur[2]) : 'black';
    if (cl < 4) { ctx.fillRect(x, y, scale, scale); continue; }
    if (typeof cur[3] === 'string') {
      ctx.font = '16px serif'; ctx.fillText(cur[3], x, y + 16, 100); continue;
    }
    var ph = cur[3] * scale, pw = scale;
    if (ph < 0) { pw = -ph; ph = scale; }
    ctx.fillRect(x, y, pw, ph);
  }
}

// T010: Logo (turtle) renderer â€” ported from giacsimple.js
function plotLogoDraw(canvas, dataString, zoom, dx, dy) {
  var v;
  try { v = JSON.parse(dataString); } catch(e) {
    try { v = (0, eval)(dataString); } catch(e2) { return; }
  }
  if (!Array.isArray(v) || v.length < 2) return;
  var w = canvas.width, h = canvas.height;
  var ctx = canvas.getContext('2d');
  if (!ctx) return;
  var turtlezoom = zoom || 1, turtlex = dx || 0, turtley = dy || 0;

  // Background
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, w, h);

  // Dot grid
  ctx.fillStyle = '#ddd';
  var xdecal = Math.floor(turtlex / 10.0) * 10;
  var ydecal = Math.floor(turtley / 10.0) * 10;
  for (var i = xdecal; i < w / turtlezoom + xdecal; i += 10) {
    for (var j = ydecal; j < h / turtlezoom + ydecal; j += 10) {
      var X = Math.floor((i - turtlex) * turtlezoom + .5);
      var Y = Math.floor((j - turtley) * turtlezoom + .5);
      ctx.fillRect(X, h - Y, 1, 1);
    }
  }

  var l = v.length;
  // v[i]=[x,y,cap,status,r,chaine]
  // color=status>>11, pen_down=status&1, visible=status&2
  for (var k = 1; k < l; k++) {
    var prec = v[k - 1], cur = v[k];
    var preccouleur = prec[3] >> 11;
    var curcouleur = cur[3] >> 11;
    if (cur[5] && cur[5].length) {
      ctx.font = cur[4] + 'px serif';
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(curcouleur);
      ctx.fillText(cur[5], turtlezoom * (cur[0] - turtlex), h - turtlezoom * (cur[1] - turtley));
      continue;
    }
    var radius = cur[4], precradius = prec[4];
    var x1 = Math.floor(turtlezoom * (prec[0] - turtlex) + .5),
        y1 = Math.floor(turtlezoom * (prec[1] - turtley) + .5),
        x2 = Math.floor(turtlezoom * (cur[0] - turtlex) + .5),
        y2 = Math.floor(turtlezoom * (cur[1] - turtley) + .5);
    if (radius > 0) {
      var r = radius & 0x1ff;
      var theta1 = prec[2] + ((radius >> 9) & 0x1ff);
      var theta2 = prec[2] + ((radius >> 18) & 0x1ff);
      var rempli = (radius >> 27) & 1;
      var seg = (radius >> 28) & 1;
      var R = Math.floor(turtlezoom * r + .5);
      var angle1 = Math.PI / 180 * (theta1 - 90);
      var angle2 = Math.PI / 180 * (theta2 - 90);
      var cx = Math.floor(turtlezoom * (cur[0] - turtlex - r * Math.cos(angle2)) + .5);
      var cy = Math.floor(turtlezoom * (cur[1] - turtley - r * Math.sin(angle2)) + .5);
      ctx.beginPath();
      if (seg) ctx.moveTo(x2, h - y2);
      else { ctx.moveTo(cx, h - cy); ctx.lineTo(x2, h - y2); }
      ctx.arc(cx, h - cy, R, -angle2, -angle1);
      ctx.closePath();
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(curcouleur);
      if (rempli) ctx.fill(); else ctx.stroke();
      continue;
    }
    if (prec[3] & 1) {
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(preccouleur);
      ctx.beginPath();
      ctx.moveTo(x1, h - y1); ctx.lineTo(x2, h - y2);
      ctx.closePath(); ctx.stroke();
    }
    if (radius < -1 && k + radius >= 0) {
      ctx.strokeStyle = ctx.fillStyle = plotResolveColor(curcouleur);
      ctx.beginPath();
      ctx.moveTo(x2, h - y2);
      for (var i = -1; i >= radius; i--) {
        var pv = v[k + i];
        ctx.lineTo(
          Math.floor(turtlezoom * (pv[0] - turtlex) + .5),
          h - Math.floor(turtlezoom * (pv[1] - turtley) + .5)
        );
      }
      ctx.closePath(); ctx.fill();
    }
  }
  // Draw turtle icon if visible
  var last = v[l - 1];
  if (last[3] & 2) {
    var tx = Math.floor(turtlezoom * (last[0] - turtlex) + .5);
    var ty = Math.floor(turtlezoom * (last[1] - turtley) + .5);
    var cost = Math.cos(last[2] * Math.PI / 180);
    var sint = Math.sin(last[2] * Math.PI / 180);
    var tlen = (last[3] >> 3) & 0xff;
    var Dx = Math.floor(turtlezoom * tlen * cost / 2 + .5);
    var Dy = Math.floor(turtlezoom * tlen * sint / 2 + .5);
    ctx.strokeStyle = plotResolveColor(last[3] >> 11);
    ctx.beginPath(); ctx.moveTo(tx + Dy, h - (ty - Dx)); ctx.lineTo(tx - Dy, h - (ty + Dx)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx + Dy, h - (ty - Dx)); ctx.lineTo(tx + 3 * Dx, h - (ty + 3 * Dy)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx - Dy, h - (ty + Dx)); ctx.lineTo(tx + 3 * Dx, h - (ty + 3 * Dy)); ctx.stroke();
  }
}

// T011: gr2d dispatcher â€” creates canvas and routes to logo or pixon
var plotCanvasCounter = 0;
var plotCanvasStates = {};

function renderGr2dPlot(outputEl, gr2dString) {
  var inner = gr2dString.substr(5, gr2dString.length - 6); // strip "gr2d(" and ")"
  var container = document.createElement('div');
  container.className = 'plot-container';
  var canvasId = 'plot-canvas-' + (++plotCanvasCounter);
  var canvas = document.createElement('canvas');
  canvas.id = canvasId;
  canvas.width = 600; canvas.height = 400;
  container.appendChild(canvas);
  outputEl.appendChild(container);

  if (inner.length > 6 && inner.substr(0, 6) === 'pixon(') {
    plotPixonDraw(canvas, inner.substr(6, inner.length - 7));
  } else if (inner.length > 5 && inner.substr(0, 5) === 'logo(') {
    var logoData = inner.substr(5, inner.length - 6);
    plotLogoDraw(canvas, logoData, 1, 0, 0);
    plotCanvasStates[canvasId] = { rawData: logoData, zoom: 1, dx: 0, dy: 0 };
    attachPlotInteractivity(canvas, canvasId);
  }
}

// T016-T019: Interactive plot features (zoom, pan, coordinate hover)
function attachPlotInteractivity(canvas, canvasId) {
  var state = plotCanvasStates[canvasId];
  if (!state) return;
  var container = canvas.parentElement;

  // Tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'plot-tooltip';
  container.appendChild(tooltip);

  // T017: Zoom via mouse wheel
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    var s = plotCanvasStates[canvasId];
    if (!s) return;
    var factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
    // Zoom toward mouse position
    var rect = canvas.getBoundingClientRect();
    var mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    var my = (e.clientY - rect.top) * (canvas.height / rect.height);
    var mathX = mx / s.zoom + s.dx;
    var mathY = (canvas.height - my) / s.zoom + s.dy;
    s.zoom *= factor;
    s.dx = mathX - mx / s.zoom;
    s.dy = mathY - (canvas.height - my) / s.zoom;
    plotLogoDraw(canvas, s.rawData, s.zoom, s.dx, s.dy);
  }, { passive: false });

  // T018: Pan via mouse drag
  var dragging = false, lastX = 0, lastY = 0;
  canvas.addEventListener('mousedown', function(e) {
    dragging = true; lastX = e.clientX; lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  canvas.addEventListener('mousemove', function(e) {
    var s = plotCanvasStates[canvasId];
    if (!s) return;
    if (dragging) {
      var rect = canvas.getBoundingClientRect();
      var scaleX = canvas.width / rect.width;
      var scaleY = canvas.height / rect.height;
      s.dx -= (e.clientX - lastX) * scaleX / s.zoom;
      s.dy += (e.clientY - lastY) * scaleY / s.zoom;
      lastX = e.clientX; lastY = e.clientY;
      plotLogoDraw(canvas, s.rawData, s.zoom, s.dx, s.dy);
    }
    // T019: Coordinate hover
    var rect = canvas.getBoundingClientRect();
    var px = (e.clientX - rect.left) * (canvas.width / rect.width);
    var py = (e.clientY - rect.top) * (canvas.height / rect.height);
    var mx = px / s.zoom + s.dx;
    var my = (canvas.height - py) / s.zoom + s.dy;
    tooltip.textContent = '(' + mx.toFixed(2) + ', ' + my.toFixed(2) + ')';
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 12) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 8) + 'px';
  });
  canvas.addEventListener('mouseup', function() { dragging = false; canvas.style.cursor = 'crosshair'; });
  canvas.addEventListener('mouseleave', function() { dragging = false; canvas.style.cursor = 'crosshair'; tooltip.style.display = 'none'; });
  canvas.style.cursor = 'crosshair';
}

// â”€â”€ Direct JSXGraph rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Detects plot commands from the INPUT expression and renders
// directly with JSXGraph â€” no SVG parsing needed.

/** Parse a Giac list string "[3,5,2,8,1]" into an array of numbers */
function parseGiacList(str) {
  if (!str) return null;
  str = str.replace(/^\[|\]$/g, '').trim();
  if (!str) return null;
  var nums = str.split(',').map(function(s) { return parseFloat(s.trim()); });
  return nums.filter(function(n) { return !isNaN(n); });
}

/** Parse a Giac list of pairs "[[a,b],[c,d]]" or "[[\"A\",30],[\"B\",50]]" */
function parseGiacPairList(str) {
  if (!str) return null;
  var pairs = [];
  var re = /\[(?:"([^"]*)"|([\w.]+))\s*,\s*([\d.eE+-]+)\]/g;
  var m;
  while ((m = re.exec(str)) !== null) {
    pairs.push({ label: m[1] || m[2], value: parseFloat(m[3]) });
  }
  return pairs.length > 0 ? pairs : null;
}

/** Generate sample points for a function using a single caseval call */
function sampleFuncPoints(funcExpr, varName, xmin, xmax, nPoints) {
  nPoints = nPoints || 500;
  var step = (xmax - xmin) / nPoints;
  var seqExpr = 'seq(evalf(subst(' + funcExpr + ',' + varName + ',' + xmin + '+k*' + step + ')),k,0,' + nPoints + ')';
  var raw = caseval(seqExpr);
  var ys = parseGiacList(raw);
  if (!ys) return null;
  var xs = [];
  for (var i = 0; i < ys.length; i++) xs.push(xmin + i * step);
  return { xs: xs, ys: ys };
}

/** Extract x range from expressions like "x=-3..3" */
function parseRange(rangeExpr) {
  var m = rangeExpr.match(/(\w+)\s*=\s*([-\w.*\/]+)\.\.([-\w.*\/]+)/);
  if (!m) return null;
  var lo = parseFloat(caseval('evalf(' + m[2] + ')'));
  var hi = parseFloat(caseval('evalf(' + m[3] + ')'));
  if (isNaN(lo) || isNaN(hi)) return null;
  return { varName: m[1], min: lo, max: hi };
}

/** Convert a Giac math expression to a JavaScript function */
function giacExprToJSFunc(expr, vars) {
  try {
    var js = expr;
    // Replace math functions with Math.* equivalents (must come before constant/operator replacements)
    js = js.replace(/\b(sin|cos|tan|asin|acos|atan|exp|sqrt|abs|sinh|cosh|tanh)\s*\(/g, 'Math.$1(');
    js = js.replace(/\bln\s*\(/g, 'Math.log(');
    js = js.replace(/\blog\s*\(/g, 'Math.log(');
    // Replace constants (whole word)
    js = js.replace(/\bpi\b/g, '(Math.PI)');
    // Replace ^ with **
    js = js.replace(/\^/g, '**');
    // Implicit multiplication: digit followed by variable name
    vars.forEach(function(v) {
      var vre = v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      js = js.replace(new RegExp('(\\d)(' + vre + ')\\b', 'g'), '$1*$2');
    });
    var fn = new Function(vars.join(','), 'return ' + js + ';');
    // Test evaluation to verify it works
    var testArgs = vars.map(function() { return 0.7; });
    var r = fn.apply(null, testArgs);
    if (typeof r !== 'number') return null;
    return fn;
  } catch(e) { return null; }
}

/** Create a JSXGraph board in outputEl with given bounding box */
function createJSXBoard(outputEl, bbox, opts) {
  var boardId = 'jsxgraph-' + (++jsxGraphBoardCounter);
  var wrapper = document.createElement('div');
  wrapper.className = 'jxgbox-container';
  var box = document.createElement('div');
  box.id = boardId;
  box.className = 'jxgbox';
  wrapper.appendChild(box);
  outputEl.appendChild(wrapper);
  var config = {
    boundingbox: [bbox.xmin, bbox.ymax, bbox.xmax, bbox.ymin],
    axis: true, showCopyright: false, showNavigation: true,
    pan: { enabled: true }, zoom: { enabled: true, wheel: true, pinch: true }
  };
  if (opts) for (var k in opts) config[k] = opts[k];
  var board = JXG.JSXGraph.initBoard(boardId, config);
  jsxGraphBoards[boardId] = board;
  return board;
}

/** Parse "[x,y]" or "[x=-3..3,y=-3..3]" into {vars, ranges} */
function parseVarList(str) {
  str = str.trim();
  if (str.charAt(0) === '[') str = str.slice(1, -1);
  var parts = splitTopLevel(str);
  var vars = [], ranges = [];
  parts.forEach(function(p) {
    p = p.trim();
    var r = parseRange(p);
    if (r) { vars.push(r.varName); ranges.push(r); }
    else { vars.push(p); ranges.push(null); }
  });
  return { vars: vars, ranges: ranges };
}

/** Parse a Giac complex number to [x, y] coordinates */
function parseComplexToPoint(str) {
  str = str.trim();
  try {
    var re = parseFloat(caseval('evalf(re(' + str + '))'));
    var im = parseFloat(caseval('evalf(im(' + str + '))'));
    if (!isNaN(re) && !isNaN(im)) return [re, im];
  } catch(e) {}
  return null;
}

/**
 * Try to render the expression directly with JSXGraph.
 * Returns true if successful, false to fall back to caseval pipeline.
 */
function tryDirectJSXGraph(expr, outputEl) {
  var m, data, plotData;

  // â”€â”€ Helper: parse a plot(...) or plotfunc(...) expression â”€â”€
  // Uses splitTopLevel to properly handle nested parentheses.

  // â”€â”€ plot(expr) or plot(expr,x) or plot([exprs],x) â”€â”€
  if (/^plot\(/.test(expr)) {
    var inner = expr.slice(5, -1); // strip "plot(" and ")"
    var args = splitTopLevel(inner);
    if (args.length >= 1) {
      var funcPart = args[0].trim(), v = (args[1] || 'x').trim();
      // Detect multi-function: plot([sin(x),cos(x)],x)
      if (funcPart.charAt(0) === '[' && funcPart.charAt(funcPart.length - 1) === ']') {
        var funcs = splitTopLevel(funcPart.slice(1, -1));
        var curves = [], allPts = [], colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'];
        for (var i = 0; i < funcs.length; i++) {
          var pts = sampleFuncPoints(funcs[i].trim(), v, -10, 10);
          if (pts) { curves.push({ xs: pts.xs, ys: pts.ys, color: colors[i % colors.length] }); allPts.push(pts); }
        }
        if (curves.length > 0) {
          renderJSXGraphPlot(outputEl, { curves: curves, polygons: [], points: [], bbox: computeBBox(allPts) });
          return true;
        }
      } else {
        // Single function with optional range: plot(sin(x)) or plot(sin(x),x) or plot(sin(x),x=-5..5)
        var range = parseRange(v);
        var varName = range ? range.varName : v;
        var xmin = range ? range.min : -10, xmax = range ? range.max : 10;
        var pts = sampleFuncPoints(funcPart, varName, xmin, xmax);
        if (pts) {
          renderJSXGraphPlot(outputEl, { curves: [{ xs: pts.xs, ys: pts.ys, color: '#e41a1c' }], polygons: [], points: [], bbox: computeBBox([pts]) });
          return true;
        }
      }
    }
  }

  // â”€â”€ plotfunc(expr,x) or plotfunc(expr,x=a..b) â€” 2D ONLY (skip 3D with [x,y]) â”€â”€
  if (/^plotfunc\(/.test(expr)) {
    var inner = expr.slice(9, -1); // strip "plotfunc(" and ")"
    var args = splitTopLevel(inner);
    if (args.length >= 2) {
      var lastArg = args[args.length - 1].trim();
      if (lastArg.charAt(0) === '[') {
        // 3D plotfunc: create canvas BEFORE caseval so Emscripten's SDL/WebGL
        // initializes on our canvas, not the hidden default one.
        if (!webglAvailable()) {
          outputEl.textContent = t('plot3dNotSupported');
          return true;
        }
        var gr = getGiacRenderer();
        if (!gr) { outputEl.textContent = t('plot3dNotSupported'); return true; }

        var container = document.createElement('div');
        container.className = 'gl3d-container';
        var canvas = document.createElement('canvas');
        canvas.id = 'gl3d_pending_' + Date.now();
        var cw = Math.min(outputEl.clientWidth || 600, 600);
        canvas.width = cw;
        canvas.height = Math.round(cw * 2 / 3);
        container.appendChild(canvas);
        outputEl.appendChild(container);

        // Set Module.canvas BEFORE caseval so SDL init targets our canvas
        var savedCanvas = Module.canvas;
        Module.canvas = canvas;

        var raw = caseval(expr);
        if (raw && raw.length > 5 && raw.substr(0, 5) === 'gl3d ') {
          var sceneId = raw.substr(5).trim();
          canvas.id = 'gl3d_' + sceneId;
          try { gr(sceneId); } catch(e) {
            container.innerHTML = '<div class="plot-3d-msg">' + t('plot3dNotSupported') + '</div>';
            Module.canvas = savedCanvas;
            return true;
          }
          // Mouse interaction
          var pushed = false, lastX = 0, lastY = 0;
          canvas.addEventListener('mousedown', function(e) { pushed = true; lastX = e.clientX; lastY = e.clientY; e.preventDefault(); });
          canvas.addEventListener('mouseup', function() { pushed = false; });
          canvas.addEventListener('mouseleave', function() { pushed = false; });
          canvas.addEventListener('mousemove', function(e) {
            if (!pushed) return;
            var dx = e.clientX - lastX, dy = e.clientY - lastY;
            if (Math.abs(dx) > 2) gr((dx > 0 ? 'r' : 'l') + sceneId);
            if (Math.abs(dy) > 2) gr((dy > 0 ? 'd' : 'u') + sceneId);
            lastX = e.clientX; lastY = e.clientY; e.preventDefault();
          });
          // Cleanup SDL keyboard listeners
          try {
            var kle = Module['keyboardListeningElement'] || document;
            if (typeof SDL !== 'undefined' && SDL.receiveEvent) {
              kle.removeEventListener('keydown', SDL.receiveEvent);
              kle.removeEventListener('keyup', SDL.receiveEvent);
              kle.removeEventListener('keypress', SDL.receiveEvent);
            }
          } catch(e) {}
        } else {
          // Not gl3d output â€” remove our canvas, show raw result
          container.remove();
          Module.canvas = savedCanvas;
          return false; // Fall through to normal pipeline
        }
        // Restore saved canvas reference for non-3D future calls
        // (keep Module.canvas = our canvas so rotation commands work)
        return true;
      } else {
        // 2D plotfunc
        var funcPart = args.slice(0, -1).join(',').trim();
        var funcs = (funcPart.charAt(0) === '[' && funcPart.charAt(funcPart.length - 1) === ']')
          ? splitTopLevel(funcPart.slice(1, -1)) : [funcPart];
        var range = parseRange(lastArg);
        var varName = range ? range.varName : lastArg;
        var xmin = range ? range.min : -10, xmax = range ? range.max : 10;
        var curves = [], allPts = [], colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'];
        for (var i = 0; i < funcs.length; i++) {
          var pts = sampleFuncPoints(funcs[i].trim(), varName, xmin, xmax);
          if (pts) { curves.push({ xs: pts.xs, ys: pts.ys, color: colors[i % colors.length] }); allPts.push(pts); }
        }
        if (curves.length > 0) {
          renderJSXGraphPlot(outputEl, { curves: curves, polygons: [], points: [], bbox: computeBBox(allPts) });
          return true;
        }
      }
    }
  }

  // â”€â”€ barplot([3,5,2,8,1]) â”€â”€
  m = expr.match(/^barplot\((.+)\)$/);
  if (m) {
    var vals = parseGiacList(caseval(m[1]));
    if (vals && vals.length > 0) {
      renderJSXBarPlot(outputEl, vals);
      return true;
    }
  }

  // â”€â”€ histogram(data) â”€â”€
  m = expr.match(/^histogram\((.+)\)$/);
  if (m) {
    var vals = parseGiacList(caseval(m[1]));
    if (vals && vals.length > 0) {
      renderJSXHistogram(outputEl, vals);
      return true;
    }
  }

  // â”€â”€ boxwhisker(data) â”€â”€
  m = expr.match(/^boxwhisker\((.+)\)$/);
  if (m) {
    var vals = parseGiacList(caseval(m[1]));
    if (vals && vals.length > 0) {
      renderJSXBoxPlot(outputEl, vals);
      return true;
    }
  }

  // â”€â”€ scatterplot(xs, ys) â”€â”€
  m = expr.match(/^scatterplot\((.+)\)$/);
  if (m) {
    var args = splitTopLevel(m[1]);
    if (args.length === 2) {
      var xs = parseGiacList(caseval(args[0].trim()));
      var ys = parseGiacList(caseval(args[1].trim()));
      if (xs && ys && xs.length === ys.length) {
        renderJSXScatterPlot(outputEl, xs, ys);
        return true;
      }
    }
  }

  // â”€â”€ camembert([["A",30],["B",50],["C",20]]) â”€â”€
  m = expr.match(/^camembert\((.+)\)$/);
  if (m) {
    // Try parsing from raw input first (preserves string labels)
    var pairs = parseGiacPairList(m[1]);
    if (!pairs) {
      // Fallback: evaluate through caseval
      try { pairs = parseGiacPairList(caseval(m[1])); } catch(e) {}
    }
    if (pairs) {
      renderJSXPieChart(outputEl, pairs);
      return true;
    }
  }

  // â”€â”€ plotimplicit(expr, x, y) or plotimplicit(expr, x=a..b, y=c..d) â”€â”€
  if (/^plotimplicit\(/.test(expr)) {
    var inner = expr.slice(13, -1);
    var args = splitTopLevel(inner);
    if (args.length >= 3) {
      var fExpr = args[0].trim();
      var r1 = parseRange(args[1].trim()), r2 = parseRange(args[2].trim());
      var xVar = r1 ? r1.varName : args[1].trim();
      var yVar = r2 ? r2.varName : args[2].trim();
      var xmin = r1 ? r1.min : -5, xmax = r1 ? r1.max : 5;
      var ymin = r2 ? r2.min : -5, ymax = r2 ? r2.max : 5;
      var jsFn = giacExprToJSFunc(fExpr, [xVar, yVar]);
      if (jsFn) {
        var pad = Math.max(xmax - xmin, ymax - ymin) * 0.1;
        var bbox = { xmin: xmin - pad, xmax: xmax + pad, ymin: ymin - pad, ymax: ymax + pad };
        var board = createJSXBoard(outputEl, bbox, { keepAspectRatio: true });
        board.create('implicitcurve', [jsFn], {
          strokeColor: '#e41a1c', strokeWidth: 2, highlight: false
        });
        return true;
      }
    }
  }

  // â”€â”€ plotfield(expr, [x,y]) â”€â”€
  if (/^plotfield\(/.test(expr)) {
    var inner = expr.slice(10, -1);
    var args = splitTopLevel(inner);
    if (args.length >= 2) {
      var fExpr = args[0].trim();
      var vl = parseVarList(args[1]);
      if (vl.vars.length >= 2) {
        var xVar = vl.vars[0], yVar = vl.vars[1];
        var xmin = vl.ranges[0] ? vl.ranges[0].min : -5, xmax = vl.ranges[0] ? vl.ranges[0].max : 5;
        var ymin = vl.ranges[1] ? vl.ranges[1].min : -5, ymax = vl.ranges[1] ? vl.ranges[1].max : 5;
        var jsFn = giacExprToJSFunc(fExpr, [xVar, yVar]);
        if (jsFn) {
          var pad = Math.max(xmax - xmin, ymax - ymin) * 0.1;
          var bbox = { xmin: xmin - pad, xmax: xmax + pad, ymin: ymin - pad, ymax: ymax + pad };
          var board = createJSXBoard(outputEl, bbox);
          var nx = 15, ny = 15;
          var dx = (xmax - xmin) / nx, dy = (ymax - ymin) / ny;
          var scale = Math.min(dx, dy) * 0.4;
          for (var i = 0; i <= nx; i++) {
            for (var j = 0; j <= ny; j++) {
              var px = xmin + i * dx, py = ymin + j * dy;
              var slope = jsFn(px, py);
              if (!isFinite(slope)) continue;
              var len = Math.sqrt(1 + slope * slope);
              var ddx = scale / len, ddy = scale * slope / len;
              var p1 = board.create('point', [px - ddx, py - ddy], { visible: false, fixed: true });
              var p2 = board.create('point', [px + ddx, py + ddy], { visible: false, fixed: true });
              board.create('arrow', [p1, p2], {
                strokeColor: '#377eb8', strokeWidth: 1.5,
                lastArrow: { type: 2, size: 4 },
                fixed: true, highlight: false
              });
            }
          }
          return true;
        }
      }
    }
  }

  // â”€â”€ plotcontour(expr, [x=a..b,y=c..d]) â”€â”€
  if (/^plotcontour\(/.test(expr)) {
    var inner = expr.slice(12, -1);
    var args = splitTopLevel(inner);
    if (args.length >= 2) {
      var fExpr = args[0].trim();
      var vl = parseVarList(args[1]);
      if (vl.vars.length >= 2) {
        var xVar = vl.vars[0], yVar = vl.vars[1];
        var xmin = vl.ranges[0] ? vl.ranges[0].min : -5, xmax = vl.ranges[0] ? vl.ranges[0].max : 5;
        var ymin = vl.ranges[1] ? vl.ranges[1].min : -5, ymax = vl.ranges[1] ? vl.ranges[1].max : 5;
        var jsFn = giacExprToJSFunc(fExpr, [xVar, yVar]);
        if (jsFn) {
          // Sample to find value range
          var vmin = Infinity, vmax = -Infinity, ns = 30;
          for (var i = 0; i <= ns; i++) for (var j = 0; j <= ns; j++) {
            var v = jsFn(xmin + i * (xmax - xmin) / ns, ymin + j * (ymax - ymin) / ns);
            if (isFinite(v)) { if (v < vmin) vmin = v; if (v > vmax) vmax = v; }
          }
          var bbox = { xmin: xmin, xmax: xmax, ymin: ymin, ymax: ymax };
          var board = createJSXBoard(outputEl, bbox);
          var nLevels = 10;
          var colors = ['#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666','#e41a1c','#377eb8'];
          for (var k = 1; k < nLevels; k++) {
            var level = vmin + k * (vmax - vmin) / nLevels;
            (function(lev, col) {
              board.create('implicitcurve', [function(x, y) { return jsFn(x, y) - lev; }], {
                strokeColor: col, strokeWidth: 1.5, highlight: false
              });
            })(level, colors[k % colors.length]);
          }
          return true;
        }
      }
    }
  }

  // â”€â”€ plotode(expr, [t,y], [t0,y0]) â”€â”€
  if (/^plotode\(/.test(expr)) {
    var inner = expr.slice(8, -1);
    var args = splitTopLevel(inner);
    if (args.length >= 3) {
      var fExpr = args[0].trim();
      var vl = parseVarList(args[1]);
      var initStr = args[2].trim();
      if (initStr.charAt(0) === '[') initStr = initStr.slice(1, -1);
      var initParts = splitTopLevel(initStr);
      var t0 = parseFloat(caseval('evalf(' + initParts[0].trim() + ')'));
      var y0 = parseFloat(caseval('evalf(' + initParts[1].trim() + ')'));
      if (vl.vars.length >= 2 && !isNaN(t0) && !isNaN(y0)) {
        var tVar = vl.vars[0], yVar = vl.vars[1];
        var jsFn = giacExprToJSFunc(fExpr, [tVar, yVar]);
        if (jsFn) {
          // RK4 integration forward and backward
          var dt = 0.02;
          var ts = [t0], ys = [y0];
          var t = t0, y = y0;
          for (var step = 0; step < 500; step++) {
            var k1 = jsFn(t, y);
            var k2 = jsFn(t + dt/2, y + dt*k1/2);
            var k3 = jsFn(t + dt/2, y + dt*k2/2);
            var k4 = jsFn(t + dt, y + dt*k3);
            y += dt * (k1 + 2*k2 + 2*k3 + k4) / 6;
            t += dt;
            if (!isFinite(y) || Math.abs(y) > 1e6) break;
            ts.push(t); ys.push(y);
          }
          t = t0; y = y0;
          for (var step = 0; step < 500; step++) {
            var k1 = jsFn(t, y);
            var k2 = jsFn(t - dt/2, y - dt*k1/2);
            var k3 = jsFn(t - dt/2, y - dt*k2/2);
            var k4 = jsFn(t - dt, y - dt*k3);
            y -= dt * (k1 + 2*k2 + 2*k3 + k4) / 6;
            t -= dt;
            if (!isFinite(y) || Math.abs(y) > 1e6) break;
            ts.unshift(t); ys.unshift(y);
          }
          var bbox = computeBBox([{ xs: ts, ys: ys }]);
          var board = createJSXBoard(outputEl, bbox);
          board.create('curve', [ts, ys], { strokeColor: '#e41a1c', strokeWidth: 2, highlight: false });
          board.create('point', [t0, y0], { strokeColor: '#e41a1c', fillColor: '#e41a1c', size: 4, fixed: true, name: '' });
          return true;
        }
      }
    }
  }

  // â”€â”€ plotseq(expr, x0, n) â€” cobweb diagram â”€â”€
  if (/^plotseq\(/.test(expr)) {
    var inner = expr.slice(8, -1);
    var args = splitTopLevel(inner);
    if (args.length >= 3) {
      var fExpr = args[0].trim();
      var x0 = parseFloat(caseval('evalf(' + args[1].trim() + ')'));
      var nIter = parseInt(args[2].trim());
      if (!isNaN(x0) && !isNaN(nIter)) {
        var jsFn = giacExprToJSFunc(fExpr, ['x']);
        if (jsFn) {
          // Determine range by iterating and sampling
          var lo = x0, hi = x0;
          var xn = x0;
          for (var k = 0; k < nIter + 5; k++) {
            xn = jsFn(xn);
            if (!isFinite(xn)) break;
            if (xn < lo) lo = xn;
            if (xn > hi) hi = xn;
          }
          var pad = Math.max((hi - lo) * 0.3, 0.5);
          lo -= pad; hi += pad;

          var bbox = { xmin: lo, xmax: hi, ymin: lo, ymax: hi };
          var board = createJSXBoard(outputEl, bbox, { keepAspectRatio: true });

          // Plot y = f(x)
          var fxs = [], fys = [], nPts = 200;
          for (var k = 0; k <= nPts; k++) {
            var xv = lo + k * (hi - lo) / nPts;
            fxs.push(xv); fys.push(jsFn(xv));
          }
          board.create('curve', [fxs, fys], { strokeColor: '#377eb8', strokeWidth: 2 });

          // Plot y = x
          board.create('line', [[0, 0], [1, 1]], { strokeColor: '#999999', strokeWidth: 1, dash: 2 });

          // Cobweb staircase
          var cwXs = [x0, x0], cwYs = [0, jsFn(x0)];
          xn = x0;
          for (var k = 0; k < nIter; k++) {
            var yn = jsFn(xn);
            cwXs.push(yn); cwYs.push(yn);   // horizontal to y=x
            cwXs.push(yn); cwYs.push(jsFn(yn)); // vertical to f(x)
            xn = yn;
          }
          board.create('curve', [cwXs, cwYs], { strokeColor: '#e41a1c', strokeWidth: 1.5 });

          return true;
        }
      }
    }
  }

  // â”€â”€ Geometry: circle, segment, point, triangle (multi-command with ;) â”€â”€
  if (/\b(circle|segment|point|triangle)\s*\(/.test(expr)) {
    var cmds = expr.split(';').map(function(s) { return s.trim(); }).filter(Boolean);
    var geomObjects = [];
    cmds.forEach(function(cmd) {
      var gm;
      // circle(center, radius)
      gm = cmd.match(/^circle\((.+?),\s*(.+)\)$/);
      if (gm) {
        var center = parseComplexToPoint(gm[1]);
        var radius = parseFloat(caseval('evalf(' + gm[2].trim() + ')'));
        if (center && !isNaN(radius) && radius > 0) {
          geomObjects.push({ type: 'circle', center: center, radius: radius });
        }
        return;
      }
      // segment([x1,y1],[x2,y2])
      gm = cmd.match(/^segment\(\[(.+?)\]\s*,\s*\[(.+?)\]\)$/);
      if (gm) {
        var c1 = gm[1].split(',').map(function(s) { return parseFloat(caseval('evalf(' + s.trim() + ')')); });
        var c2 = gm[2].split(',').map(function(s) { return parseFloat(caseval('evalf(' + s.trim() + ')')); });
        if (c1.length === 2 && c2.length === 2 && c1.every(isFinite) && c2.every(isFinite)) {
          geomObjects.push({ type: 'segment', p1: c1, p2: c2 });
        }
        return;
      }
      // point(x, y)
      gm = cmd.match(/^point\((.+?),\s*(.+)\)$/);
      if (gm) {
        var px = parseFloat(caseval('evalf(' + gm[1].trim() + ')'));
        var py = parseFloat(caseval('evalf(' + gm[2].trim() + ')'));
        if (isFinite(px) && isFinite(py)) {
          geomObjects.push({ type: 'point', coords: [px, py] });
        }
        return;
      }
      // triangle(a, b, c) â€” complex number vertices
      gm = cmd.match(/^triangle\((.+)\)$/);
      if (gm) {
        var tArgs = splitTopLevel(gm[1]);
        var verts = tArgs.map(function(a) { return parseComplexToPoint(a.trim()); }).filter(Boolean);
        if (verts.length === 3) {
          geomObjects.push({ type: 'triangle', vertices: verts });
        }
        return;
      }
    });

    if (geomObjects.length > 0) {
      // Compute bounding box
      var allXs = [], allYs = [];
      geomObjects.forEach(function(obj) {
        if (obj.type === 'circle') {
          allXs.push(obj.center[0] - obj.radius, obj.center[0] + obj.radius);
          allYs.push(obj.center[1] - obj.radius, obj.center[1] + obj.radius);
        } else if (obj.type === 'segment') {
          allXs.push(obj.p1[0], obj.p2[0]); allYs.push(obj.p1[1], obj.p2[1]);
        } else if (obj.type === 'point') {
          allXs.push(obj.coords[0]); allYs.push(obj.coords[1]);
        } else if (obj.type === 'triangle') {
          obj.vertices.forEach(function(v) { allXs.push(v[0]); allYs.push(v[1]); });
        }
      });
      var gxmin = Math.min.apply(null, allXs), gxmax = Math.max.apply(null, allXs);
      var gymin = Math.min.apply(null, allYs), gymax = Math.max.apply(null, allYs);
      var gpad = Math.max(gxmax - gxmin, gymax - gymin) * 0.2 || 1;
      var bbox = { xmin: gxmin - gpad, xmax: gxmax + gpad, ymin: gymin - gpad, ymax: gymax + gpad };
      // Make square for geometry
      var w = bbox.xmax - bbox.xmin, h = bbox.ymax - bbox.ymin;
      if (w > h) { var d = (w - h) / 2; bbox.ymin -= d; bbox.ymax += d; }
      else { var d = (h - w) / 2; bbox.xmin -= d; bbox.xmax += d; }

      var board = createJSXBoard(outputEl, bbox, { keepAspectRatio: true });
      var colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00'];
      var ci = 0;

      geomObjects.forEach(function(obj) {
        var color = colors[ci++ % colors.length];
        if (obj.type === 'circle') {
          var c = board.create('point', obj.center, { visible: false, fixed: true });
          board.create('circle', [c, obj.radius], {
            strokeColor: color, strokeWidth: 2, fillColor: 'none', highlight: false
          });
        } else if (obj.type === 'segment') {
          var pa = board.create('point', obj.p1, { visible: false, fixed: true });
          var pb = board.create('point', obj.p2, { visible: false, fixed: true });
          board.create('segment', [pa, pb], { strokeColor: color, strokeWidth: 2, highlight: false });
        } else if (obj.type === 'point') {
          board.create('point', obj.coords, {
            strokeColor: color, fillColor: color, size: 4, fixed: true, name: ''
          });
        } else if (obj.type === 'triangle') {
          var verts = obj.vertices.map(function(v) {
            return board.create('point', v, { visible: true, fixed: true, size: 2, strokeColor: color, fillColor: color, name: '' });
          });
          board.create('polygon', verts, {
            borders: { strokeColor: color, strokeWidth: 2 },
            fillColor: color, fillOpacity: 0.1,
            vertices: { visible: true }, highlight: false
          });
        }
      });

      return true;
    }
  }

  return false; // Not recognized â€” fall back to caseval pipeline
}

/** Split "sin(x),cos(x)" respecting parentheses */
function splitTopLevel(str) {
  var parts = [], depth = 0, start = 0;
  for (var i = 0; i < str.length; i++) {
    if (str[i] === '(' || str[i] === '[') depth++;
    else if (str[i] === ')' || str[i] === ']') depth--;
    else if (str[i] === ',' && depth === 0) {
      parts.push(str.substring(start, i));
      start = i + 1;
    }
  }
  parts.push(str.substring(start));
  return parts;
}

/** Compute bounding box from arrays of point sets */
function computeBBox(ptSets) {
  var allXs = [], allYs = [];
  ptSets.forEach(function(pts) {
    pts.xs.forEach(function(x) { if (isFinite(x)) allXs.push(x); });
    pts.ys.forEach(function(y) { if (isFinite(y)) allYs.push(y); });
  });
  var xmin = Math.min.apply(null, allXs), xmax = Math.max.apply(null, allXs);
  var ymin = Math.min.apply(null, allYs), ymax = Math.max.apply(null, allYs);
  var padX = (xmax - xmin) * 0.08 || 1, padY = (ymax - ymin) * 0.08 || 1;
  return { xmin: xmin - padX, xmax: xmax + padX, ymin: ymin - padY, ymax: ymax + padY };
}

/** Render a bar plot with JSXGraph */
function renderJSXBarPlot(outputEl, vals) {
  var polygons = [], maxVal = Math.max.apply(null, vals);
  for (var i = 0; i < vals.length; i++) {
    polygons.push({
      corners: [[i + 0.1, 0], [i + 0.9, 0], [i + 0.9, vals[i]], [i + 0.1, vals[i]]],
      color: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628', '#f781bf', '#999999'][i % 8]
    });
  }
  var bbox = { xmin: -0.5, xmax: vals.length + 0.5, ymin: -maxVal * 0.1, ymax: maxVal * 1.15 };
  renderJSXGraphPlot(outputEl, { curves: [], polygons: polygons, points: [], bbox: bbox });
}

/** Render a histogram with JSXGraph */
function renderJSXHistogram(outputEl, vals) {
  var min = Math.min.apply(null, vals), max = Math.max.apply(null, vals);
  var nBins = Math.max(5, Math.min(30, Math.ceil(Math.sqrt(vals.length))));
  var binWidth = (max - min) / nBins || 1;
  var bins = new Array(nBins).fill(0);
  vals.forEach(function(v) {
    var idx = Math.min(Math.floor((v - min) / binWidth), nBins - 1);
    bins[idx]++;
  });
  var maxCount = Math.max.apply(null, bins);
  var polygons = [];
  for (var i = 0; i < nBins; i++) {
    var x0 = min + i * binWidth, x1 = x0 + binWidth;
    polygons.push({
      corners: [[x0, 0], [x1, 0], [x1, bins[i]], [x0, bins[i]]],
      color: '#377eb8'
    });
  }
  var bbox = { xmin: min - binWidth, xmax: max + binWidth, ymin: -maxCount * 0.1, ymax: maxCount * 1.2 };
  renderJSXGraphPlot(outputEl, { curves: [], polygons: polygons, points: [], bbox: bbox });
}

/** Render a box-and-whisker plot with JSXGraph */
function renderJSXBoxPlot(outputEl, vals) {
  vals.sort(function(a, b) { return a - b; });
  var n = vals.length;
  var q1 = vals[Math.floor(n * 0.25)], q2 = vals[Math.floor(n * 0.5)], q3 = vals[Math.floor(n * 0.75)];
  var vmin = vals[0], vmax = vals[n - 1];
  var range = vmax - vmin || 1;
  var polygons = [
    // Box (Q1 to Q3)
    { corners: [[0.3, q1], [0.7, q1], [0.7, q3], [0.3, q3]], color: '#377eb8' }
  ];
  var curves = [
    // Median line
    { xs: [0.3, 0.7], ys: [q2, q2], color: '#e41a1c' },
    // Lower whisker
    { xs: [0.5, 0.5], ys: [vmin, q1], color: 'black' },
    { xs: [0.4, 0.6], ys: [vmin, vmin], color: 'black' },
    // Upper whisker
    { xs: [0.5, 0.5], ys: [q3, vmax], color: 'black' },
    { xs: [0.4, 0.6], ys: [vmax, vmax], color: 'black' }
  ];
  var bbox = { xmin: -0.5, xmax: 1.5, ymin: vmin - range * 0.15, ymax: vmax + range * 0.15 };
  renderJSXGraphPlot(outputEl, { curves: curves, polygons: polygons, points: [], bbox: bbox });
}

/** Render a scatter plot with JSXGraph */
function renderJSXScatterPlot(outputEl, xs, ys) {
  var pts = [];
  for (var i = 0; i < xs.length; i++) pts.push({ x: xs[i], y: ys[i], color: '#e41a1c' });
  var bbox = computeBBox([{ xs: xs, ys: ys }]);
  renderJSXGraphPlot(outputEl, { curves: [], polygons: [], points: pts, bbox: bbox });
}

/** Render a pie chart with JSXGraph */
function renderJSXPieChart(outputEl, pairs) {
  var total = pairs.reduce(function(s, p) { return s + p.value; }, 0);
  if (total <= 0) return;
  var colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628', '#f781bf', '#999999'];
  var polygons = [], labels = [], angle = 0;
  pairs.forEach(function(p, idx) {
    var sweep = (p.value / total) * 2 * Math.PI;
    var corners = [[0, 0]];
    var steps = Math.max(20, Math.round(sweep * 30));
    for (var s = 0; s <= steps; s++) {
      var a = angle + sweep * s / steps;
      corners.push([Math.cos(a), Math.sin(a)]);
    }
    polygons.push({ corners: corners, color: colors[idx % colors.length] });
    // Label at midpoint of sector
    var midAngle = angle + sweep / 2;
    labels.push({ x: 0.6 * Math.cos(midAngle), y: 0.6 * Math.sin(midAngle), text: p.label });
    angle += sweep;
  });
  var bbox = { xmin: -1.5, xmax: 1.5, ymin: -1.5, ymax: 1.5 };
  renderJSXGraphPlot(outputEl, { curves: [], polygons: polygons, points: [], labels: labels, bbox: bbox });
}

// â”€â”€ JSXGraph board management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function jsxGraphAvailable() {
  return typeof JXG !== 'undefined' && JXG.JSXGraph;
}

var jsxGraphBoardCounter = 0;
var jsxGraphBoards = {};

function cleanupJSXGraphBoard(boardId) {
  if (jsxGraphBoards[boardId]) {
    try { JXG.JSXGraph.freeBoard(jsxGraphBoards[boardId]); } catch(e) {}
    delete jsxGraphBoards[boardId];
  }
}

function cleanupJSXGraphInElement(el) {
  var boxes = el.querySelectorAll('.jxgbox');
  boxes.forEach(function(box) { cleanupJSXGraphBoard(box.id); });
}

/** Parse Giac SVG output into curve data for JSXGraph */
function parseSvgPlotData(svgString) {
  var parser = new DOMParser();
  // Use text/html (lenient) because Giac SVG may have malformed attributes (missing spaces)
  var doc = parser.parseFromString(svgString, 'text/html');
  var svg = doc.querySelector('svg');
  if (!svg) return null;

  // Giac SVG uses math coordinates directly in line/path elements.
  // A <g transform="scale(1,-1)"> handles the y-flip for SVG rendering.
  // We read the raw attribute values as math coordinates â€” no y-negation needed.

  var curves = [];
  var defaultColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'];
  var colorIdx = 0;

  // Group <line> elements by color+strokeWidth
  var lineGroups = {};
  var lines = svg.querySelectorAll('line');
  lines.forEach(function(ln) {
    var x1 = parseFloat(ln.getAttribute('x1')), y1 = parseFloat(ln.getAttribute('y1'));
    var x2 = parseFloat(ln.getAttribute('x2')), y2 = parseFloat(ln.getAttribute('y2'));
    if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) return;
    var color = ln.getAttribute('stroke') || 'black';
    var sw = parseFloat(ln.getAttribute('stroke-width')) || 1;
    var key = color + '|' + sw;
    if (!lineGroups[key]) lineGroups[key] = { color: color, strokeWidth: sw, segments: [] };
    lineGroups[key].segments.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
  });

  // Build curves from line groups â€” need many segments (skip axes/borders)
  Object.keys(lineGroups).forEach(function(key) {
    var group = lineGroups[key];
    // Plot curves have many segments (50+), axis/border lines have few (<10)
    if (group.segments.length < 10) return;
    var segs = group.segments;
    var xs = [segs[0].x1], ys = [segs[0].y1];
    for (var i = 0; i < segs.length; i++) {
      xs.push(segs[i].x2); ys.push(segs[i].y2);
    }
    if (xs.length > 1) {
      curves.push({ xs: xs, ys: ys, color: group.color });
    }
  });

  // Extract polyline elements
  var polylines = svg.querySelectorAll('polyline');
  polylines.forEach(function(pl) {
    var pts = pl.getAttribute('points');
    if (!pts) return;
    var pairs = pts.trim().split(/\s+/);
    var xs = [], ys = [];
    pairs.forEach(function(p) {
      var xy = p.split(',');
      if (xy.length === 2) {
        xs.push(parseFloat(xy[0]));
        ys.push(parseFloat(xy[1]));
      }
    });
    if (xs.length > 1) {
      var color = pl.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
      curves.push({ xs: xs, ys: ys, color: color });
    }
  });

  var polygons = [];
  var points = [];

  // Extract <circle> elements â€” large circles as curves, small ones as points
  var circles = svg.querySelectorAll('circle');
  circles.forEach(function(circ) {
    var cx = parseFloat(circ.getAttribute('cx')) || 0;
    var cy = parseFloat(circ.getAttribute('cy')) || 0;
    var r = parseFloat(circ.getAttribute('r'));
    if (isNaN(r) || r <= 0) return;
    var color = circ.getAttribute('stroke') || circ.getAttribute('fill') || defaultColors[colorIdx++ % defaultColors.length];
    if (r < 5) {
      // Small circle = scatter point
      points.push({ x: cx, y: cy, color: color });
    } else {
      // Large circle = curve
      var xs = [], ys = [], steps = 64;
      for (var s = 0; s <= steps; s++) {
        var a = 2 * Math.PI * s / steps;
        xs.push(cx + r * Math.cos(a));
        ys.push(cy + r * Math.sin(a));
      }
      curves.push({ xs: xs, ys: ys, color: color });
    }
  });

  // Extract <ellipse> elements
  var ellipses = svg.querySelectorAll('ellipse');
  ellipses.forEach(function(el) {
    var cx = parseFloat(el.getAttribute('cx')) || 0;
    var cy = parseFloat(el.getAttribute('cy')) || 0;
    var rx = parseFloat(el.getAttribute('rx'));
    var ry = parseFloat(el.getAttribute('ry'));
    if (isNaN(rx) || isNaN(ry) || rx <= 0 || ry <= 0) return;
    var xs = [], ys = [], steps = 64;
    for (var s = 0; s <= steps; s++) {
      var a = 2 * Math.PI * s / steps;
      xs.push(cx + rx * Math.cos(a));
      ys.push(cy + ry * Math.sin(a));
    }
    var color = el.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
    curves.push({ xs: xs, ys: ys, color: color });
  });

  // Extract <rect> elements (bars in histograms/barplots, boxes in boxwhisker)
  var rects = svg.querySelectorAll('rect');
  rects.forEach(function(rect) {
    var x = parseFloat(rect.getAttribute('x')) || 0;
    var y = parseFloat(rect.getAttribute('y')) || 0;
    var w = parseFloat(rect.getAttribute('width'));
    var h = parseFloat(rect.getAttribute('height'));
    if (isNaN(w) || isNaN(h) || w <= 0 || h <= 0) return;
    var fill = rect.getAttribute('fill') || rect.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
    if (fill === 'none' || fill === 'white' || fill === '#ffffff') return; // skip background rects
    polygons.push({
      corners: [[x, y], [x + w, y], [x + w, y + h], [x, y + h]],
      color: fill
    });
  });

  // Extract <polygon> elements
  var svgPolygons = svg.querySelectorAll('polygon');
  svgPolygons.forEach(function(pg) {
    var pts = pg.getAttribute('points');
    if (!pts) return;
    var corners = [];
    pts.trim().split(/\s+/).forEach(function(p) {
      var xy = p.split(',');
      if (xy.length === 2) corners.push([parseFloat(xy[0]), parseFloat(xy[1])]);
    });
    if (corners.length >= 3) {
      var fill = pg.getAttribute('fill') || pg.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
      polygons.push({ corners: corners, color: fill });
    }
  });

  // Extract path elements (supports both absolute and relative commands)
  var paths = svg.querySelectorAll('path');
  paths.forEach(function(path) {
    var d = path.getAttribute('d');
    if (!d) return;
    var xs = [], ys = [];
    var commands = d.match(/[MLCQZAHVmlcqzahv][^MLCQZAHVmlcqzahv]*/g);
    if (!commands) return;
    var curX = 0, curY = 0;
    commands.forEach(function(cmd) {
      var type = cmd.charAt(0);
      var nums = cmd.slice(1).trim().split(/[\s,]+/).map(Number);
      var rel = (type === type.toLowerCase()); // relative if lowercase
      var T = type.toUpperCase();
      if (T === 'M' || T === 'L') {
        for (var i = 0; i + 1 < nums.length; i += 2) {
          curX = rel ? curX + nums[i] : nums[i];
          curY = rel ? curY + nums[i + 1] : nums[i + 1];
          xs.push(curX); ys.push(curY);
        }
      } else if (T === 'H') {
        for (var i = 0; i < nums.length; i++) {
          curX = rel ? curX + nums[i] : nums[i];
          xs.push(curX); ys.push(curY);
        }
      } else if (T === 'V') {
        for (var i = 0; i < nums.length; i++) {
          curY = rel ? curY + nums[i] : nums[i];
          xs.push(curX); ys.push(curY);
        }
      } else if (T === 'C') {
        for (var i = 0; i + 5 < nums.length; i += 6) {
          var px = curX, py = curY;
          var cp1x = rel ? px + nums[i] : nums[i], cp1y = rel ? py + nums[i+1] : nums[i+1];
          var cp2x = rel ? px + nums[i+2] : nums[i+2], cp2y = rel ? py + nums[i+3] : nums[i+3];
          var ex = rel ? px + nums[i+4] : nums[i+4], ey = rel ? py + nums[i+5] : nums[i+5];
          for (var t = 1; t <= 20; t++) {
            var u = t / 20, u2 = u*u, u3 = u2*u, inv = 1-u, inv2 = inv*inv, inv3 = inv2*inv;
            xs.push(inv3*px + 3*inv2*u*cp1x + 3*inv*u2*cp2x + u3*ex);
            ys.push(inv3*py + 3*inv2*u*cp1y + 3*inv*u2*cp2y + u3*ey);
          }
          curX = ex; curY = ey;
        }
      } else if (T === 'Q') {
        for (var i = 0; i + 3 < nums.length; i += 4) {
          var px = curX, py = curY;
          var cpx = rel ? px + nums[i] : nums[i], cpy = rel ? py + nums[i+1] : nums[i+1];
          var ex = rel ? px + nums[i+2] : nums[i+2], ey = rel ? py + nums[i+3] : nums[i+3];
          for (var t = 1; t <= 20; t++) {
            var u = t / 20, inv = 1-u;
            xs.push(inv*inv*px + 2*inv*u*cpx + u*u*ex);
            ys.push(inv*inv*py + 2*inv*u*cpy + u*u*ey);
          }
          curX = ex; curY = ey;
        }
      } else if (T === 'A') {
        // Arc: rx ry x-rotation large-arc sweep-flag x y
        for (var i = 0; i + 6 < nums.length; i += 7) {
          var ex = rel ? curX + nums[i+5] : nums[i+5];
          var ey = rel ? curY + nums[i+6] : nums[i+6];
          // Approximate arc with line segments
          var steps = 20;
          for (var t = 1; t <= steps; t++) {
            var u = t / steps;
            xs.push(curX + (ex - curX) * u);
            ys.push(curY + (ey - curY) * u);
          }
          curX = ex; curY = ey;
        }
      }
    });
    if (xs.length > 1) {
      var color = path.getAttribute('stroke') || defaultColors[colorIdx++ % defaultColors.length];
      curves.push({ xs: xs, ys: ys, color: color });
    }
  });

  if (curves.length === 0 && polygons.length === 0 && points.length === 0) return null;

  // Compute tight bounding box from all data
  var allXs = [], allYs = [];
  curves.forEach(function(c) { allXs = allXs.concat(c.xs); allYs = allYs.concat(c.ys); });
  polygons.forEach(function(p) { p.corners.forEach(function(c) { allXs.push(c[0]); allYs.push(c[1]); }); });
  points.forEach(function(p) { allXs.push(p.x); allYs.push(p.y); });
  var dataXmin = Math.min.apply(null, allXs), dataXmax = Math.max.apply(null, allXs);
  var dataYmin = Math.min.apply(null, allYs), dataYmax = Math.max.apply(null, allYs);
  var padX = (dataXmax - dataXmin) * 0.08 || 1;
  var padY = (dataYmax - dataYmin) * 0.08 || 1;
  var bbox = {
    xmin: dataXmin - padX, xmax: dataXmax + padX,
    ymin: dataYmin - padY, ymax: dataYmax + padY
  };

  return { curves: curves, polygons: polygons, points: points, bbox: bbox };
}

/** Parse gr2d(logo(...)) output into curve data for JSXGraph */
function parseGr2dLogoData(gr2dString) {
  var inner = gr2dString.substr(5, gr2dString.length - 6); // strip "gr2d(" and ")"
  if (inner.length < 6 || inner.substr(0, 5) !== 'logo(') return null;
  var logoData = inner.substr(5, inner.length - 6);
  var v;
  try { v = JSON.parse(logoData); } catch(e) {
    try { v = (0, eval)(logoData); } catch(e2) { return null; }
  }
  if (!Array.isArray(v) || v.length < 2) return null;

  // Group consecutive pen-down vertices by color into curve segments
  var curves = [];
  var currentXs = [], currentYs = [], currentColor = null;

  for (var k = 1; k < v.length; k++) {
    var prec = v[k - 1], cur = v[k];
    // Skip text labels
    if (cur[5] && cur[5].length) continue;
    var penDown = prec[3] & 1;
    var colorIdx = prec[3] >> 11;
    var color = plotResolveColor(colorIdx);

    if (penDown && cur[4] === 0) { // Normal line segment (not arc/polygon)
      if (color !== currentColor) {
        // Flush previous segment
        if (currentXs.length > 1) {
          curves.push({ xs: currentXs.slice(), ys: currentYs.slice(), color: currentColor });
        }
        currentXs = [prec[0]]; currentYs = [prec[1]];
        currentColor = color;
      } else if (currentXs.length === 0) {
        currentXs.push(prec[0]); currentYs.push(prec[1]);
      }
      currentXs.push(cur[0]); currentYs.push(cur[1]);
    } else {
      // Flush on non-line segment
      if (currentXs.length > 1) {
        curves.push({ xs: currentXs.slice(), ys: currentYs.slice(), color: currentColor });
      }
      currentXs = []; currentYs = []; currentColor = null;

      // Handle arcs: sample points along the arc
      if (cur[4] > 0) {
        var radius = cur[4];
        var r = radius & 0x1ff;
        var theta1 = prec[2] + ((radius >> 9) & 0x1ff);
        var theta2 = prec[2] + ((radius >> 18) & 0x1ff);
        var angle1 = theta1 * Math.PI / 180;
        var angle2 = theta2 * Math.PI / 180;
        var cx = cur[0] - r * Math.cos((theta2 - 90) * Math.PI / 180);
        var cy = cur[1] - r * Math.sin((theta2 - 90) * Math.PI / 180);
        var arcColor = plotResolveColor(cur[3] >> 11);
        var arcXs = [], arcYs = [];
        var steps = Math.max(40, Math.abs(theta2 - theta1));
        for (var s = 0; s <= steps; s++) {
          var a = ((theta1 - 90) + (theta2 - theta1 - 90 + 90) * s / steps) * Math.PI / 180;
          // Simpler: linearly interpolate angle
          var aa = angle1 + (angle2 - angle1) * s / steps;
          arcXs.push(cx + r * Math.cos(aa));
          arcYs.push(cy + r * Math.sin(aa));
        }
        if (arcXs.length > 1) {
          curves.push({ xs: arcXs, ys: arcYs, color: arcColor });
        }
      }
    }
  }
  // Flush final segment
  if (currentXs.length > 1) {
    curves.push({ xs: currentXs.slice(), ys: currentYs.slice(), color: currentColor });
  }

  if (curves.length === 0) return null;

  // Compute bounding box
  var allXs = [], allYs = [];
  curves.forEach(function(c) { allXs = allXs.concat(c.xs); allYs = allYs.concat(c.ys); });
  var xmin = Math.min.apply(null, allXs), xmax = Math.max.apply(null, allXs);
  var ymin = Math.min.apply(null, allYs), ymax = Math.max.apply(null, allYs);
  var padX = (xmax - xmin) * 0.08 || 1;
  var padY = (ymax - ymin) * 0.08 || 1;

  return {
    curves: curves,
    bbox: { xmin: xmin - padX, xmax: xmax + padX, ymin: ymin - padY, ymax: ymax + padY }
  };
}

/** Render plot data using JSXGraph */
function renderJSXGraphPlot(outputEl, plotData) {
  var boardId = 'jsxgraph-' + (++jsxGraphBoardCounter);
  var wrapper = document.createElement('div');
  wrapper.className = 'jxgbox-container';
  var box = document.createElement('div');
  box.id = boardId;
  box.className = 'jxgbox';
  wrapper.appendChild(box);
  outputEl.appendChild(wrapper);

  var bb = plotData.bbox;
  var board = JXG.JSXGraph.initBoard(boardId, {
    boundingbox: [bb.xmin, bb.ymax, bb.xmax, bb.ymin],
    axis: true,
    showCopyright: false,
    showNavigation: true,
    pan: { enabled: true },
    zoom: { enabled: true, wheel: true, pinch: true }
  });

  var defaultColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628'];
  plotData.curves.forEach(function(curve, idx) {
    var color = curve.color || defaultColors[idx % defaultColors.length];
    board.create('curve', [curve.xs, curve.ys], {
      strokeColor: color,
      strokeWidth: 2,
      highlight: false
    });
  });

  // Render filled polygons (rects from histograms/barplots, SVG polygons)
  if (plotData.polygons) {
    plotData.polygons.forEach(function(pg) {
      var verts = pg.corners.map(function(c) {
        return board.create('point', c, { visible: false, fixed: true });
      });
      board.create('polygon', verts, {
        fillColor: pg.color,
        fillOpacity: 0.7,
        borders: { strokeColor: pg.color, strokeWidth: 1 },
        vertices: { visible: false },
        highlight: false
      });
    });
  }

  // Render scatter points
  if (plotData.points) {
    plotData.points.forEach(function(pt) {
      board.create('point', [pt.x, pt.y], {
        strokeColor: pt.color,
        fillColor: pt.color,
        size: 3,
        fixed: true,
        highlight: false
      });
    });
  }

  // Render text labels (for pie charts etc.)
  if (plotData.labels) {
    plotData.labels.forEach(function(lbl) {
      board.create('text', [lbl.x, lbl.y, lbl.text], {
        anchorX: 'middle',
        anchorY: 'middle',
        fontSize: 14,
        fixed: true,
        highlight: false
      });
    });
  }

  jsxGraphBoards[boardId] = board;
  return board;
}

// â”€â”€ gl3d 3D Plot Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Uses Giac's built-in OpenGL renderer compiled to WebGL via Emscripten.
// No external 3D library needed â€” giac_renderer() draws directly to canvas.

function webglAvailable() {
  try {
    var c = document.createElement('canvas');
    return !!(c.getContext('webgl') || c.getContext('experimental-webgl'));
  } catch(e) { return false; }
}

var gl3dRendererFn = null;

function getGiacRenderer() {
  if (gl3dRendererFn) return gl3dRendererFn;
  try {
    gl3dRendererFn = Module.cwrap('_ZN4giac13giac_rendererEPKc', 'number', ['string']);
    return gl3dRendererFn;
  } catch(e) { return null; }
}

function renderGl3dPlot(outputEl, sceneId) {
  // Check WebGL availability
  if (UI.disable3d || !webglAvailable()) {
    var msg = document.createElement('div');
    msg.className = 'plot-3d-msg';
    msg.textContent = t('plot3dNotSupported');
    outputEl.appendChild(msg);
    return;
  }

  var gr = getGiacRenderer();
  if (!gr) {
    var msg = document.createElement('div');
    msg.className = 'plot-3d-msg';
    msg.textContent = t('plot3dNotSupported');
    outputEl.appendChild(msg);
    return;
  }

  // Create canvas with required ID pattern for Giac's renderer
  var canvasId = 'gl3d_' + sceneId;
  var container = document.createElement('div');
  container.className = 'gl3d-container';

  var canvas = document.createElement('canvas');
  canvas.id = canvasId;
  // Responsive: use container width but cap at 600px
  var containerWidth = Math.min(outputEl.clientWidth || 600, 600);
  canvas.width = containerWidth;
  canvas.height = Math.round(containerWidth * 2 / 3); // 3:2 aspect ratio
  container.appendChild(canvas);
  outputEl.appendChild(container);

  // Point Emscripten's GL output to this canvas, then render
  Module.canvas = canvas;
  try {
    gr(sceneId);
  } catch(e) {
    container.innerHTML = '';
    var msg = document.createElement('div');
    msg.className = 'plot-3d-msg';
    msg.textContent = t('plot3dNotSupported');
    container.appendChild(msg);
    return;
  }

  // Mouse interaction for 3D rotation
  var pushed = false, lastX = 0, lastY = 0;

  canvas.addEventListener('mousedown', function(e) {
    pushed = true;
    lastX = e.clientX;
    lastY = e.clientY;
    e.preventDefault();
  });

  canvas.addEventListener('mouseup', function() { pushed = false; });
  canvas.addEventListener('mouseleave', function() { pushed = false; });

  canvas.addEventListener('mousemove', function(e) {
    if (!pushed) return;
    var dx = e.clientX - lastX;
    var dy = e.clientY - lastY;
    if (Math.abs(dx) > 2) {
      gr((dx > 0 ? 'r' : 'l') + sceneId);
    }
    if (Math.abs(dy) > 2) {
      gr((dy > 0 ? 'd' : 'u') + sceneId);
    }
    lastX = e.clientX;
    lastY = e.clientY;
    e.preventDefault();
  });

  // Clean up SDL keyboard listeners that Emscripten attaches
  try {
    var kle = Module['keyboardListeningElement'] || document;
    if (typeof SDL !== 'undefined' && SDL.receiveEvent) {
      kle.removeEventListener('keydown', SDL.receiveEvent);
      kle.removeEventListener('keyup', SDL.receiveEvent);
      kle.removeEventListener('keypress', SDL.receiveEvent);
    }
  } catch(e) { /* SDL may not exist */ }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION 14 â€” REACTIVE DAG (Observable Runtime)
//
// Dependency tracking and automatic re-evaluation using
// Observable Runtime. Each cell becomes a reactive variable
// in a DAG. When an upstream cell changes, all downstream
// cells re-evaluate automatically in topological order.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Known Giac built-in functions and keywords â€” NOT notebook variables
var GIAC_BUILTINS = new Set([
  'sin','cos','tan','asin','acos','atan','atan2','exp','ln','log','log10',
  'sqrt','abs','ceil','floor','round','sign','max','min','gcd','lcm','mod',
  'pi','e','i','true','false','inf','infinity','undef',
  'solve','fsolve','linsolve','factor','expand','simplify','normal','collect',
  'diff','integrate','limit','sum','product','series','taylor','laplace','ilaplace',
  'matrix','det','eigenvalues','eigenvectors','transpose','inv','rref','rank','ker',
  'plot','plotfunc','plotimplicit','plotfield','plotcontour','plotode','plotseq',
  'plotparam','plotpolar','plotparam3d','plot3d',
  'histogram','barplot','camembert','boxwhisker','scatterplot',
  'circle','segment','point','triangle','line','polygon','arc',
  'seq','rand','randint','randn','sort','size','length','dim','append','remove',
  'evalf','latex','lname','VARS','string','expr','subst','assume','purge',
  'if','then','else','for','while','do','od','fi','proc','return','local',
  'print','input','nops','op','head','tail','map','apply','select','zip',
  're','im','conj','arg','real','imag',
  'irem','iquo','isprime','ifactor','euler','nextprime','prevprime',
  'quo','rem','gcdex','hermite','smith',
  'pmin','pmax','fMin','fMax','extrema','implicitplot'
]);

/** Extract variable definitions (:=) and references from a cell expression.
 *  Uses pure syntactic analysis (regex) â€” NOT lname() which is state-dependent. */
function extractCellDependencies(expr) {
  var defines = [];
  var references = [];
  if (!expr || !expr.trim()) return { defines: defines, references: references };

  // Extract `:=` assignments (Giac assignment operator)
  var assignRe = /(\w+)\s*:=/g;
  var m;
  while ((m = assignRe.exec(expr)) !== null) {
    if (defines.indexOf(m[1]) === -1) defines.push(m[1]);
  }

  // Extract all identifiers via regex (state-independent)
  var idRe = /\b([a-zA-Z_]\w*)\b/g;
  while ((m = idRe.exec(expr)) !== null) {
    var name = m[1];
    if (!GIAC_BUILTINS.has(name)
        && defines.indexOf(name) === -1
        && references.indexOf(name) === -1
        && !/^\d/.test(name)) {
      references.push(name);
    }
  }

  return { defines: defines, references: references };
}

/** Check if Observable Runtime is available */
function observableAvailable() {
  return window._ObservableRuntime != null && typeof window._ObservableRuntime === 'function';
}

/** Initialize the Observable runtime and module (async â€” waits for CDN load) */
function initReactiveRuntime() {
  window._observableReady.then(function() {
    if (!observableAvailable()) {
      console.warn('Observable Runtime not loaded â€” reactive mode disabled');
      reactiveMode = false;
      var toggle = document.getElementById('reactive-toggle');
      if (toggle) { toggle.checked = false; toggle.disabled = true; }
      return;
    }
    try {
      observableRuntime = new window._ObservableRuntime();
      observableModule = observableRuntime.module();
      console.log('Reactive DAG runtime initialized');
    } catch(e) {
      console.error('Failed to init reactive runtime:', e);
      reactiveMode = false;
    }
  });
}

/** Create an Observable observer that renders a cell's output */
function makeCellObserver(cellId) {
  return {
    pending: function() {
      var el = document.getElementById(cellId);
      if (el) el.classList.add('cell-pending');
      var out = document.getElementById(cellId + '-output');
      if (out) out.innerHTML = '<span class="spinner"></span> ' + t('pendingEvaluation');
    },
    fulfilled: function() {
      // Rendering is done inside the define function via scheduleCellRender
      var el = document.getElementById(cellId);
      if (el) el.classList.remove('cell-pending', 'running');
    },
    rejected: function(err) {
      var el = document.getElementById(cellId);
      if (el) { el.classList.remove('cell-pending', 'running'); el.classList.add('cell-error'); }
      var out = document.getElementById(cellId + '-output');
      if (out) {
        var msg = (err && err.message) ? err.message : String(err);
        // Check if it's a dependency error (upstream rejected)
        if (msg.indexOf('RuntimeError') !== -1 || err instanceof Error) {
          out.innerHTML = '<div class="dep-warning cycle">' + t('dependencyError') + ': ' + esc(msg) + '</div>';
        } else {
          out.innerHTML = '<span class="err">' + t('errorPrefix') + ' ' + esc(msg) + '</span>';
        }
      }
    }
  };
}

/** Register a cell in the Observable module */
function registerCell(cellId, expr) {
  if (!observableModule || !expr || !expr.trim()) return null;
  var cell = document.getElementById(cellId);
  if (!cell) return null;

  var deps = extractCellDependencies(expr);
  var definedName = deps.defines.length > 0 ? deps.defines[0] : null;

  // Update DOM data attributes
  cell.dataset.defines = deps.defines.join(',');
  cell.dataset.references = deps.references.join(',');

  // Check for duplicate variable definitions
  deps.defines.forEach(function(varName) {
    var existingOwner = variableOwnerMap.get(varName);
    if (existingOwner && existingOwner !== cellId) {
      showDuplicateWarning(cellId, varName, existingOwner);
    }
    variableOwnerMap.set(varName, cellId);
  });

  // Reuse existing variable instance, or create a new one
  var prev = cellVariableMap.get(cellId);
  var variable;

  // If the defined name changed (e.g. cell was `a:=5` now `b:=10`),
  // we must delete the old variable and create a fresh one.
  var prevName = prev ? (prev.defines && prev.defines[0]) || null : null;
  var nameChanged = prev && prevName !== definedName;

  if (nameChanged && prev && prev.variable) {
    try { prev.variable.delete(); } catch(e) {}
    if (prev.defines) {
      prev.defines.forEach(function(v) {
        if (variableOwnerMap.get(v) === cellId) variableOwnerMap.delete(v);
      });
    }
    deps.defines.forEach(function(v) { variableOwnerMap.set(v, cellId); });
    variable = null; // force creation below
  } else if (prev && prev.variable) {
    variable = prev.variable; // reuse â€” just redefine
  }

  // Observable variables are LAZY â€” they only evaluate when observed.
  // We must pass an observer so the runtime actually calls our define function.
  if (!variable) {
    variable = observableModule.variable(makeCellObserver(cellId));
  }

  // Build the definition function that evaluates the expression
  var evalCellId = cellId;
  var evalExpr = expr;
  var evalDefinedName = definedName;

  // Only depend on references that are actually defined by another cell.
  // Symbolic variables (x, y, tâ€¦) that no cell defines are NOT Observable inputs.
  var activeInputs = deps.references.filter(function(name) {
    return variableOwnerMap.has(name);
  });

  if (definedName) {
    variable.define(definedName, activeInputs, function() {
      var result = caseval(evalExpr);
      scheduleCellRender(evalCellId, evalExpr, result);
      // Return the assigned value for downstream cells
      try { return caseval(evalDefinedName); } catch(e) { return result; }
    });
  } else {
    // Anonymous cell â€” observes references but doesn't define a name
    variable.define(null, activeInputs, function() {
      var result = caseval(evalExpr);
      scheduleCellRender(evalCellId, evalExpr, result);
      return result;
    });
  }

  cellVariableMap.set(cellId, {
    variable: variable,
    defines: deps.defines,
    references: deps.references,
    expr: expr
  });

  // When a new variable name is defined, re-register any existing cells
  // that reference it but didn't list it as an Observable input (because
  // it wasn't defined yet when they were first registered).
  if (deps.defines.length > 0) {
    deps.defines.forEach(function(newVar) {
      cellVariableMap.forEach(function(info, otherCellId) {
        if (otherCellId === cellId) return;
        if (info.references && info.references.indexOf(newVar) !== -1) {
          // This cell references our new variable â€” check if it was wired
          var otherInputs = info.references.filter(function(n) { return variableOwnerMap.has(n); });
          // Re-register if the active inputs have changed
          var prevInputs = info._activeInputs || [];
          if (otherInputs.length !== prevInputs.length || otherInputs.some(function(n, i) { return n !== prevInputs[i]; })) {
            // Schedule re-registration (avoid recursion)
            setTimeout(function() { registerCell(otherCellId, info.expr); }, 0);
          }
        }
      });
    });
  }

  // Store active inputs for change detection
  cellVariableMap.get(cellId)._activeInputs = activeInputs;

  return variable;
}

/** Unregister a cell from the reactive graph */
function unregisterCell(cellId) {
  var info = cellVariableMap.get(cellId);
  if (!info) return;
  if (info.variable) {
    try { info.variable.delete(); } catch(e) {}
  }
  // Clean up variable ownership
  if (info.defines) {
    info.defines.forEach(function(v) {
      if (variableOwnerMap.get(v) === cellId) variableOwnerMap.delete(v);
    });
  }
  cellVariableMap.delete(cellId);
}

/** Update a cell's expression in the reactive graph */
function updateCell(cellId, newExpr) {
  // Re-register with new expression â€” reuses variable instance to keep
  // downstream wiring intact, triggering automatic cascade via .define()
  return registerCell(cellId, newExpr);
}

/** Render a cell's output after reactive evaluation */
function scheduleCellRender(cellId, expr, rawResult) {
  var cell = document.getElementById(cellId);
  if (!cell) return;
  var out = document.getElementById(cellId + '-output');
  if (!out) return;

  cell.classList.remove('cell-pending', 'cell-error');
  cell.classList.add('running');

  // Clean up previous output
  cleanupJSXGraphInElement(out);
  out.innerHTML = '';

  try {
    // Try direct JSXGraph rendering
    if (jsxGraphAvailable() && tryDirectJSXGraph(expr, out)) {
      // Done
    } else {
      var raw = rawResult;
      var plotFmt = detectPlotFormat(raw);

      if (plotFmt === 'svg') {
        renderSvgPlot(out, stripQuotes(raw));
      } else if (plotFmt === 'gr2d') {
        var jsxDone = false;
        if (jsxGraphAvailable()) {
          try {
            var plotData = parseGr2dLogoData(raw);
            if (plotData && plotData.curves.length > 0) {
              renderJSXGraphPlot(out, plotData);
              jsxDone = true;
            }
          } catch(e) {}
        }
        if (!jsxDone) renderGr2dPlot(out, raw);
      } else if (plotFmt === 'gl3d') {
        var sceneId = raw.substr(5).trim();
        renderGl3dPlot(out, sceneId);
      } else {
        // Text/LaTeX path
        var latex = '';
        try { latex = caseval('latex(' + expr + ')').replace(/^"|"$/g, ''); } catch(e) {}
        if (latex && typeof katex !== 'undefined') {
          var d = document.createElement('div');
          try {
            katex.render(latex, d, { displayMode: true, throwOnError: false, trust: true });
            out.appendChild(d);
          } catch(e) { out.innerHTML = '<div class="raw-res">' + esc(raw) + '</div>'; }
        } else {
          out.innerHTML = '<div class="raw-res">' + esc(raw) + '</div>';
        }
        if (plotFmt === 'text') {
          var r = document.createElement('div');
          r.className = 'raw-res'; r.textContent = 'â†’ ' + raw;
          out.appendChild(r);
        }
      }
    }
  } catch(err) {
    out.innerHTML = '<span class="err">' + t('errorPrefix') + ' ' + esc(String(err)) + '</span>';
    cell.classList.add('cell-error');
  }
  cell.classList.remove('running');
}

/** Show a duplicate variable warning */
function showDuplicateWarning(cellId, varName, existingCellId) {
  var cell = document.getElementById(cellId);
  if (!cell) return;
  var out = document.getElementById(cellId + '-output');
  if (!out) return;
  var warn = document.createElement('div');
  warn.className = 'dep-warning duplicate';
  warn.textContent = t('duplicateVariable') + ': ' + varName + ' (' + existingCellId + ')';
  out.prepend(warn);
}

/** Get upstream cell IDs (transitive) */
function getUpstreamCells(cellId) {
  var result = [];
  var visited = new Set();
  function traverse(id) {
    if (visited.has(id)) return;
    visited.add(id);
    var info = cellVariableMap.get(id);
    if (!info || !info.references) return;
    info.references.forEach(function(varName) {
      var owner = variableOwnerMap.get(varName);
      if (owner && owner !== cellId && result.indexOf(owner) === -1) {
        result.push(owner);
        traverse(owner);
      }
    });
  }
  traverse(cellId);
  return result;
}

/** Get downstream cell IDs (transitive) */
function getDownstreamCells(cellId) {
  var result = [];
  var visited = new Set();
  var info = cellVariableMap.get(cellId);
  if (!info || !info.defines) return result;

  function traverse(defines) {
    defines.forEach(function(varName) {
      cellVariableMap.forEach(function(cellInfo, cid) {
        if (visited.has(cid) || cid === cellId) return;
        if (cellInfo.references && cellInfo.references.indexOf(varName) !== -1) {
          visited.add(cid);
          result.push(cid);
          if (cellInfo.defines) traverse(cellInfo.defines);
        }
      });
    });
  }
  traverse(info.defines);
  return result;
}

/** Highlight dependency cells on focus */
function highlightDeps(cellId) {
  clearDepHighlights();
  getUpstreamCells(cellId).forEach(function(id) {
    var el = document.getElementById(id);
    if (el) el.classList.add('dep-upstream');
  });
  getDownstreamCells(cellId).forEach(function(id) {
    var el = document.getElementById(id);
    if (el) el.classList.add('dep-downstream');
  });
}

/** Clear all dependency highlights */
function clearDepHighlights() {
  document.querySelectorAll('.dep-upstream').forEach(function(el) { el.classList.remove('dep-upstream'); });
  document.querySelectorAll('.dep-downstream').forEach(function(el) { el.classList.remove('dep-downstream'); });
}

/** Mark downstream cells as pending before cascade */
function markDownstreamPending(cellId) {
  getDownstreamCells(cellId).forEach(function(id) {
    var el = document.getElementById(id);
    if (el) {
      el.classList.add('cell-pending');
      var out = document.getElementById(id + '-output');
      if (out) out.innerHTML = '<span class="spinner"></span> ' + t('pendingEvaluation');
    }
  });
}

/** Toggle reactive mode */
function toggleReactiveMode(enabled) {
  reactiveMode = enabled;
  var toggle = document.getElementById('reactive-toggle');
  if (toggle) toggle.checked = enabled;

  // Remove any existing reactive banner
  var oldBanner = document.getElementById('reactive-banner');
  if (oldBanner) oldBanner.remove();

  if (enabled) {
    // Show consent banner â€” do NOT auto-register/evaluate cells
    var notebook = document.getElementById('notebook');
    var banner = document.createElement('div');
    banner.id = 'reactive-banner';
    banner.className = 'stale-banner';
    banner.innerHTML = '<span>' + t('reactiveReady') + '</span>' +
      '<button onclick="runAllReactive()">' + t('runAllReactive') + '</button>' +
      '<button onclick="toggleReactiveMode(false)">' + t('cancelCascade') + '</button>';
    notebook.parentNode.insertBefore(banner, notebook);
  } else {
    // Switching to manual mode â€” dispose Observable runtime state
    if (observableModule) {
      cellVariableMap.forEach(function(entry) {
        try { entry.variable.delete(); } catch(e) {}
      });
      cellVariableMap.clear();
      variableOwnerMap.clear();
    }
    if (observableRuntime) {
      try { observableRuntime.dispose(); } catch(e) {}
      observableRuntime = null;
      observableModule = null;
    }
  }
}

/** Run all cells in reactive mode â€” builds the DAG and evaluates */
function runAllReactive() {
  // Remove the consent banner
  var banner = document.getElementById('reactive-banner');
  if (banner) banner.remove();

  // Initialize Observable runtime if needed
  window._observableReady.then(function() {
    if (!observableAvailable()) {
      reactiveMode = false;
      var tog = document.getElementById('reactive-toggle');
      if (tog) tog.checked = false;
      // Fall back to sequential run
      cells.forEach(function(c) { runSingleCell(c.id); });
      return;
    }
    if (!observableModule) {
      try {
        observableRuntime = new window._ObservableRuntime();
        observableModule = observableRuntime.module();
      } catch(e) {
        reactiveMode = false;
        var tog = document.getElementById('reactive-toggle');
        if (tog) tog.checked = false;
        cells.forEach(function(c) { runSingleCell(c.id); });
        return;
      }
    }
    // Register all cells in the DAG â€” Observable will evaluate them
    cells.forEach(function(c) {
      if (c.type !== 'text') {
        var expr = getXcasExpr(c.id);
        if (expr) registerCell(c.id, expr);
      }
    });
  });
}

</script>
</body>
</html>
