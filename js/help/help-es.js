'use strict';
// Auto-generated from giac aide_cas — do not edit manually
// Generated: 2026-03-01
// Language: Spanish (es)
// Commands: 1731 | Aliases: 481 | Descriptions: 1265 (73.1%)
// Source: https://raw.githubusercontent.com/s-celles/giac/main/doc/aide_cas

var GIAC_HELP = {
  cmds: {
    '!':{d:'Devuelve el inverso lógico del argumento o n!=factorial(n).',p:'Boolean'},
    '!=':{d:'Operador infijo booleano que comprueba una no igualdad.',p:'Expr,Expr'},
    '#':{d:'Transforma (en un programa Xcas) una cadena en el nombre de una variable.',p:'Str'},
    '$':{d:'Versión infijo de seq.',p:'(Expr(Var)||Int(a..b)),(Var(Var)=Int(a..b))||Intg(n)||Real(p)'},
    '%/':{d:'Resto euclídeo de 2 enteros : es la versión infija de irem.',p:'Intg(a),Intg(b)'},
    '&*':{d:'Producto de matrices (operador infijo, &* compatibilidad Maple).',p:'Mtrx,Mtrx'},
    '&^':{d:'Calcula la potencia n-ésima de la matriz (operador infijo,&^ compatibilidad Maple).',p:'Mtrx,Intg(n)'},
    '\'':{d:'Devuelve la derivada con respecto al segundo argumento (versión postfija de diff).',p:'Strng(str)'},
    '()':{d:''},
    '*':{d:'Producto escalar infijo (o producto de 2 expressiones o 2 matrices).',p:'Vect,Vect||Mtrx,Mtrx,||Xpr,Xpr'},
    '*=':{d:'Operador infijo : a*=b equivalente a a:=a*b.',p:'Var,Real'},
    '+':{d:'Concatenación de 2 cadenas o suma componente por componente de 2 expresiónes o 2 listas o 2 matrices o 2 puntos (operador infijo).',p:'Str||Lst||Expr||Pnt, Str||Lst||Expr||Pnt'},
    '+&':{d:'Concatenación de 2 cadenas o suma componente por componente de 2 expresiónes o 2 listas o 2 matrices (operador infijo, compatibilidad TI).',p:'Str||Lst, Str||Lst, Expr||Expr'},
    '+=':{d:'Operador infijo : a+=b equivalente a a:=a+b.',p:'Var,(Real or Str)'},
    '+infinity':{d:'Mas infinito',a:['inf']},
    '-':{d:'resta componente por componente de 2 expresiónes o 2 listas o 2 matrices o 2 puntos (operador infijo).',p:'Lst||Expr||Pnt,Lst||Expr||Pnt'},
    '-<':{d:'Operador infijo (equivalente a la instrucción prefija color) que define los atributos de una figura geométrica.',p:'GeoObj,Attribut'},
    '-=':{d:'Operador infijo : a-=b equivalente a a:=a-b.',p:'Var,Real'},
    '->':{d:'Operador infijo que define una función definida por el usuario: x->f(x).',p:'VectVar(x),Expr(f(x))'},
    '-infinity':{d:'Menos infinito'},
    '.*':{d:'Ejecuta el producto componente por componente de 2 listas o 2 matrices con el mismo dimensión(operador infijo, compatibilidad TI).',p:'Lst||Mtrx,Lst||Mtrx'},
    '.+':{d:'Ejecuta la suma componente por componente de 2 listas o 2 matrices (operador infijo, compatibilidad TI).',p:'Lst||Mtrx, Real(a)||Lst||Mtrx'},
    '.-':{d:'Ejecuta la resta componente por componente de 2 listas o 2 matrices (operador infijo, compatibilidad TI).',p:'Lst||Mtrx,Real(a)||Lst||Mtrx'},
    './':{d:'Ejecuta la división componente por componente de 2 listas o 2 matrices (operador infijo, compatibilidad TI).',p:'Lst||Mtrx,Lst||Mtrx'},
    '.^':{d:'Calcula la potencia de cada elemento de la matriz (operador infijo, compatibilidad TI).',p:'Mtrx,Intg(n)'},
    '/%':{d:'Cociente euclídeo de 2 enteros : es la versión infija de iquo.'},
    '/=':{d:'Operador infijo : a/=b equivalente a a:=a/b.',p:'Var,Real'},
    ':=':{d:'Operador infijo que guarda el segundo argumento en la variable dada como primer argumento.',p:'Var,(Real or Str)'},
    '<':{d:'Operador infijo booleano que comprueba una desigualdad.',p:'Expr,Expr'},
    '<=':{d:'Operador infijo booleano que comprueba una desigualdad.',p:'Expr,Expr'},
    '=':{d:'Símbolo infijo para vincular los dos miembros de una ecuación.',p:'Expr,Expr'},
    '=<':{d:'Operador infijo que guarda por referencia el segundo argumento en la variable (conteniendo una lista) dada como primer argumento.',p:'Var,(Real or Str)'},
    '==':{d:'Operador infijo booleano que comprueba una igualdad.',p:'Expr,Expr'},
    '=>':{d:'Operador infijo que guarda el primer argumento en la variable dada como segundo argumento o es la versión infija de convert.',p:'(Real or Str),Var'},
    '>':{d:'Operador infijo booleano que comprueba una desigualdad.',p:'Expr,Expr'},
    '>=':{d:'Operador infijo booleano que comprueba una desigualdad.',p:'Expr,Expr'},
    '?':{d:'? es la versión infija de when :(Cond) ? Expr1:Expr2. Si condiciónCond=1 (aún simbólica) devuelve Expr1 sino devuelve Expr2.',p:'Cond,Expr1,Expr2'},
    '@':{d:'Es el operador infijo de la composición de funciones.',p:'Fnc,Fnc'},
    '@@':{d:'f @@ n designa la función: fof...of (n veces) (operador infijo).',p:'Fnc(f),Intg(n)'},
    'Airy_Ai':{d:'Devuelve el valor de la función Ai de la función Airy solución de w\'\'-wx=0. Ai(x)=Ai(0)f(z)+Ai\'(0)g(z)(f y g son series de Taylor soluciones de w\'\'-xw=0).',p:'Real'},
    'Airy_Bi':{d:'Devuelve el valor de la función Bi de Airy solución de w\'\'-wx=0. Bi(x)=sqrt(3)(Bi(0)f(z)-Bi\'(0)g(z)))(f y g son series de Taylor solución de w\'\'-xw=0).',p:'Real'},
    'Archive':{d:'Proteje las variables dadas como argumento en un archivo.',p:'SeqVar'},
    'BesselJ':{d:'',p:'Int(p),Real(x)'},
    'BesselY':{d:'',p:'Int(p),Real(x)'},
    'Beta':{d:'Beta(a,b)=int(t^(a-1)*(1-t)^(b-1),t=0..1), Beta(a,b,p)=int(t^(a-1)*(1-t)^(b-1),t=0..p), Beta(a,b,p,1)=Beta(a,b,p)/Beta(a,b).(Beta(x,y) devuelve Gamma(x)*Gamma(y)/Gamma(x+y)).',p:'Expr,Expr,[Expr],[1]'},
    'BlockDiagonal':{d:'Devuelve o bien la matrix diagonal con diagonal l, o bien la diagonal de A.',p:'Lst(l)||Mtrx(A)'},
    'COND':{d:'',p:'Mtrx,[2]||[inf]',a:['cond']},
    'CST':{d:'Nombre de la variable para crear menú personalizado.',p:'Lst'},
    'Celsius2Fahrenheit':{d:'Convierte Celsius->Fahrenheit',p:'Unit'},
    'Ci':{d:'Coseno integral int(cos(t)/t,t=-inf..x)',p:'Expr'},
    'Circle':{d:'Traza una circunferencia con centro (xc, yc) y radio r (por defecto opción=1 y opción=0 son para borrar este círculo).',p:'Real(xc),Real(yc),Real(r),[Intg(option)]'},
    'ClrGraph':{d:'Borra los gráficos y los objetos geométricos en la pantalla gráfica DispG.',p:'NULL',a:['ClrDraw']},
    'ClrIO':{d:'Borra la pantalla de salidas.',p:'NULL'},
    'Col':{d:'Devuelve el índice de la columna de la celda señalada en el editor de matrices.',p:'NULL'},
    'CopyVar':{d:'Copia sin evaluar el contenido de var1 en var2.',p:'Var(var1),Var(var2)'},
    'CyclePic':{d:'Realiza una secuencia automática de n imágenes (guardados con StoPic por ejemplo con nombres des1,des2,des3..desn). La visualización se hace n veces con una pausa de p segundos entre cada gráfico.',p:'Str(),Intg(n),Real(p),Intg(n)'},
    'DOM_COMPLEX':{d:'DOM_COMPLEX o complex representa el tipo de un complejo ou de una variable compleja, valor del comando type o es una opción del comando assume.',p:'Opt',a:['complex']},
    'DOM_FLOAT':{d:'DOM_FLOAT o float es un entero que representa el tipo de una variable flotante, valor del comando type o es una opción del comando assume.',p:'Opt',a:['float','double']},
    'DOM_FUNC':{d:'DOM_FUNC o func representa el tipo de una función, valor del comando type o es una opción del comando assume.',p:'Opt',a:['func']},
    'DOM_IDENT':{d:'DOM_IDENT o identifier representa el tipo de un identificador, valor del comando type o es una opción del comando assume.',p:'Opt',a:['identifier']},
    'DOM_INT':{d:'DOM_INT o integer o DOM_int es un entero que representa el tipo de una variable entera, valor del comando type. DOM_INT está utilizado si el entero es < 2^31 o es una opción del comando assume.',p:'Opt',a:['integer','DOM_int']},
    'DOM_LIST':{d:'DOM_LIST o vector representa el tipo de una lista o de una secuencia, valor del comando type o es una opción del comando assume.',p:'Opt',a:['vector']},
    'DOM_RAT':{d:'DOM_RAT o rational reprasenta el tipo de un racional, valor del comando type o es una opción del comando assume.',p:'Opt',a:['rational']},
    'DOM_STRING':{d:'DOM_STRING o string representa el tipo de una cadena de caracteres, valor del comando type o es una opción del comando assume.',p:'Opt',a:['string']},
    'DOM_SYMBOLIC':{d:'DOM_SYMBOLIC o symbol representa el tipo de una variable simbólica, valor del comando type o es una opción del comando assume.',p:'Opt',a:['symbol','expression']},
    'DelFold':{d:'Borra el directorio señalado (hay un error si dicho directorio no está vacio).',p:'Var'},
    'Det':{d:'Determinante de una matriz cuadrada M, sin evaluarla.',p:'Mtrx'},
    'Dialog':{d:'En un programa, crea entradas: Dialog{Title("título");Text("Alumno"+string(c));Request("Nombre=",a);Request("Edad=",b);DropDown("Nivel",["un","dos"],n);} (se puede reemplazar {} con EndDlog al final).',p:'Title;Text;Request;Request;DropDown;EndDlog',a:['EndDlog']},
    'Digits':{d:'Nombre que permite modificar el número de dígitos significantes (Digits:=n).',p:':=Intg(n)',a:['DIGITS']},
    'Dirac':{d:'Función derivada de Heaviside.',p:'Real'},
    'DispG':{d:'Abre la ventana DispG (DispG sin ()).'},
    'DispHome':{d:'Cierra la ventana DispG.'},
    'DrawInv':{d:'Traaza el gráfico del simétrico de la expresión con respecto a y=x.',p:'Expr,[Var]'},
    'DrawSlp':{d:'Traza la recta con pendiente m que pasa por (a,b): y-b=m*(x-a).',p:'Real(a),Real(b),Real(m)'},
    'DropDown':{d:'En un programa, instrucción para una caja de diálogo.',p:'Str,LstVal,Var'},
    'Ei':{d:'Integral exponencial int(exp(t)/t,t=-inf..x)',p:'Expr'},
    'Factor':{d:'Factoriza un polinomio, sin evaluar.',p:'Expr'},
    'Fahrenheit2Celsius':{d:'Convierte Fahrenheit->Celsius',p:'Unit'},
    'Fill':{d:'Rellena la lista o matriz guardada en A con Xpr.',p:'Expr(Xpr),Var(A)'},
    'Fourier':{d:'',p:'Expr(f),Var(t),Var(omega)'},
    'GF':{d:'Crea un campo de Galois de característica p con p^n elementos.',p:'Intg(p), Intg(n)|Minpoly,[Variable],[0|undef|Poly]'},
    'Gamma':{d:'Calcula los valores de la función Gamma en el punto a (Gamma(n+1)=n! para n entero) si a>0, Gamma(a)=int(e^{-t}*t^{a-1},t=0..inf)) y Gamma(a)=Gamma(a+1)/a y Gamma(a,b)=ugamma(a,b).',p:'Real(a),[Real(b)]'},
    'Gcd':{d:'Devuelve el máximo común divisor de 2 polinomios o de 2 enteros sin evaluar',p:'(Intg or Poly),(Intg or Poly)'},
    'GetFold':{d:'Devuelve el nombre del directorio actual.',p:'Var'},
    'Heaviside':{d:'Función igual a 0 si x<0 y 1 si x>=0.',p:'Real'},
    'Heaviside2sign':{d:'',p:'Expr'},
    'Hilbert':{d:'',p:'Expr(f),Var(x)'},
    'InputStr':{d:'Instrucción en un programa que permite introducir una cadena de caracteres y guardarla en var.',p:'[Str],Var(Var)',a:['textinput','lis_phrase']},
    'Int':{d:'Devuelve la primitiva o la integral (entre a y b) sin evaluar.',p:'Expr,[Var(x)],[Real(a)],[Real(b)]'},
    'Inverse':{d:'Devuelve la inversa de una matriz o de una expresión sin evaluarla.',p:'Expr||Mtrx'},
    'JordanBlock':{d:'Devuelve una matriz n*n con a en la diagonal, 1 en la parte triangular superior y 0 en el resto.',p:'Expr(a),Intg(n)'},
    'LQ':{d:'Para una matriz numércia A, devuelve L una matriz triangular inferior, Q una ortogonal y P una matriz de permutación tal que P*A=L*Q.',p:'Mtrx(A)'},
    'LSQ':{d:'',p:'Mtrx(A),(Mtrx || Vect)(B)',a:['lsq']},
    'LU':{d:'Para una matriz numércia A, guarda en L una matriz triangular inferior, en U una triangular superior y en P una matriz de permutación tal que P*A=L*U.',p:'Mtrx(A),Var(L),Var(U),Var(P)'},
    'LambertW':{d:'',p:'Real(x),[Intg(n)]'},
    'Li':{d:'Integral logarithmica Li(x)=Ei(ln(x)) primitiva de 1/ln(x)',p:'Expr'},
    'Line':{d:'Traza el segmento [a+i*b,c+i*d].',p:'Expr(a),Expr(b),Expr(c),Expr(d)'},
    'LineHorz':{d:'Traza la recta horizontal y=a.',p:'Expr(a)'},
    'LineTan':{d:'Traza la tangente de y=f(x) en x=a.',p:'Expr(f(x)),[Var],Expr(a)'},
    'LineVert':{d:'Traza la recta vertical x=a.',p:'Expr(a)'},
    'MSE':{d:'',p:'Opt',a:['cross_entropy','log_loss','ReLU','learning_rate','weight_decay','block_size','adaptive','momentum','topology']},
    'NewFold':{d:'Crea un nuevo directorio y se situa en dicho directorio.',p:'Var'},
    'NewPic':{d:'Crea una imagen llamada pic1, compuesta por los puntos definidos por las filas de A.',p:'Mtrx_nrows_2cols(A),Var(pic1)'},
    'Nullspace':{d:'Forma inerta de nullspace para cálculos modulares (irem/mod)',p:'Mtrx'},
    'Ox_2d_unit_vector':{d:'Ox_2d_unit_vector()',p:'NULL'},
    'Ox_3d_unit_vector':{d:'Ox_3d_unit_vector()',p:'NULL'},
    'Oy_2d_unit_vector':{d:'Oy_2d_unit_vector()',p:'NULL'},
    'Oy_3d_unit_vector':{d:'Oy_3d_unit_vector()',p:'NULL'},
    'Oz_3d_unit_vector':{d:'Oz_3d_unit_vector()',p:'NULL'},
    'Pause':{d:'Pause; en un programa que detiene su ejecución (la ejecución continua si se presiona ENTER) [Pause n; detiene su ejecución durante n segundos].',a:['sleep']},
    'Psi':{d:'Psi(a,n)=n-ésima derivada de la función DiGamma (=ln@Gamma) en el punto a (Psi(a,0)=Psi(a)).',p:'Real(a),Intg(n)'},
    'QR':{d:'Para una matriz numérica, guarda en Q una matriz ortogonal y en R una matriz triangular superior, tal que A=Q*R [cambiando por 0 los elementos el tales que abs(el)<eps].',p:'Mtrx,Var(Q),Var(R),[Real(eps)]'},
    'Quo':{d:'Cociente euclidiano de 2 polinomios sin evaluar.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'REDIM':{d:'',p:'Mtrx||Vect,Intg(n1),Intg(n2)',a:['redim']},
    'REPLACE':{d:'',p:'Mtrx(A),Lst(n1,n2),Mtrx(B)',a:['replace']},
    'RandSeed':{d:'Reinicia números aleatorios.',p:'Intg'},
    'RclPic':{d:'Añade a la pantalla gráfica DispG, la imagen guardada con StoPic.',p:'Var(pic1)'},
    'Rem':{d:'Resto euclidiano de 2 polinomios sin evaluar.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'Request':{d:'En un programa, instrucción para una caja de diálogo.',p:'Str,Var'},
    'Resultant':{d:'Forma inerta de resultante para cálculos modulares (irem/mod)',p:'Poly,Poly,Var'},
    'Row':{d:'Devuelve el índice de la fila de la celda señalada en el editor de matrices.',p:'NULL'},
    'RplcPic':{d:'Borra y reemplaza el gráfico en la pantalla gráfica DispG, con el dibujo guardado con StoPic.',p:'Var(pic1)'},
    'Rref':{d:'Devuelve la reducción en forma escalonada de AX=b (M=A|b) sin evaluar.',p:'Mtrx(M)'},
    'SCHUR':{d:'Reducción matricial bajo forma de Hessenberg : SCHUR(A)=hessenberg(A,-1).',p:'Mtrx(A)',a:['schur']},
    'SVD':{d:'Para una matriz real numércia A, devuelve L una matriz ortogonal, S un vector de Singular Value y U una matriz ortogonal tal que A=U*diag(S)*trn(Q).',p:'Mtrx(A)'},
    'SVL':{d:'Devuelve un vector de Singular Value i.e. sqrt(eigenvals(A*trn(A)))',p:'Mtrx(A)'},
    'SetFold':{d:'Devuelve el nombre del directorio actual y escoge el nombre señalado como nuevo directorio (main para el directorio raiz).',p:'Var'},
    'Si':{d:'Seno integral int(sin(t)/t,t=0..x)',p:'Expr'},
    'SortA':{d:'Ordena las listas en orden creciente (like TI).',p:'LstReal||Seq||Mtrx'},
    'SortD':{d:'Ordena las listas en orden decreciente (like TI).',p:'LstReal||Seq||Mtrx'},
    'StoPic':{d:'Para guardar gráficos en variables con el mismo nombre raíz (radical1,radical2..) y poder animarlos con CyclePic.',p:'Var'},
    'Text':{d:'En un programa, instrucción de una caja de diálogo.',p:'Str'},
    'Title':{d:'En un programa, instrucción de una caja de diálogo.',p:'Str'},
    'UTPC':{d:'Devuelve la probabilidad que una variable aleatoria según ley Chi-cuadrado sea mayor que x0 (n es el número de grados de libertad).',p:'Intg(n),Real(x0)'},
    'UTPF':{d:'Devuelve la probabilidad que una variable aleatoria según ley de Fisher-Snedecor sea mayor que x0 (n y d son los grados de libertad).'},
    'UTPN':{d:'Devuelve la probabilidad que una variable aleatoria Normal sea mayor que x0 (mu es el promedio y v la varianza).',p:'Real(mu),Real(v),Real(x0)'},
    'UTPT':{d:'Devuelve la probabilidad que una variable aleatoria según ley de Student sea mayor que x0 (n es el número de grados de libertad).',p:'Intg(n),Real(x0)'},
    'Unarchiv':{d:'Desprotege las variables dadas como argumento.',p:'SeqVar'},
    'VARS':{d:'Lista de las variables y de los repertorios del repertorio actual.',p:'NULL'},
    'VAS':{d:'Devuelve la lista de intervalos donde están las raíces reales de P, con el algoritmo Vincent-Akritas-Strzebonski.',p:'Poly(P)'},
    'VAS_positive':{d:'Devuelve la lista de intervalos donde están las raíces reales positivas de P, con el algoritmo Vincent-Akritas-Strzebonski.',p:'Poly(P)'},
    'WAIT':{d:'WAIT(n); en un programa que detiene su ejecución durante n segundos.',p:'Var(n)'},
    'Zeta':{d:'Devuelve si a>1 sum(1/n^a,n,1,+infinito).',p:'Real(a)'},
    '^':{d:'Calcula la potencia n-ésima de un número (operador infijo).',p:'Expr(a),Intg(n)'},
    '_(cm/s)':{d:'centimetro por segundo.'},
    '_(ft*lb)':{d:'foot por pound (pie por libra).'},
    '_(ft/s)':{d:'foot por segundo (pie por segundo).'},
    '_(m/s)':{d:'metro por segundo.'},
    '_(m/s^2)':{d:'metro por segundo cuadrado.'},
    '_(rad/s)':{d:'radián por segundo.'},
    '_(rad/s^2)':{d:'radián por segundo cuadrado.'},
    '_(tr/min)':{d:'Revoluciones por minuto.'},
    '_(tr/s)':{d:'Revoluciones por segundo.'},
    '_A':{d:'amperio'},
    '_Angstrom':{d:'Angstrom'},
    '_Bq':{d:'becquerel'},
    '_Btu':{d:'Btu British thermal unit (unidad termal británica)'},
    '_Ci':{d:'Curie'},
    '_F':{d:'Farad'},
    '_F_':{d:'Constante de Faraday'},
    '_Fdy':{d:'Faraday'},
    '_G_':{d:'Constante gravitacional'},
    '_Gal':{d:'Gal=0.01_(m/s^2).'},
    '_Gy':{d:'Gray'},
    '_H':{d:'Henry'},
    '_Hz':{d:'Hertz'},
    '_J':{d:'Joule (julio, unidad)'},
    '_K':{d:'Kelvin'},
    '_Kcal':{d:'kilocaloría.'},
    '_MHz':{d:'megahercio.'},
    '_MW':{d:'megavatio.'},
    '_MeV':{d:'megaelectronvoltio.'},
    '_N':{d:'Newton'},
    '_NA_':{d:'Número de Avogrado.'},
    '_Ohm':{d:'Ohm'},
    '_P':{d:'Poise (unidad de viscosidad)'},
    '_PSun_':{d:''},
    '_Pa':{d:'Pascal'},
    '_R':{d:'Roentgen (1_R=0.258_(mC/kg))'},
    '_REarth_':{d:''},
    '_RSun_':{d:''},
    '_R_':{d:'Constante universal de los gases.'},
    '_Rankine':{d:'grado Rankine.'},
    '_Rinfinity_':{d:'Constante de Rydberg'},
    '_S':{d:'Siemens'},
    '_St':{d:'Stokes'},
    '_StdP_':{d:'Presión estándar.'},
    '_StdT_':{d:'Temperatura estándar.'},
    '_Sv':{d:'Sievert'},
    '_T':{d:'Tesla'},
    '_V':{d:'Voltio'},
    '_Vm_':{d:'Volumen molar.'},
    '_W':{d:'Vatio'},
    '_Wb':{d:'Weber'},
    '_Wh':{d:'vatio-hora.'},
    '_a':{d:'área (100 m^2)'},
    '_a0_':{d:'Radio de Bohr'},
    '_acre':{d:'acre'},
    '_alpha_':{d:'Constante de estructura fina'},
    '_arcmin':{d:'minuto de arco'},
    '_arcs':{d:'Segundo de arco'},
    '_atm':{d:'atmósfera'},
    '_au':{d:'Unidad astronómica'},
    '_b':{d:'Barn'},
    '_bar':{d:'Bar'},
    '_bbl':{d:'Barilio'},
    '_bblep':{d:'barril equivalente de petróleo.'},
    '_bu':{d:'Bushel (Celemín británico 1_bu=8_galUK)'},
    '_buUS':{d:'bushel (Celemín estadounidense)'},
    '_c3_':{d:'Constante de la ley de repartición de Wien'},
    '_c_':{d:'Velocidad de la luz en el vacío.'},
    '_cal':{d:'Caloría'},
    '_cd':{d:'Candela'},
    '_chain':{d:'Chain (1 chain = 66 pies o 22 yardas)'},
    '_cm':{d:'centímetro.'},
    '_cm^2':{d:'centímetro cuadrado.'},
    '_cm^3':{d:'centímetro cúbico.'},
    '_ct':{d:'Carat'},
    '_cu':{d:'copa de EEUU'},
    '_d':{d:'Día'},
    '_dB':{d:'Decibel'},
    '_deg':{d:'grado (ángulo).'},
    '_degreeF':{d:'grado Fahrenheit.'},
    '_dyn':{d:'Dyne'},
    '_eV':{d:'Electronvoltio'},
    '_epsilon0_':{d:'Permitividad del vacío'},
    '_epsilon0q_':{d:'epsilon0/q (permitivida/carga del electrón)'},
    '_epsilonox_':{d:'Constante dieléctrica del óxido de silicio'},
    '_epsilonsi_':{d:'Constante dieléctrica del silicio'},
    '_erg':{d:'Erg'},
    '_f0_':{d:'Frecuencia de fotón (e/h)'},
    '_fath':{d:'Fathom (braza)'},
    '_fbm':{d:'Board foot (pie tabla)'},
    '_fc':{d:'Footcandle (1 footcandle ≈ 10.764 lux)'},
    '_fermi':{d:'Fermi'},
    '_flam':{d:'Footlambert'},
    '_fm':{d:'Fathom (braza)'},
    '_ft':{d:'foot (pie)'},
    '_ftUS':{d:'foot (pie EEUU)'},
    '_ft^2':{d:'foot cuadrado (pie cuadrado).'},
    '_ft^3':{d:'foot cúbico (pie cúbico).'},
    '_g':{d:'gramo'},
    '_g_':{d:'Aceleración de la gravedad'},
    '_ga':{d:'Standard freefall (caída libre estándar)'},
    '_galC':{d:'Galón canadiense'},
    '_galUK':{d:'Galón británico'},
    '_galUS':{d:'Galón EEUU'},
    '_gf':{d:'Gramo-fuerza (pondio)'},
    '_gmol':{d:''},
    '_gon':{d:'Grado'},
    '_grad':{d:'gramo-mol'},
    '_grain':{d:'Grain (unidad de masa ≈ 0,0648 gramos)'},
    '_h':{d:'Hora'},
    '_h_':{d:'Constante de Planck'},
    '_ha':{d:'Hectárea'},
    '_hbar_':{d:'Constante de Dirac'},
    '_hp':{d:'Horsepower (caballo de vapor)'},
    '_in':{d:'Inch (pulgada)'},
    '_inH20':{d:'Pulgadas de agua, 60 grados Fahrenheit'},
    '_inHg':{d:'Pulgadas de mercurio, 0 grados Celsius'},
    '_in^2':{d:'inch cuadrado (pulgada cuadrada).'},
    '_in^3':{d:'inch cúbico (plugada cúbica).'},
    '_j':{d:'Día'},
    '_kWh':{d:'kilovatio-hora.'},
    '_k_':{d:'Constante de Boltzmann.'},
    '_kg':{d:'Kilogramo'},
    '_kip':{d:'Kilopound-force (kilolibra-fuerza)'},
    '_km':{d:'kilómetro.'},
    '_km^2':{d:'kilómetro cuadrado.'},
    '_knot':{d:'milla náutica por hora'},
    '_kph':{d:'kilómetros por hora'},
    '_kq_':{d:'k/q (Boltzmann/carga del electrón)'},
    '_l':{d:'litro'},
    '_lam':{d:'Lambert'},
    '_lambda0_':{d:'Longitud de onda (ch/e)'},
    '_lambdac_':{d:'Longitud de onda del Compton'},
    '_lb':{d:'libra (1 libra = 16 oz)'},
    '_lbf':{d:'libra-fuerza'},
    '_lbmol':{d:'libra-mole'},
    '_lbt':{d:'Troya libra'},
    '_lep':{d:'litro equivalente de petróleo.'},
    '_liqpt':{d:'US liquid pint (1_galUS=8_liqpt)'},
    '_lm':{d:'Lumen'},
    '_lx':{d:'Lux'},
    '_lyr':{d:'año luz'},
    '_m':{d:'Metro (unidad)'},
    '_mEarth_':{d:''},
    '_m^2':{d:'metro cuadrado.'},
    '_m^3':{d:'metro cúbico.'},
    '_me_':{d:'Masa elemental del electrón'},
    '_mho':{d:'mho'},
    '_miUS':{d:'US statute mile'},
    '_miUS^2':{d:'milla estatuaria (EEUU) cuadrada.'},
    '_mi^2':{d:'milla cuadrada internacional.'},
    '_mil':{d:'mil'},
    '_mile':{d:'milla internacional'},
    '_mille':{d:'milla náutica'},
    '_ml':{d:'mililitro.'},
    '_mm':{d:'milímetro.'},
    '_mmHg':{d:'milímetro de mercurio (torr), 0 grado Celsius'},
    '_mn':{d:'minuto.'},
    '_mol':{d:'mole'},
    '_mp_':{d:'Masa elemental del protón'},
    '_mph':{d:'millas por hora'},
    '_mpme_':{d:'Cuociente mp/me (masa del protón/masa del electrón)'},
    '_mu0_':{d:'Permeabilidad del vacío'},
    '_muB_':{d:'Magnetón de Bohr'},
    '_muN_':{d:'Magnetón nuclear'},
    '_oz':{d:'onza'},
    '_ozUK':{d:'onza fluida británica'},
    '_ozfl':{d:'onza fluida EEUU'},
    '_ozt':{d:'onza de Troya'},
    '_pc':{d:'Parsec'},
    '_pdl':{d:'Poundal (unidad de fuerza)'},
    '_ph':{d:'Phot'},
    '_phi_':{d:'Quantum (cuanto) de flujo magnético'},
    '_pk':{d:'US peck'},
    '_psi':{d:'Libras por pulgadas cuadradas'},
    '_ptUK':{d:'pinta británica (1_galUK=8_ptUK)'},
    '_qe_':{d:'Carga del electrón'},
    '_qepsilon0_':{d:'q*epsilon0 (carga del electrón*permitividad)'},
    '_qme_':{d:'Cuociente q/me (carga/masa del electrón)'},
    '_qt':{d:'quarto (de galón)'},
    '_rad':{d:'radián'},
    '_rad_':{d:'1 radián'},
    '_rd':{d:'rad 1_rd=0.01_Gy'},
    '_rem':{d:'Rem'},
    '_rod':{d:'Rod 1_rod=5.029215842_m'},
    '_rpm':{d:'Revoluciones por minuto'},
    '_s':{d:'segundos'},
    '_sb':{d:'Stilb'},
    '_sd_':{d:''},
    '_sigma_':{d:'Constante de Stefan-Boltzmann.'},
    '_slug':{d:'Slug'},
    '_sr':{d:'Estereorradían'},
    '_st':{d:'Estéreo'},
    '_syr_':{d:''},
    '_t':{d:'Tonelada'},
    '_tbsp':{d:'tablespoon (cucharada)'},
    '_tec':{d:'tonelada de equivalente carbón.'},
    '_tep':{d:'Tonelada equivalente de petróleo.'},
    '_tex':{d:'tex=10^-6 _(kg/m).'},
    '_therm':{d:'EEC therm'},
    '_ton':{d:'short ton (1 tonelada corta = 2000 libras)'},
    '_tonUK':{d:'Long ton (UK)'},
    '_torr':{d:'Torr (mmHg)'},
    '_tr':{d:'tour=2*pi _rad.'},
    '_tsp':{d:'teaspoon (cucharada de té)'},
    '_u':{d:'Unidad de masa atómica'},
    '_yd':{d:'yarda internacional'},
    '_yd^2':{d:'yard cuadrado.'},
    '_yd^3':{d:'yard cúbico.'},
    '_yr':{d:'año'},
    '_µ':{d:'micrón'},
    'a2q':{d:'a2q(A,X)=la forma cuadrática q asociada a A, X=vector de variables.',p:'Mtrx,VectVar'},
    'abcuv':{d:'Devuelve [u,v] tales que au+bv=c para 3 polinomios a,b,c.',p:'Poly(a),Poly(b),Poly(c),[Var]'},
    'about':{d:'Devuelve las hipótesis hechas con assume en la variable a.',p:'Var(a)||Image||Audio'},
    'abs':{d:'Devuelve el valor absoluto o la norma del argumento.',p:'Cplx||LstCplx'},
    'abscissa':{d:'Devuelve la abscisa del punto o del vector.',p:'Pnt or Vect'},
    'accumulate_head_tail':{d:'Devuelve la lista obtenida a partir de l, donde los primeros p y los últimos q elementos son reemplazados por su suma.',p:'Lst(l),Intg(p),Intg(q)'},
    'acos':{d:'Arcocoseno',p:'Expr',a:['arccos']},
    'acos2asin':{d:'Reemplaza arccos(x) por pi/2-arcsin(x) en el argumento.',p:'Expr'},
    'acos2atan':{d:'Reemplaza arccos(x) por pi/2-arctan(x/sqrt(1-x^2)) en el argumento.',p:'Expr'},
    'acosh':{d:'Arcocoseno hiperbólico.',p:'Expr',a:['arccosh','ACOSH']},
    'acot':{d:'Arcocotangente.',p:'Expr',a:['ACOT']},
    'acsc':{d:'Arcocosecante: acsc(x)=asin(1/x).',p:'Expr',a:['ACSC']},
    'acyclic':{d:'',p:'Opt'},
    'add_arc':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'add_edge':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'add_vertex':{d:'',p:'Graph(G),Vrtx(v)||Lst(V)'},
    'additionally':{d:'Agrega una hipótesis a una variable.',p:'Expr'},
    'addtable':{d:'',p:'fourier||laplace,f(x),F(s),Var(x),Var(s)'},
    'adjacency_matrix':{d:'',p:'Graph(G)'},
    'adjoint_matrix':{d:'Devuelve el polinomio característico de A y la comatriz de A-xI.',p:'Mtrx'},
    'affix':{d:'Número complejo igual al afijo de un punto o de un vector.',p:'Pnt||Vect'},
    'algsubs':{d:'Sustituye una expresión algebraica Xpr1 por una expresión algebraica Xpr2 en una expresión Xpr.',p:'Equal(Xpr1=Xpr2),Expr(Xpr)'},
    'algvar':{d:'Lista de las variables ordenadas por extensión algebraica.',p:'Expr'},
    'all_trig_solutions':{d:'',p:':=Intg(0 or 1)'},
    'allpairs_distance':{d:'',p:'Graph(G)'},
    'alog10':{d:'Función x->10^x.',p:'Expr'},
    'altitude':{d:'altitude(A,B,C) traza la altura en A del triángulo ABC',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'and':{d:'operador booleano infijo (y).',p:'Expr, Expr',a:['&&','et']},
    'angle':{d:'angle(A,B,C) es el valor de la medida del ángulo (AB,AC).',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'angle_radian':{d:'Nombre que permite trabajar con radianes (angle_radian:=1) o grados (angle_radian:=0).',p:':=Intg(0 or 1)'},
    'angleat':{d:'angleat(A,B,C,z0) escribe en el punto point(z0) con una leyenda, el valor de la medida del ángulo (AB,AC).',p:'Pnt(A),Pnt(B),Pnt(C),(Pnt or Cplx(z0))'},
    'angleatraw':{d:'angleatraw(A,B,C,z0) escribe en el punto point(z0), el valor de la medida del ángulo (AB,AC).',p:'Pnt(A),Pnt(B),Pnt(C),(Pnt or Cplx(z0))'},
    'animate':{d:'Anima el gráfico de Xpr, dependiendo de x, parámetro t llamando plot.',p:'Expr(Xpr),x=xmin..xmax,t=tmin..tmax,frames=nframes'},
    'animate3d':{d:'Anima el gráfico de Xpr, dependiendo de [x,y], parámetro t llamando plotfunc.',p:'Expr(Xpr),[x=xmin..xmax,y=ymin..ymax],t=tmin..tmax,frames=nframes'},
    'animation':{d:'Dibuja en bucle cada objeto de una secuencia de objetos geométricos.',p:'Mtrx'},
    'ans':{d:'Devuelve la n+1-ésima respuesta del histórico de comandos si n>=0 o, la (-n)-ésima respuesta previa si n<0 (por defecto n=-1 para la respuesta anterior).',p:'Intg(n)'},
    'antiprism_graph':{d:'',p:'Intg(n)'},
    'append':{d:'Añade un elemento a una lista (conjunto o cadena)(L:=append(L,a) ou L.append(a)).',p:'(Lst||Set||Str(L),Elem)'},
    'apply':{d:'Aplica la función f a los elementos de la lista l (opción matrix para una matriz).',p:'Fnc(f),Lst(l)'},
    'approx_mode':{d:'Nombre que permite trabajar en modo aproximado (approx_mode:=1) o en modo exacto (approx_mode:=0).',p:':=Intg(0 or 1)'},
    'arc':{d:'Traza un arco de circunferencia dado por 2 vértices y el ángulo al centro [el centro va en C y el radio en r].',p:'Pnt, Pnt, Real,[Var(C)],[Var(r)],[Opt(segment)]'},
    'arcLen':{d:'Devuelve la longitud del arco de la curva definida por y=Xpr(o por x=Xpr1,y=Xpr2) cuando los valores de los parámetros están entre a y b.',p:'Expr(Xpr) or Lst([Xpr1,Xpr2]),Var,Real(a),Real(b)',a:['arclen']},
    'archive':{d:'Guarda el contenido de una variable o de una lista de variables dadas como argumento en el archivo especificado (legible con unarchive).',p:'Str(namefich),Seq(Var)'},
    'area':{d:'Área algebraica de una circunferencia, un arco de circunferencia o de un polígono estrella (por ejemplo triángulo, cuadrado,...) o el area bajo una curva, en opción el método de cuadratura.',p:'Polygone || Expr,x=a..b,[n],[Method]'},
    'areaat':{d:'Escribe en el punto point(z0), con una leyenda, el área algebraica de una circunferencia o de un polígono estrella (por ejemplo triángulo, cuadrado, ...)',p:'Polygone, Pnt||Cplx(z0)'},
    'areaatraw':{d:'Escribe en el punto point(z0), el área algebraica de una circunferencia o de un polígono estrella (por ejemplo triángulo, cuadrado, ...)',p:'Polygone, Pnt||Cplx(z0)'},
    'arg':{d:'Devuelve el argumento de un número complejo.',p:'Expr'},
    'args':{d:'Dentro de un programa args(NULL) es la lista constituida por la función y sus argumentos.',p:'NULL'},
    'array':{d:'Opción para convert.',p:'Opt'},
    'arrivals':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'articulation_points':{d:'',p:'Graph(G)'},
    'as_function_of':{d:'Devuelve un elemento definido como función de un elemento definido previamente.',p:'VarResult,VarArg'},
    'asc':{d:'Devuelve la lista de los códigos ASCII de una cadena.',p:'Str'},
    'asec':{d:'Arcosecante: asec(x)=acos(1/x).',p:'Expr',a:['ASEC']},
    'asin':{d:'Arcoseno.',p:'Expr',a:['arcsin','ASIN']},
    'asin2acos':{d:'Reemplaza arcsin(x) por pi/2-arccos(x) en el argumento.',p:'Expr'},
    'asin2atan':{d:'Reemplaza arcsin(x) por arctan(x/sqrt(1-x^2)) en el argumento.',p:'Expr'},
    'asinh':{d:'Arcoseno hiperbólico.',p:'Expr',a:['arcsinh','ASINH']},
    'assert':{d:'Instrucción en un programa, devuelve un error si b==false.',p:'Boolean(b)'},
    'assign':{d:'Guarda el segundo argumento (de la igualdad) en la variable dada como primer argumento (de la igualdad) (compatibilidad con Maple).',p:'(Var,value) or Equal or LstEq.'},
    'assign_edge_weights':{d:'',p:'Graph(G),Seq(m,n)||Intrv(a..b)'},
    'assume':{d:'Asigna una hipótesis a una variable.',p:'Expr'},
    'at':{d:'at(l,j) (ó at(m,[j,k])) es el elemento de la lista l (o matriz m) de índice j (o de índice j,k).',p:'Lst(l)||Mtrx(m),Index(j)||Lst([j,k])'},
    'atan':{d:'Arcotangente.',p:'Expr',a:['arctan','ATAN']},
    'atan2':{d:'',p:'Real(y),Real(x)'},
    'atan2acos':{d:'Reemplaza arctan(x) por pi/2-arccos(x/sqrt(1+x^2)) en el argumento.',p:'Expr'},
    'atan2asin':{d:'Reemplaza arctan(x) por arcsin(x/sqrt(1+x^2)) en el argumento.',p:'Expr'},
    'atanh':{d:'Arcotangente hiperbólico.',p:'Expr',a:['arctanh','ATANH']},
    'atrig2ln':{d:'Reescribe la expresión conteniendo funciones trigonométricas inversas con funciones logarítmicas.',p:'Expr'},
    'auto_correlation':{d:'',p:'Lst'},
    'autosimplify':{d:'',p:'Cmds'},
    'avance':{d:'La tortuga avanza de n pasos (por defecto n=10).',p:'NULL or Real(n)',a:['forward']},
    'avgRC':{d:'Devuelve (Xpr(var+h)-Xpr(Var))/h (por defecto h=0.001).',p:'Expr(Xpr),Var(Var),[Real(h)]'},
    'axes':{d:'Opción global (compatibilidad Maple) de una instrucción gráfica para poner o no los ejes.',p:'Opt'},
    'axis':{d:'',p:'xmin,xmax,ymin,ymax,[zmin,zmaz]'},
    'back':{d:'',p:'Vect or Seq or Str'},
    'backquote':{d:'``',p:'Expr'},
    'baisse_crayon':{d:'Baja el lápiz para que la tortuga mueva dejando marcas.',p:'NULL',a:['pendown']},
    'bandwidth':{d:'',p:'Opt'},
    'bar_plot':{d:'Muestra el gráfico de barras de una serie estadística en una variable.',p:'Mtrx',a:['barplot']},
    'bartlett_hann_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'barycenter':{d:'barycenter([point1,coeff1],...) traza el baricentro de point1 con peso coeff1...',p:'[Pnt,Real],[Pnt,Real],[Pnt,Real]'},
    'base':{d:'Opción para convert : convert(p,base,b)=[a0,a1,..an] o convert([a0,a1,..an],base,b)=p con p=a0+a1*b+....an*b^(n-1).',p:'Opt'},
    'basis':{d:'Extrae una base de una familia generadora de vectores.',p:'Lst(vector1,..,vectorn)'},
    'batons':{d:'',p:'Mtrx'},
    'begin':{d:'Comienzo de bloque.'},
    'bellman_ford':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)||Lst(T)'},
    'bernoulli':{d:'bernoulli(n) es el n-ésimo número de Bernoulli y bernoulli(n,x) es el n-ésimo polinomio de Bernoulli de variable el segundo argumento.',p:'Intg||(Intg,Var)'},
    'bernoulli_mod':{d:'',p:'Intg,Intg'},
    'besselJ':{d:'',p:'Real(x),Int(p)'},
    'besselY':{d:'',p:'Real(x),Int(p)'},
    'betad':{d:'Devuelve la densidad de probabilidad de la ley Beta (=Gamma(a+b)*x^(a-1)*(1-x)^(b-1)/(Gamma(a)*Gamma(b))).',p:'Real(a>0),Real(b>0),Real(0<=x<=1)'},
    'betad_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según la ley Beta sea menor que x0 o entre x0 y y0.',p:'Real(a>0),Real(b>0),Real(0<=x0<=1),[Real(0<=y0<=1)]'},
    'betad_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria Beta sea menor que h es p (0<=p<=1).',p:'Real(a>0),Real(b>0),Real(0<=p<=1)'},
    'betweenness_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'bezier':{d:'',p:'Lst,[plot]'},
    'bezoutian':{d:'',p:'Poly,Poly'},
    'biconnected_components':{d:'',p:'Graph(G)'},
    'binomial':{d:'Devuelve comb(n,k)*p^k*(1-p)^(n-k) o comb(n,k) si no hay 3er argumento.',p:'Intg(n),Intg(k),[Real(p in 0..1)]'},
    'binomial_cdf':{d:'Devuelve Proba(X<=x) o Proba(x<=X<=y) cuando X sigue la ley B(n,p).',p:'Intg(n),Real(p),Real(x),[Real(y)]'},
    'binomial_icdf':{d:'Devuelve h tal que Proba(X<=h)=t cuando X sigue la ley B(n,p).',p:'Intg(n),Real(p),Real(t)'},
    'bins':{d:'',p:'Opt'},
    'bipartite':{d:'',p:'Opt'},
    'bipartite_matching':{d:'',p:'Graph(G,[maximize||minimize,[epsilon=Real(eps)]])'},
    'bisection_solver':{d:'Argumento para fsolve indicando el método para la resolución numérica de una ecuación.',p:'Opt',a:['brent_solver','falsepos_solver','newton_solver','secant_solver','steffenson_solver']},
    'bisector':{d:'Traza la bisectriz del ángulo (AB,AC) dado por 3 puntos A,B,C.',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Pnt(C) or Cplx)'},
    'bit_depth':{d:'',p:'Audio(clip)||Image(img)'},
    'bitand':{d:'"Y" lógico bit a bit (conjunción).',p:'Intg,Intg'},
    'bitor':{d:'"O" lógico inclusivo bit a bit (disyunción).',p:'Intg,Intg'},
    'bitxor':{d:'"O" lógico exclusivo bit a bit (disyunción).',p:'Intg,Intg'},
    'blackman_harris_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'blackman_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'bloc':{d:'Palabra reservada.'},
    'blockmatrix':{d:'Devuelve la matriz obtenida al escindir la lista según n listas de largo m.',p:'Intg(n),Intg(m),Lst'},
    'bohman_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'border':{d:'Devuelve la matriz formada por A con b en el borde como última columna, si nrows(A)=size(b), border(a,b)=tran(append(tran(A),b)).',p:'Mtrx(A),Lst(b)'},
    'box_constraints':{d:'',p:'Vect(x),Mtrx(bounds)'},
    'boxcar':{d:'',p:'Real(a),Real(b),Expr(x)'},
    'boxwhisker':{d:'Gráfica BoxWhisker para una serie estadística.',p:'Lst,[Lst],[x=a..b||y=a..b]',a:['moustache']},
    'break':{d:'Interrumpe un bucle: while (cond) {inst1; if (cond) {inst2;break;}}.'},
    'breakpoint':{d:'Añade un punto de ruptura.',p:'Intg'},
    'bspline':{d:'',p:'Lst(c),[x[=Lst(t)||a..b],Intg(p)]'},
    'bvpsolve':{d:'',p:'Expr(f(x,y,y\')),Lst(x=a..b,y),Lst(y(a),y(b),[y\'(1)]),[options]'},
    'c1oc2':{d:'Devuelve la permutación producto de dos ciclos.',p:'Cycle,Cycle'},
    'c1op2':{d:'Devuelve la permutación igual al producto del ciclo con la permutación.',p:'Cycle,Permut'},
    'cFactor':{d:'Factorización de la expresión en ℂ (en los Gauss enteros si hay más de 2 variables).',p:'Expr',a:['cfactor','factoriser_sur_C']},
    'cZeros':{d:'Devuelve la lista de elementos complejos solución de Xpr=0 o la matriz donde las filas son las soluciones del sistema: Xpr1=0, Xpr2=0,..',p:'Expr(Xpr)||LstExpr, [Var||LstVar]'},
    'cache_tortue':{d:'Esconde la tortuga.',p:'NULL'},
    'camembert':{d:'Muestra uno o varios gráfico(s) de torta de una serie estadística en una variable.',p:'Mtrx',a:['pie']},
    'canonical_form':{d:'Forma canónica de un polinomio de grado 2.',p:'Trinom(a*x^2+b*x+c),[Var]'},
    'canonical_labeling':{d:'',p:'Graph(G)'},
    'cap':{d:'Devuelve la dirección de la tortuga en grados o gira la tortuga según el argumento.',p:'NULL or Real',a:['heading']},
    'cartesian_product':{d:'',p:'Seq(G1,G2,[G3])'},
    'cas_setup':{d:'Es el comando que reinicia el cas, argumentos: Approx,Cplx_var,Cplx,Angle,Format,Epsilon,Digit',p:'Int,Int,Int,Int,Int,Real,Int'},
    'case':{d:'Test (selección múltiple): switch(variable){case 1: {bloc1;} default: {bloc2;}};'},
    'cat':{d:'Evalua los argumentos, y los concatena en una cadena.',p:'SeqObj'},
    'catch':{d:'Protección contra errores: try {instructions} catch (variable) {error_instructions}(dentro de un programa).',p:'Var'},
    'cauchy':{d:'Devuelve la densidad de probabilidad de la ley de Cauchy.',p:'Real(x0),Real(a),Real(x)',a:['cauchyd']},
    'cauchy_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley Cauchy sea menor que x.',p:'Real(x0),Real(a),Real(x),[Real(y)]',a:['cauchyd_cdf']},
    'cauchy_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según ley Cauchy sea menor que h es p (y 0<=p<=1).',p:'Real(x0),Real(a),Real(p)',a:['cauchyd_icdf']},
    'cd':{d:'Cambia de directorio.',p:'Str'},
    'cdf':{d:'',p:'Func,FuncParams'},
    'ceil':{d:'Devuelve el menor entero >= que el argumento.',p:'Real or Cplx',a:['ceiling']},
    'center':{d:'Muestra el centro de una circunferencia.',p:'Crcle'},
    'center2interval':{d:'Devuelve la lista de intervalos empezando por a0 y teniendo por centros la lista l.',p:'LstVal(l),[Real(a0)]'},
    'centered_cube':{d:'Traza el cubo directo de centro A, vértice B, tal que el plano ABC contiene un eje de simetría del cubo.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'centered_tetrahedron':{d:'Traza el tetraedro regular directo de centro A, vértice B con un vértice en el plano (A,B,C).',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'cfsolve':{d:'Resolución numérica de una ecuación o de un sistema de ecuaciones en ℂ.',p:'Expr,Var,[Guess or Interval],[Method]'},
    'changebase':{d:'Devuelve la matriz B=inv(P)*A*P.',p:'Mtrx(A),Mtrx(P)'},
    'channel_data':{d:'',p:'Audio(clip),[Intg(chn) or matrix],[range=a..b]||Image(img),Intg(chn),Intg(x),Intg(y),Intg(width),Intg(height)'},
    'channels':{d:'',p:'Audio(clip)||Image(img)'},
    'char':{d:'Devuelve la cadena correspondiente a los códigos de caracteres contenidos en el argumento.',p:'Intg or Lst(Intg)',a:['chr']},
    'chinrem':{d:'Resto chino para polinomios escritos como listas o no.',p:'[Lst||Expr,Lst||Expr],[Lst||Expr,Lst||Expr]'},
    'chisquare':{d:'Devuelve la densidad de probabilidad de la ley Chi-cuadrada en x0 (n es el número de grados de libertad).',p:'Intg(n),Real(x0)',a:['chisquared']},
    'chisquare_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según Chi-cuadrado sea menor que x0 (n es el número de grados de libertad).',p:'Intg(n),Real(x0)',a:['chisquared_cdf']},
    'chisquare_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según Chi-cuadrado sea menor que h es p (n es el número de grados de libertad y 0<=p<=1).',p:'Intg(n),Real(p)',a:['chisquared_icdf']},
    'chisquaret':{d:'',p:'Data,[Func],[FuncParams]'},
    'choice':{d:'choice(L)=rand(L)=  un elemento de L.',p:'Lst(L)'},
    'cholesky':{d:'Para un matriz numérica simétrica A, devuelve L, matriz tal que A=L*tran(L).',p:'Mtrx'},
    'choosebox':{d:'En un programa, crea una entrada mostrando una lista de elección.',p:'Str(titel),LstVal,Var',a:['PopUp']},
    'chrem':{d:'Restos chinos para entero S o para polinomios.',p:'LstIntg(a,b,c....),LstIntg(p,q,r,....)'},
    'chromatic_index':{d:'',p:'Graph(G)'},
    'chromatic_number':{d:'',p:'Graph(G)'},
    'chromatic_polynomial':{d:'',p:'Graph(G),[Var(t)]'},
    'circle':{d:'Define una circunferencia por un diámetro MN (arg1=M o zM,arg2=N) o por sus centro y radio (centr0=M et radi0=abs(zN)) [o arc0 AB, A ángulo a, B ángulo b, (MN=ángulo 0) or M(M+zN)=ángulo 0)] o por su ecuación.',p:'(Pnt(M) or Cplx(M),(Pnt(N) or Cplx(zN)),[Real(a)],[Real(b)],[Var(A)],[Var(B)]'},
    'circumcenter':{d:'',p:'(Pnt or Cplx),(Pnt or Cplx),((Pnt or Cplx)'},
    'circumcircle':{d:'circumcircle(A,B,C)=circunferencia circunscrita al triángulo ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),((Pnt or Cplx)'},
    'classes':{d:'Devuelve la matriz [[clase,número],...] obtenida con class_min y class_size: véase configuración de geo o argumento 2 y 3 o con la lista de centros.',p:'Lst(l),[ClassMin],[ClassSize||Lst(Center)]'},
    'clear':{d:'',p:'NULL'},
    'click':{d:'Entrada interactiva de un número complejo con un click en una pantalla de geometría.',p:'NULL'},
    'clique_cover':{d:'',p:'Graph(G),[Intg(k)]'},
    'clique_cover_number':{d:'',p:'Graph(G)'},
    'clique_number':{d:'',p:'Graph(G)'},
    'closeness_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'cluster':{d:'',p:'Lst(data),[opts]'},
    'clustering_coefficient':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'coeff':{d:'Devuelve la lista de los coeficientes de un polinomio con respecto al 2o argumento o el coeficiente de grado del 3er argumento.',p:'Expr(P),[Var]',a:['coeffs']},
    'col':{d:'Devuelve la columna n o la secuencia de columnas n1..n2 de la matriz A, o argumento opcional de count,count_eq,count_inf,count_sup.',p:'Mtrx(A),Intg(n)||Interval(n1..n2)'},
    'colNorm':{d:'Devuelve el máximo de las sumas de los valores absolutos de los elementos encontrados sobre las columnas de la matriz: colNorm(a_{j,k})=max_k(sum_j(|a_{j,k}|)).',p:'Vect or Mtrx',a:['colnorm']},
    'colSwap':{d:'Devuelve la matriz obtenida a partir de A intercambiando las columnas n1 y n2.',p:'Mtrx(A),Intg(n1),Intg(n2)',a:['swapcol','colswap','SWAPCOL']},
    'coldim':{d:'Número de columnas de una matriz.',p:'Mtrx',a:['ncols','colDim']},
    'collect':{d:'Factorización de un polinomio (o de una lista de polinomios) sobre los enteros.',p:'Poly or LstPoly'},
    'colormap':{d:'',p:'Str(palette)||Lst(palettes),[Intg(n)||Real(t)||Str(colorname)||display]'},
    'colspace':{d:'Devuelve una matriz cuyas columnas constituyen una base del espacio de vectores generado por las columnas de la matriz A [d es la dimensión de este espacio].',p:'Mtrx(A), [Var(d)]'},
    'comDenom':{d:'Devuelve la expresión después de reducirla a denominador común: el numerador y denominador son desarrollados [de acuerdo con las potencias de la variable var].',p:'Expr,[Var(Var)]'},
    'comb':{d:'comb(n,r)=número de combinaciones de r objetos tomados dentro de n : n!/(r!(n-r)!) (si n<0 comb(n,r)=n(n-1)..(n-r+1)/r!).',p:'Intg(n),Intg(r)',a:['nCr']},
    'combine':{d:'Agrupa términos de Xpr de acuerdo a una [clase de] función f [en segundo argumento].',p:'Expr(Xpr),Fnc(f).'},
    'comment':{d:'Comentario dentro de un programa.',p:'Expr'},
    'common_perpendicular':{d:'Traza la perpendicular común a las rectas D1 y D2.',p:'Line(D1),Line(D2)'},
    'companion':{d:'Matriz compañera de un polinomio unitario (an=1).',p:'Poly,Var'},
    'compare':{d:'Devuelve 1 si type(arg1)<type(arg2) o si type(arg1)=type(arg2) y arg1<arg2, si no, devuelve 0.',p:'Obj(arg1),Obj(arg2)'},
    'complete_binary_tree':{d:'',p:'Intg(n)'},
    'complete_graph':{d:'',p:'Intg(n)||Lst(V)||Seq(n1,n2,...,nk)'},
    'complete_kary_tree':{d:'',p:'Intg(k),Intg(n)'},
    'complex_mode':{d:'Nombre que permite trabajar en modo complejo (complex_mode:=1) o en modo real (complex_mode:=0).',p:':=Intg(0 or 1)'},
    'complex_variables':{d:'Nombre que permite trabajar con variables complejas (complex_variables:=1) o con variables reales (complex_variables:=0).',p:':=Intg(0 or 1)'},
    'complexroot':{d:'Devuelve la lista de intervalos complejos (lado<=l) que contienen las raíces de P (por ejemplo i[1.1,1.2]+i*i[2,2.4] para [1.1,1.2]x[2,2.4] con en opción a=1+2*i,b=2+3*i) con su multiplicidad.',p:'Poly(P),Real(l),[Cplx(a)],[Cplx(b)]'},
    'concat':{d:'Concatena 2 listas o 2 cadenas o 2 secuencias o dos matrices; L:=concat(L,L1) o L.concat(L1).',p:'Lst,Lst||Seq,Seq||Str,Str||Mtrx,Mtrx',a:['augment','extend']},
    'condensation':{d:'',p:'Graph(G)'},
    'cone':{d:'Traza un cono con cumbre A, dirección v, y con medio_ángulo t en la cumbre [y con altura h y -h].',p:'Pnt(A),Vect(v),Real(t),[Real(h)]'},
    'confrac':{d:'Opción del comando convert o convertir (ex id L:=dfc(sqrt(2),1e-10)).',p:'Opt'},
    'conic':{d:'Define una cónica por su ecuación con x,y como variables por defecto, y la traza.',p:'Expr,[LstVar]'},
    'conj':{d:'Devuelve el conjugado de un número complejo.',p:'Cplx'},
    'conjugate_equation':{d:'',p:'Expr(y0),Lst(P),Lst(V),Var(x),Real(a)'},
    'conjugate_gradient':{d:'',p:'Mtrx(A),Vect(y),[Vect(x0),Real(eps)]'},
    'connected':{d:'',p:'Opt'},
    'connected_components':{d:'',p:'Graph(G)'},
    'cont':{d:'Continua la ejecución de un programa detenido.',p:'NULL'},
    'contains':{d:'Comprueba si uno conjunto contiene una expresión (devuelve el índice+1 o 0).',p:'(Lst(l) or Set(l)),Elem(e)'},
    'content':{d:'Devuelve el mcd de los coeficientes del polinomio P dado como argumento.',p:'Poly(P),[Var]'},
    'continue':{d:'En un programa, no finaliza la iteración, sino que pasa a la iteración siguiente: while (cond) {i1; if(cond) continue; i2;}.'},
    'contract_edge':{d:'',p:'Graph(G),Edge(e)'},
    'contract_subgraph':{d:'',p:'Graph(G),Lst(S),[lb]'},
    'convert':{d:'Devuelve el valor de cmd(Xpr) cmd es el nombre de un comando especificado como 2o argumento (por ejemplo option sin=command trigsin).',p:'Expr(Xpr),Cmd(cmd)',a:['convertir']},
    'convex':{d:'',p:'Expr(f),Lst(x,y,..),[simplify]'},
    'convexhull':{d:'Envoltura convexa de un conjunto de puntos del plano.',p:'Lst'},
    'convolution':{d:'',p:'Lst(u),Lst(v)'},
    'coordinates':{d:'Devuelve la lista (resp matriz) de la abscisa y de la ordenada de un punto o de un vector.',p:'Pnt or Cplx or Vect'},
    'copy':{d:'A:=copy(B) copia la lista o matriz B en A.',p:'Mtrx,Var'},
    'correlation':{d:'Devuelve la correlación de los elementos del argumento.',p:'Lst||Mtrx,[Lst]'},
    'cos':{d:'Coseno o Opción del comando convert o convertir (id trigcos).',p:'Expr or Opt',a:['COS']},
    'cos2sintan':{d:'Reemplaza cos(x) por sin(x)/tan(x) en el argumento.',p:'Expr'},
    'cosh':{d:'Coseno hiperbólico.',p:'Expr',a:['COSH']},
    'cosine_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'cot':{d:'Cotangente.',p:'Expr',a:['COT']},
    'cote':{d:'Tercera coordinada (z) de un punto 3-d.',p:'Vect'},
    'count':{d:'Devuelve f(l[0])+f(l[1])+..+f(l[size(l)-1]).',p:'Fnc(f)||LstIntg,(Lst||Mtrx)(l),[Opt(row||col)]'},
    'count_eq':{d:'Devuelve el número de elementos de L iguales a a.',p:'Real(a),(Lst||Mtrx)(L),[Opt(row||col)]'},
    'count_inf':{d:'Devuelve el número de elementos de L estrictamente menores que a.',p:'Real(a),(Lst||Mtrx)(L),[Opt(row||col)]'},
    'count_sup':{d:'Devuelve el número de elementos de L estríctamente mayores que a.',p:'Real(a),(Lst||Mtrx)(L),[Opt(row||col)]'},
    'covariance':{d:'Devuelve la covarianza de los elementos del argumento',p:'Lst||Mtrx,[Lst]'},
    'covariance_correlation':{d:'Devuelve la lista de la covarianza y la correlación de los elementos del argumento.',p:'Lst||Mtrx,[Lst]'},
    'cpartfrac':{d:'Efectua la descomposición parcial en ℂ de una fracción.',p:'RatFrac'},
    'crationalroot':{d:'Devuelve la lista de raíces racionales complejas de P sin indicar la multiplicidad.',p:'Poly(P)'},
    'crayon':{d:'Cambia el color del lápiz (sin parámetros, devuelve el color actual).',p:'Color',a:['pencolor']},
    'createwav':{d:'',p:'Lst(data),[opts]'},
    'cross':{d:'Producto vectorial.',p:'Vect(v1),Vect(v2)',a:['crossproduct','crossP']},
    'cross_correlation':{d:'',p:'cross_correlation(Lst(u),Lst(v))'},
    'cross_ratio':{d:'Devuelve el número complejo igual a ((c-a)/(c-b))/((d-a)/(d-b)).',p:'Pnt or Cplx(a),Pnt or Cplx(b),Pnt or Cplx(c),Pnt or Cplx(d)'},
    'csc':{d:'Cosecante: csc(x)=1/sin(x).',p:'Expr',a:['CSC']},
    'csolve':{d:'Devuelve la matriz cuyas filas son soluciones en ℂ del sistema de ecuaciones polinomiales.',p:'LstEq,LstVar',a:['cSolve','resoudre_dans_C']},
    'csv2gen':{d:'',p:'Strng(filename),Strng(sep),Strng(nl),Strng(decsep),Strng(eof),[string]'},
    'cube':{d:'Traza el cubo directo de lado AB con una casa en el plano (A,B,C).',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'cumSum':{d:'Devuelve la lista (o secuencia, o cadena) lr donde los elementos son sumas acumulativas de la lista l: lr[k]=sum(l[j],j=0..k) (o lr=sum(l[j],j=0..k)$(k=0..size(l)-1)).',p:'Lst(l)||Seq||Str',a:['cumsum']},
    'cumulated_frequencies':{d:'Traza el diagrama de frecuencias acumuladas (filas=[valor,frecuencias])',p:'Lst || Mtrx'},
    'curl':{d:'rotacional=[dC/dy-dB/dz,dA/dz-dC/dx,dB/dx-dA/dy].',p:'Lst(A,B,C),Lst(x,y,z)'},
    'current_sheet':{d:'Contenido del editor de matriz/de la hoja de balance.',p:'[Intg||Inter],[Intg||Letter],[Letter]'},
    'curvature':{d:'',p:'Curve,Point'},
    'curve':{d:'Palabra reservada.',p:'Expr'},
    'cycle2perm':{d:'Convierte el ciclo c en una permutación.',p:'Cycle'},
    'cycle_basis':{d:'',p:'Graph(G)'},
    'cycle_graph':{d:'',p:'Intg(n)||Lst(V)'},
    'cycleinv':{d:'Devuelve el ciclo inverso del ciclo c.',p:'Cycle(c)'},
    'cycles2permu':{d:'Convierte un producto de ciclos c en una permutación.',p:'Lst(Cycle)'},
    'cyclotomic':{d:'N-ésimo polinomio ciclotómico.',p:'Expr'},
    'cylinder':{d:'Traza un cilindro con eje (A,v), con radio r [y altura h].',p:'Pnt(A),Vect(v),Real(r),[Real(h)]'},
    'dash_line':{d:'Opción de la instrucción display para una línea.',p:'Opt',a:['ligne_tiret','solid_line','ligne_trait_plein','dashdot_line','ligne_tiret_point','dashdotdot_line','ligne_tiret_pointpoint','cap_flat_line','ligne_chapeau_plat','cap_square_line','ligne_chapeau_carre','cap_round_line','ligne_chapeau_rond']},
    'dayofweek':{d:'',p:'Int,Int,Int'},
    'de':{d:'Utilizado en una bucle for (for...from ...to...[step...] do...od;).',a:['from']},
    'debug':{d:'Comienza una sesión de depuración.',p:'Expr'},
    'debut_enregistrement':{d:'Marca el inicio de la grabación de comandos componiendo el dibujo de nombre dado en argumento.',p:'Var(nom_du_dessin)'},
    'default':{d:'Selección por defecto en una instrucción switch.',a:['otherwise']},
    'degree':{d:'Grado del polinomio P con respecto al segundo argumento.',p:'Poly(P),Var(Var)'},
    'degree_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'degree_sequence':{d:'',p:'Graph(G)'},
    'degrees':{d:'',p:'Real(rad)'},
    'delcols':{d:'Devuelve la matriz A después de borrar las columnas n1..n2 (o n1).',p:'Mtrx(A),Interval(n1..n2)||n1'},
    'delete_arc':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'delete_edge':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'delete_vertex':{d:'',p:'Graph(G),Vrtx(v)||Lst(V)'},
    'delrows':{d:'Devuelve la matriz A después de borrar las filas n1..n2 (o n1).',p:'Mtrx(A),Interval(n1..n2)||n1'},
    'deltalist':{d:'Devuelve una lista con las diferencias de términos consecutivos en una sucesión.',p:'Lst'},
    'denom':{d:'Devuelve el denominador de la fracción simplificada.',p:'Frac(a/b) or RatFrac'},
    'departures':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'desolve':{d:'Resuelve una ecuación diferencial o un sistema diferencial lineal con coeficientes constants.',p:'Eq,[TimeVar],FncVar',a:['deSolve','dsolve']},
    'dessine_tortue':{d:'Traza el triángulo relleno (o no si n=1) representando la tortuga.',p:'[Intg(n)]'},
    'det':{d:'Determinante de una matriz cuadrada M.',p:'Mtrx'},
    'det_minor':{d:'Devuelve el determinante calculado con cálculo de menores.',p:'Mtrx(A)'},
    'dfc':{d:'Devuelve el desarrollo en fracción continua de x0 de orden n o con precisión eps.',p:'Real(x0),Int(n)||Real(eps)'},
    'dfc2f':{d:'Convierte una fracción continua en un real.',p:'LstFrac_Cont)'},
    'diag':{d:'Con 1 argumento devuelve o bien la matrix diagonal con diagonal l, o bien la diagonal de A, con 2 argumentos devuelve la parte izquierda de A o la parte derecha de A ou cortar A en 3 partes : estricto izquierda,diagonal,estricto derecha y con 3 argumentos devuelve la matrix tridiagonal con diagonal l,d,u.',p:'Lst(l)||(Mtrx(A),[left||right||lu])||Lst(l),Lst(d),Lst(u)'},
    'diff':{d:'Devuelve la derivada con respecto al segundo argumento.',p:'Expr or Fnc,[SeqVar or LstVar],[n]',a:['derive','deriver']},
    'digraph':{d:'',p:'[Lst(V)],[Set(E)],[Mtrx(A)],[options]'},
    'dijkstra':{d:'',p:'Graph(G),Vrtx(v),[Vrtx(w)||Lst(W)]'},
    'dim':{d:'Devuelve la lista que da la dimensión de la matriz dada como argumento.',p:'Mtrx'},
    'directed':{d:'',p:'Opt'},
    'discard_edge_attribute':{d:'',p:'Graph(G),Edge(e),Seq(tag1=value1,tag2=value2,..)'},
    'discard_graph_attribute':{d:'',p:'Graph(G),Seq(tag1=value1,tag2=value2,..)'},
    'discard_vertex_attribute':{d:'',p:'Graph(G),Vrtx(v),Seq(tag1=value1,tag2=value2,..)'},
    'discriminant':{d:'Discriminante de 1 polinomios.',p:'Poly,Var'},
    'disjoint_union':{d:'',p:'Seq(G1,G2,...)'},
    'display':{d:'Dibuja un objeto geométrico con colores (negro=0 rojo=1 verde=2 amarillo=3 azul=4), con trazado +/- grueso (line_width_n 0<n<8) y puede mostrarlo según una recta punteada (dash_line), mientras filled permite de rellenar un polígono o una curva cerrada.',p:'[GeoObj or legende],Intg',a:['color']},
    'disque':{d:'Traza un disco (círculo) de radio r (resp un sector de ángulo (0,a) o (a,b)), tangente a la posición de la tortuga.',p:'Real(r),[Real(a)],[Real(b)]'},
    'disque_centre':{d:'Traza un disco (círculo) de radio r (resp un sector de ángulo (0,a) o (a,b)) de centro la posición de la tortuga.',p:'Real(r),[Real(a)],[Real(b)]'},
    'distance':{d:'Calcula la distancia entre 2 puntos o entre 1 punto y una curva.',p:'(Pnt or Cplx),(Pnt or Cplx or Curve)'},
    'distance2':{d:'Calcula el cuadrado de la distancia entre 2 puntos o entre un punto y una curva.',p:'(Pnt or Cplx),(Pnt or Cplx or Curve)'},
    'distanceat':{d:'distanceat(A,B,z0) escribe en el punto point(z0), con una leyenda, el valor de la distancia entre 2 puntos o entre 1 punto y una curva',p:'GeoObj(A),GeoObj(B),(Pnt or Cplx)'},
    'distanceatraw':{d:'distanceatraw(A,B,z0) escribe en el punto point(z0), el valor de la distancia entre 2 objetos geométricos.',p:'GeoObj(A),GeoObj(B),(Pnt or Cplx(z0))'},
    'div':{d:'Cociente euclídeo de 2 enteros (operador infijo).',p:'Intg,Intg'},
    'divergence':{d:'Divergencia: divergence([A,B,C],[x,y,z])=dA/dx+dB/dy+dC/dz.',p:'Lst(A,B,C),Lst(x,y,z)'},
    'divis':{d:'Devuelve la lista de divisores de un polinomio.',p:'Poly(P) or LstPoly'},
    'division_point':{d:'Devuelve el punto M tal que (z-a)=k*(z-b) y z=afijo de M (MA=k*MB).',p:'Pnt or Cplx(a),Pnt or Cplx(b),Cplx(k)'},
    'divpc':{d:'Polinómio de Taylor de grado n del cociente de 2 polinomios.',p:'Poly,Poly,Intg(n)'},
    'dnewton_solver':{d:'Argumento para fsolve indicando el método para la resolución numérica de un sistema de ecuaciones.',p:'Opt',a:['hybrid_solver','hybrids_solver','hybridj_solver','hybridsj_solver','newtonj_solver']},
    'do':{d:'Palabra clave utilizada en un bucle.',a:['faire']},
    'dodecahedron':{d:'Traza un dodecaedro de centro A, vértice B donde el plano ABC contiene un eje de simetría del dodecaedro.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'domain':{d:'',p:'Expr'},
    'dot':{d:'Producto escalar.',p:'Vect(v1),Vect(v2)',a:['dotP','scalarProduct','scalar_product','dotprod']},
    'dot_paper':{d:'Traza los vértices de la red formada por las rectas y=n*uy e en los ejes OxY de ángulo t!=0 las rectas x=n*ux.',p:'Real(ux),Real(uy),Real(t)'},
    'draw_arc':{d:'',p:'Intg(x),Intg(y),Intg(rx),Intg(ry),Real(theta1),Real(theta2),Intg(col)'},
    'draw_circle':{d:'',p:'Intg(x),Intg(y),Intg(r),Intg(col)'},
    'draw_graph':{d:'',p:'Graph(G),[opts]'},
    'draw_line':{d:'',p:'Intg(x1),Intg(y1),Intg(x2),Intg(y2),Intg(col)'},
    'draw_polygon':{d:'',p:'Lst(l),Intg(col)'},
    'draw_rectangle':{d:'',p:'Intg(x),Intg(y),Intg(w),Intg(h),Intg(col)'},
    'droite_tangente':{d:'Traza la tangente de y=f(x) en x=a.',p:'Expr(f(x)),[Var],Expr(a)'},
    'duration':{d:'',p:'Audio(clip)'},
    'dwt':{d:'',p:'(Lst||Mtrx)(data),[opts]'},
    'e':{d:'exp(1)'},
    'ecef2geodetic':{d:'',p:'Real(x),Real(y),Real(z)'},
    'ecm_factor':{d:'',p:'Intg(a),[Intg(B1)]'},
    'ecris':{d:'Escribe la cadena s con la fuente n (por defecto n=14) en el punto [x,y] (por defecto en el lugar de la tortuga).',p:'Str(s),[Intg(n)],[Real(x)],[Real(y)]'},
    'edge_connectivity':{d:'',p:'graph(G)'},
    'edges':{d:'',p:'Graph(G),[weights]'},
    'efface':{d:'Borra la pantalla de la tortuga o vuelve por atrás de n pasos borrando.',p:'NULL or Real(n)'},
    'egcd':{d:'Máximo común divisor extendido de 2 polinomios.',p:'(Poly or Lst),(Poly or Lst),[Var]',a:['gcdex']},
    'egv':{d:'Calcula los vectores propios de una matriz diagonalizable.',p:'Mtrx',a:['eigenvectors','eigenvects','eigVc']},
    'egvl':{d:'Devuelve la matriz de Jordan asociada a A si los valores propios son calculables.',p:'Mtrx(A)',a:['eigVl']},
    'eigenvals':{d:'Devuelve la secuencia de valores propios (calculables) de una matriz.',p:'Mtrx',a:['eigenvalues']},
    'element':{d:'Muestra un punto seleccionado de una curva o un real escogido dentro de un intervalo',p:'(Curve or Real_interval),[Val]'},
    'elif':{d:'FIXME elif =else if). if condition1 then instruction1; elif condition2 then instruction2;...[else instruction;] end'},
    'eliminate':{d:'',p:'LstEq(eqs),LstVar(vars)'},
    'ellipse':{d:'ellipse(F1,F2,M)=elipse de focos F1,F2 que pasa por M o MF1+MF2=2*a (geo2d) y ellipse(p(x,y)) traza la cónica si deg(p)=2.',p:'Pnt(F1),Pnt(F2),(Pnt(M) or Real(a))'},
    'else':{d:'Comienza los comandos de la opción falsa de un "if": if (condition){instruction1;} else {instruction2;}'},
    'emd':{d:'',p:'Lst(data),[opts]'},
    'end':{d:'Final de bloque.',a:['end_for','fpour','end_while','ftantque','end_if','fi','fsi','od','ffaire','ffonction','ffunction']},
    'enumerate':{d:'',p:'Lst(l),[Intg(start)]'},
    'envelope':{d:'Devuelve la envoltura de las curvas de ecuación Xpr=0, cuando t varia.',p:'Expr(Xpr),Var(t)||[x,y,t]'},
    'epsilon':{d:'Devuelve el valor de epsilon de la configuración del CAS.',p:'NULL'},
    'epsilon2zero':{d:'Sustituye por 0 los valores < epsilon',p:'Expr'},
    'equal':{d:'Versión prefijo de =',p:'Expr,Expr'},
    'equal2diff':{d:'Transforma A=B o equal(A,B) en la diferencia A-B',p:'Equal'},
    'equal2list':{d:'Transforma la igualdad A=B o equal(A,B) en la lista [A,B]',p:'Equal'},
    'equation':{d:'equation devuelve la ecuación cartesiana de una curva',p:'GeoObj, VectParam'},
    'equilateral_triangle':{d:'equilateral_triangle(A,B) (resp equilateral_triangle(A,B,P)) traza el triángulo equilátero ABC directo de lado AB (resp en el semi-plan ABP).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),[Pnt(P)],[Var(C)]'},
    'erase':{d:'Borra la pantalla gráfica',p:'NULL'},
    'erase3d':{d:'Borra la pantalla gráfica 3d',p:'NULL'},
    'erf':{d:'Devuelve el valor aproximado de 2/sqrt(pi)*int(exp(-t^2),t,0,x0).',p:'Real(x0)'},
    'erfc':{d:'Devuelve el valor aproximado de 2/sqrt(pi)*int(exp(-t^2),t,x0,+infinity).',p:'Real(x0)'},
    'error':{d:'Genera un mensaje de error dentro de un programa',p:'Str',a:['ERROR','throw']},
    'euler':{d:'Función de Euler (eluler(n)=card({p<n,gcd(n,p)=1})).',p:'Intg(n)',a:['Phi']},
    'euler_gamma':{d:'Constante de Euler=euler_gamma=limit(sum(1/k,k,1,n)-ln(n),n,+infinity).'},
    'euler_lagrange':{d:'',p:'Expr(f),[(Var(x),[Var||Lst(y)]) || y(x) || Lst(y(x))]'},
    'eval':{d:'Evalua su argumento.',p:'Expr',a:['evalm']},
    'eval_level':{d:'Nivel de evaluación en modo interactivo',p:'[Intg(n)]'},
    'evalb':{d:'Evaluación booleana del argumento',p:'Expr'},
    'evalc':{d:'Devuelve una expresión compleja simplificada de la forma real+i*imag.',p:'Expr'},
    'evalf':{d:'Evaluación numérica del primer argumento (se puede dar el número de dígitos como segundo argumento)',p:'Expr,[Int]',a:['approx']},
    'even':{d:'Devuelve 1 si el entero es par, devuelve 0 si no.',p:'Intg(n)'},
    'evolute':{d:'',p:'Curve'},
    'exbisector':{d:'Traza la bisectriz exterior del ángulo (AB,AC) dado por 3 puntos A,B,C.',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Pnt(C) or Cplx)'},
    'excenter':{d:'excenter(A,B,C) dibuja la circunferencia exinscrita relativa al punto A.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'excircle':{d:'excircle(A,B,C) dibuja la circunferencia exinscrita relativa al punto A.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'exp':{d:'Exponencial o Opción del comando convert o convertir (id trig2exp).',p:'Expr or Opt',a:['EXP']},
    'exp2list':{d:'Devuelve la lista formada por los miembros derechos de (var=expr0 o var=expr1), práctico después de solve en modo TI.',p:'Expr'},
    'exp2pow':{d:'Transforma exp(n*ln(x)) en x^n.',p:'Expr'},
    'exp2trig':{d:'Transforma las exponenciales complejas en senos y cosenos.',p:'Expr'},
    'expand':{d:'Distribuye totalmente * y / sobre + y -',p:'Expr',a:['fdistrib','developper']},
    'expexpand':{d:'Desarrolla las expresiones exponenciales.',p:'Expr'},
    'expln':{d:'Opción del comando convert o convertir (id trig2exp).',p:'Opt'},
    'exponential':{d:'Devuelve la densidad de probabilidad de la ley de exponential.',p:'Real(lambda),Real(x)',a:['exponentiald']},
    'exponential_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley exponential sea menor que x0.',p:'Real(lambda),Real(x0),[Real(y0)]',a:['exponentiald_cdf']},
    'exponential_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según ley exponential sea menor que h es p (0<=p<=1).',p:'Real(lambda),Real(x0),Real(p)',a:['exponentiald_icdf']},
    'exponential_regression':{d:'Devuelve los coeficientes (a,b) de y=b*a^x : es la exponencial que mejor aproxima los puntos donde las coordenadas son las filas de A (o las dos listas).',p:'Lst||Mtrx(A),[Lst]'},
    'exponential_regression_plot':{d:'Devuelve la gráfica de y=b*a^x : es la exponencial que mejor aproxima los puntos cuyas coordenadas son las filas de A (o de las 2 listas).',p:'Lst||Mtrx(A),[Lst]'},
    'export_graph':{d:'',p:'Graph(G),Str("filename"),[opts]'},
    'export_mathml':{d:'',p:'Expr,[display||content]'},
    'expr':{d:'Instrucción que transforma una cadena en un comando o en un número.',p:'Str',a:['execute']},
    'extract_measure':{d:'extract_measure devuelve con respuesta el valor calculado por el argumento.',p:'Var'},
    'extrema':{d:''},
    'ezgcd':{d:'MCD de 2 polinomios de al menos 2 variables, con el algoritmo ezgcd.',p:'Poly,Poly'},
    'f2nd':{d:'Devuelve la lista formada por el numerdador y el denominador de la facción simplificada.',p:'Frac or RatFrac',a:['fxnd']},
    'fMax':{d:'Devuelve la abscisa del máximo de la expresión.',p:'Expr,[Var]'},
    'fMin':{d:'Devuelve la abscisa del mínimo de la expresión.',p:'Expr,[Var]'},
    'fPart':{d:'Devuelve la parte fraccional (if x<0 then frac(x)+floor(x)+1=x else frac(x)+floor(x)=x).',p:'Real||LstReal',a:['frac']},
    'faces':{d:'Devuelve la lista de los lados (1 lado=matriz(n,3) donde las n filas son los n vértices del lado) de un poliedro P.',p:'Polygon or Polyedr(P)'},
    'factor':{d:'Factoriza un polinomio.',p:'Expr',a:['factoriser']},
    'factor_xn':{d:'Factoriza x^n en P (n=grado del polinomio P).',p:'Poly(P)'},
    'factorial':{d:'factorial(n)=n! o a! = G(a + 1).',p:'Intg(n)|| Real(a)'},
    'factors':{d:'Devuelve la lista de factores primos de un polinomio y su orden de multiplicidad.',p:'Poly or LstPoly'},
    'fadeev':{d:'Opción del comando pcar o charpoly para especificar el algoritmo.',p:'Opt'},
    'false':{d:'Tipo de dato lógico (booleano) que vale falso o 0.',a:['FALSE','False']},
    'fclose':{d:'Cierra el archivo f.',p:'File(f)',a:['close']},
    'fcoeff':{d:'Devuelve el polinomio descrito por la lista (raíz o polo, multiplicidad).',p:'Lst(root||pole,order)'},
    'feuille':{d:'Devuelve el argumento de un operador en forma de secuencia.',p:'Op or Fnc',a:['op']},
    'fft':{d:'Fast Fourier Transform en ℝ, o en el campo finito ℤ/pℤ, con a como raíz n-ésima primitiva de la unidad (n=size(L)).',p:'Vect or (Vect(L),Intg(a),Intg(p)'},
    'filled':{d:'Opción de la instrucción display para rellenar figuras.',p:'Opt'},
    'filled_1':{d:'Opción de la instrucción display para rellenar figuras.',p:'Opt'},
    'filled_2':{d:'Opción de la instrucción display para rellenar figuras.',p:'Opt'},
    'filled_3':{d:'Opción de la instrucción display para rellenar figuras.',p:'Opt'},
    'filled_4':{d:'Opción de la instrucción display para rellenar figuras.',p:'Opt'},
    'filled_5':{d:'Opción de la instrucción display para rellenar figuras.',p:'Opt'},
    'fin_enregistrement':{d:'Marca el fin de la grabación de comandos y graba estos comandos en un archivo con nombre dado en argumento.',p:'Str(nom_de_fichier)'},
    'find':{d:'',p:'Expr,Vect'},
    'find_cliques':{d:'',p:'Graph(G),[Intg(k)||Intrv(m..n)]'},
    'find_cycles':{d:'',p:'Graph(G,[length=k||l..u])'},
    'find_minimum':{d:'',p:'(Expr||Func)(f),Real(a),Real(b),[Real(eps),Intg(maxiter)]'},
    'find_vertex_cover':{d:'',p:'Graph(G),[Intg(k)]'},
    'findhelp':{d:'Devuelve la ayuda sobre el comando (si ? es infijo véase when).',p:'Cmd',a:['?']},
    'fisher':{d:'Devuelve la densidad de probabilidad de la ley de Fisher-Snedecor (n y m son los grados de libertad).',p:'Intg(n),Intg(m),Real(x0)',a:['snedecor','fisherd','snedecord']},
    'fisher_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley Fisher-Snedecor sea menor que x0 (n y m son los grados de libertad).',p:'Intg(n),Intg(m),Real(x0)',a:['snedecor_cdf','fisherd_cdf','snedecord_cdf']},
    'fisher_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según ley Fisher-Snedecor sea menor que h es p (n y m son los grados de libertad y 0<=p<=1).',p:'Intg(n),Intg(m),Real(p)',a:['snedecor_icdf','fisherd_icdf','snedecord_icdf']},
    'fitdistr':{d:'',p:'Lst(L),Fnc(D)'},
    'fitpoly':{d:'',p:'Expr||Mtrx||Seq(Lst(x),Lst(y)),[Var[=Real(a)..Real(b)]],[Options]'},
    'fitspline':{d:'',p:'Mtrx(data),(Var||Lst)(x),[opts]'},
    'flatten':{d:'',p:'Lst||Image'},
    'float2rational':{d:'Convierte una expresión en una expresión real o racional.',p:'Expr',a:['exact']},
    'floor':{d:'Devuelve el mayor entero <= que el argumento',p:'Real or Cplx'},
    'flow_polynomial':{d:'',p:'Graph(G),[Var(x)]'},
    'flower_snark':{d:'',p:'Intg(n)'},
    'fmod':{d:'',p:'Real(a),Real(b)'},
    'foldl':{d:'',p:'op,id,Seq(r1,r2,...)'},
    'foldr':{d:'',p:'op,id,Seq(r1,r2,...)'},
    'fopen':{d:'Abre un archivo llamado s, devuelve una variable de tipo archivo.',p:'Str(s)'},
    'for':{d:'Bucle: for (init;do_if_true;increment) {action;}'},
    'fork_timeout':{d:'',p:'Expr(f),Real(dt)'},
    'format':{d:'Transforma un número real en una cadena del formato indicado (f=flotante,s=científico,e=ingeniero).',p:'Real,Str("f4"||"s5"||"e6")'},
    'fourier':{d:'',p:'Expr(f(x)),[Var(x),[Var(s)]]'},
    'fourier_an':{d:'Devuelve el coeficiente n-ésimo de Fourier an=2/T*integrate(f(x)*cos(2*pi*n*x/T),a,a+T).',p:'Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)'},
    'fourier_bn':{d:'Devuelve el coeficiente n-ésimo de Fourier bn=2/T*integrate(f(x)*sin(2*pi*n*x/T),a,a+T).',p:'Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)'},
    'fourier_cn':{d:'Devuelve el coeficiente n-ésimo de Fourier cn=2/T*integrate(f(x)*exp(-2*i*pi*n*x/T),a,a+T).',p:'Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)'},
    'fprint':{d:'Escribe en el archivo f algunos datos.',p:'File(f),Var,[Var,Var...]'},
    'fracmod':{d:'Devuelve la fracción a/b tal que b*Xpr=a mod n, -sqrt(n)/2<a<=sqrt(n)/2 y 0<=b<sqrt(n)/2.',p:'Expr(Xpr),Intg(n)',a:['iratrecon']},
    'frame_2d':{d:'frame_2d()',p:'NULL'},
    'frame_3d':{d:'frame_3d()',p:'NULL'},
    'frames':{d:'Opción de animate y animate3d para dar la cantidad de imágenes.',p:'Opt',a:['trames']},
    'frank_wolfe':{d:'',p:'Expr(f),Mtrx(A),[opts]'},
    'frenet':{d:'',p:'[X(t),Y(t)],t,[t0]'},
    'frequencies':{d:'Devuelve las frecuencias.',p:'Lst'},
    'frobenius_norm':{d:'',p:'Mtrx'},
    'froot':{d:'Devuelve la lista de raíces y polos de F con su multiplicidad.',p:'RatPoly(F)'},
    'fsolve':{d:'Resolución numérica de una ecuación o de un sistema de ecuaciones.',p:'Expr,Var,[Guess or Interval],[Method]'},
    'function':{d:'Instrucción que define una función definida por el usuario.',p:'Fnc(f)',a:['fonction']},
    'function_diff':{d:'Devuelve la función derivada de la función f.',p:'Fnc(f)',a:['fonction_derivee']},
    'fundamental_cycle':{d:'',p:'Graph(G)'},
    'gammad':{d:'Devuelve la densidad de probabilidad de la ley Gamma (=x^(a-1)*exp(-b*x)*b^a/Gamma(a)).',p:'Real(a>0),Real(b>0),Real(x>=0)'},
    'gammad_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según la ley Gamma sea menor que x0 o entre x0 y y0.',p:'Real(a>0),Real(b>0),Real(x0>=0),[Real(y0>=0)]'},
    'gammad_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria Gamma sea menor que h es p (0<=p<=1).',p:'Real(a>0),Real(b>0),Real(0<=p<=1)'},
    'gauss':{d:'Descompone una forma cuadrática como suma/diferencia de cuadrados',p:'Expr,VectVar'},
    'gauss_seidel_linsolve':{d:'',p:'[Real(omega)],Mtrx(A),Vect(b),Real(eps),[Int(maxiter)]'},
    'gaussian_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'gaussquad':{d:'Devuelve el valor aproximado de integrate(f(x),x,a,b)  por el método de Gauss.',p:'Expr(f(x)),Var(x),Real(a),Real(b)'},
    'gbasis':{d:'Base Groebner del ideal generado por la lista de polinomios.',p:'LstPoly,LstVar,[order]'},
    'gbasis_max_pairs':{d:'',p:'Intg'},
    'gbasis_reinject':{d:'',p:'Real(a),[Real(b)]'},
    'gbasis_simult_primes':{d:'',p:'Intg'},
    'gbasis_vars':{d:'',p:'List'},
    'gcd':{d:'Devuelve el máximo común divisor de 2 polinomios de varias variables o de 2 enteros de 2 racionales.',p:'(Intg(a) or Poly),(Intg(b) or Poly)',a:['igcd']},
    'genpoly':{d:'Devuelve la reconstrucción de un polinomio Q(-b/2<=coef<=b/2) de n variables a partir de un polinomio P de (n-1) variables y base b (subst(Q,var=b)=P).',p:'Poly(P),Intg(b),Var'},
    'geodetic2ecef':{d:'',p:'Real(latitude),Real(longitude),Real(height)'},
    'geometric':{d:'Devuelve la densidad de probabilidad de la ley de geometric (0<p<1).',p:'Real(p),Intg(k)'},
    'geometric_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley geometric sea menor que k.',p:'Real(p),Intg(k),[Intg(m)]'},
    'geometric_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según ley geometric sea menor que h es x (0<=x<=1).',p:'Real(p),Real(x)'},
    'getDenom':{d:'Devuelve el denominador de la expresión no simplificada.',p:'Expr'},
    'getKey':{d:'Instrucción en un programa, devuelve 0 si no pulsa ninguna tecla, y si no, devuelve el código ascii de la tecla pulsada.',p:'NULL'},
    'getNum':{d:'Devuelve el numerador de la expresión no simplificada.',p:'Expr'},
    'getType':{d:'Devuelve el tipo del argumento (STR,EXPR,FUNC,NUM,LIST,MAT,VAR,NONE,PIC...).',p:'Expr'},
    'get_edge_attribute':{d:'',p:'Graph(G),Edge(e),Seq(tag1=value1,tag2=value2,..)'},
    'get_edge_weight':{d:'',p:'Graph(G),Edge(e)'},
    'get_graph_attribute':{d:'',p:'Graph(G),Seq(tag1=value1,tag2=value2,..)'},
    'get_vertex_attribute':{d:'',p:'Graph(G),Vrtx(v),Seq(tag1=value1,tag2=value2,..)'},
    'girth':{d:'',p:'Graph(G)'},
    'gl_ortho':{d:'Opción global que permite definir el ortonormal gráfico.',p:'Opt=Interval'},
    'gl_quaternion':{d:'Opción que permite definir el cuaternión para la visualización de escenas 3-d (no compatible con la interactividad)',p:'Opt=Lst'},
    'gl_rotation':{d:'Opción global que permite definir el eje de rotación para las animaciones por rotación en escenas 3-d.',p:'Opt=NameFich'},
    'gl_showaxes':{d:'Opción que permite mostrar o esconder los ejes.',p:'Opt=Boolean'},
    'gl_shownames':{d:'Opción que permite mostrar o esconder el nombre de objetos geométricos.',p:'Opt=Boolean'},
    'gl_texture':{d:'Opción que permite poner una imagen sobre los rectángulos de lados paralelos a los ejes en 2-d y sobre las superficies en 3-d o que permite poner un fondo sobre un gráfico 2-d.',p:'Opt=NameFich'},
    'gl_x':{d:'Opción global que permite definir el encuadre del gráfico.',p:'Opt=Interval',a:['gl_y','gl_z']},
    'gl_x_axis_color':{d:'Opción global que permite definir de manera individual los colores de los ejes x, (o y, o z) (negro=0 rojo=1 verde=2 amarillo=3 azul=4).',p:'Opt=Intg',a:['gl_y_axis_color','gl_z_axis_color']},
    'gl_x_axis_name':{d:'Opción global que permite definir de manera individual los nombre de los ejes x, (o y, o z).',p:'Opt=Str',a:['gl_y_axis_name','gl_z_axis_name']},
    'gl_x_axis_unit':{d:'Opción global que permite definir de manera individual los nombres de unidad sobre los ejes x, (o y, o z).',p:'Opt=Str',a:['gl_y_axis_unit','gl_z_axis_unit']},
    'gl_xtick':{d:'Opción globalque permite definir el intervalo de marcas sobre el eje x (resp. y, z).',p:'Opt=Real',a:['gl_ytick','gl_ztick']},
    'gnuplot':{d:'Ejecuta una instrucción en el proceso gnuplot (ventana 3-d).',p:'Str'},
    'goldberg_snark':{d:'',p:'Intg(n)'},
    'goto':{d:'En un programa, se usa para saltar a la instrucción con la etiqueta nom.',p:'Var(nom)'},
    'grad':{d:'Devuelve el gradiente de Xpr',p:'Expr(Xpr),LstVar'},
    'gramschmidt':{d:'Devuelve una base ortonormal de E de base B para el producto escalar Sp',p:'Basis(B),ScalarProd(Sp)'},
    'graph':{d:'',p:'[Lst(V)],[Set(E)],[Mtrx(A)],[options]'},
    'graph2tex':{d:'Convierte el gráfico en archivo LaTeX',p:'[Str("filename")]'},
    'graph3d2tex':{d:'Convierte el gráfico 3D en archivo LaTeX',p:'[Str"filename")]'},
    'graph_automorphisms':{d:'',p:'Graph(G)'},
    'graph_charpoly':{d:'',p:'Graph(G),[Var(x)]'},
    'graph_complement':{d:'',p:'Graph(G)'},
    'graph_diameter':{d:'',p:'Graph(G)'},
    'graph_equal':{d:'',p:'Graph(G1),Graph(G2)'},
    'graph_join':{d:'',p:'Graph(G),Graph(H)'},
    'graph_power':{d:'',p:'Graph(G),Intg(k)'},
    'graph_rank':{d:'',p:'Graph(G),[Lst(E)]'},
    'graph_spectrum':{d:'',p:'Graph(G)'},
    'graph_union':{d:'',p:'Seq(G1,G2,...)'},
    'graph_vertices':{d:'',p:'Graph(G)'},
    'greduce':{d:'Devuelve el resto de la división de un polinomio por una base Groebner.',p:'Poly,LstPoly,LstVar,[order]'},
    'greedy_clique':{d:'',p:'Graph(G),[Intg(n)]'},
    'greedy_color':{d:'',p:'Graph(G),[Permu(p)]'},
    'greedy_independent_set':{d:'',p:'Graph(G),[Intg(n)]'},
    'grid_graph':{d:'',p:'Intg(m),Intg(n),[triangle]'},
    'grid_paper':{d:'Traza las filas de la red formada por las rectas y=n*uy e en los ejes OxY de ángulo t!=0 las rectas x=n*ux.',p:'Real(ux),Real(t),Real(uy),[x=xmin..xmax,y=ymin..ymax]'},
    'groupermu':{d:'Devuelve el grupo de permutaciones generado por a y b.',p:'Permut(a),Permut(b)'},
    'haar_graph':{d:'',p:'Intg(n)'},
    'hadamard':{d:'Realiza el producto término a término de 2 matrices',p:'Mtrx,Mtrx'},
    'half_cone':{d:'Traza un medio-cono con cumbre A, dirección v, y con medio_ángulo t en la cumbre [y con altura h].',p:'Pnt(A),Vect(v),Real(t),[Real(h)]'},
    'half_line':{d:'half_line(A,B) traza la media-recta AB con origen A.',p:'(Pnt or Cplx),(Pnt or Cplx)'},
    'halftan':{d:'Transforma sin(x),cos(x) y tan(x) como funciones de tan(x/2).',p:'Expr'},
    'halftan_hyp2exp':{d:'Transforma las funciones trigonométricas en tan(x/2) y las funciones hiperbólicas en exp',p:'ExprTrig'},
    'halt':{d:'Pone un programa en modo de depuración paso a paso',p:'NULL'},
    'hamdist':{d:'Distancia de Hamming bit a bit.',p:'Intg,Intg'},
    'hamming':{d:'',p:'Str(s1)||Lst(s1),Str(s2)||Lst(s2)'},
    'hamming_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'hann_poisson_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'hann_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'harmonic_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'harmonic_conjugate':{d:'Devuelve el conjugado armónico C con respecto A y B de 3 puntos alineados o de 3 rectas paralelas o concurrentes , o la polar de un punto con respecto a 2 rectas.',p:'Line or Pnt(A),Line or Pnt(B),Line or Pnt(C)'},
    'harmonic_division':{d:'Devuelve 4 puntos (resp rectas) y guarda en el último argumento, tal que los 4 puntos (resp rectas) formen una división armónica.',p:'Pnt or Line,Pnt or Line,Pnt or Line,Var'},
    'has':{d:'Comprueba si una variable está en una expresión',p:'Expr,Var'},
    'has_arc':{d:'',p:'Graph(G),Edge(e)'},
    'has_edge':{d:'',p:'Graph(G),Edge(e)'},
    'hasard':{d:'(hasard n)=un número (resp hasard(p,n)=un número real o hasard(p..n)=una función real) aleatorio distribuido en 0..n-1 (resp en [p;n]) (hasard =(hasard 0,1)) o nhasard(n,b1,b2)= enteros entre b1 y b2 o hasard(n,L)=n elementos de L. Si hasard tiene un sólo arguemnto, no se tiene que poner () (compatibilidad lenguaje tortuga).',p:'Intg(n) or Interval(p..n) or NULL,[Intg(b1) or Lst(L)],[Intg(b2)]'},
    'head':{d:'Muestra el primer elemento de un vector o secuencia o cadena.',p:'Vect or Seq or Str'},
    'heapify':{d:'',p:'List'},
    'heappop':{d:'',p:'List'},
    'heappush':{d:'',p:'List,Object'},
    'hermite':{d:'Devuelve el polinómio de Hermite de grado n',p:'Intg(n)||Matr(A)'},
    'hessenberg':{d:'Reducción matricial bajo forma de Hessenberg.',p:'Mtrx(A),[Intg(n)]'},
    'hessian':{d:'Devuelve el hessiano de Xpr',p:'Expr(Xpr),LstVar'},
    'heugcd':{d:'MCD de 2 polinomios, con el algoritmo pgcd heurístico.',p:'Poly,Poly'},
    'hexagon':{d:'Devuelve y traza el hexágono de lado AB (ABCD es directo) (en el plan ABP).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,[Pnt(P)],[Var(C)],[Var(D)],[Var(E)],[Var(F)]'},
    'hht':{d:'',p:'Lst(data)||Mtrx(imf),[opts]'},
    'hidden_name':{d:'Opción de la instrucción display para esconder el nombre.',p:'Opt'},
    'highlight_edges':{d:'',p:'Graph(G),Edge(e)||Lst(E),[Color(c)||Lst(C)]'},
    'highlight_subgraph':{d:'',p:'Graph(G),Graph(S)||Lst(S1,S2,..),Seq(c1,c2)'},
    'highlight_trail':{d:'',p:'Graph(G),Trail(t)||Lst(T),[Color(c)||Lst(C)]'},
    'highlight_vertex':{d:'',p:'Graph(G),Vrtx(v)||Lst(V),[Color(c)||Lst(C)]'},
    'highpass':{d:'',p:'Lst(s),Real(c),[Intg(samplerate)]'},
    'hilbert':{d:'Devuelve la matriz n-ésima de Hilbert: Hjk=1/(j+k+1) j,k=1..n',p:'Intg(n)||(Expr(f),[Var(x)])||Lst(u)'},
    'histogram':{d:'Traza el histograma del argumento.',p:'Lst(data),[Lst(eff) || Intg(nc) || Real(classmin)],[Real(classsize)]'},
    'homogeneize':{d:'',p:'Expr(P),[Var(t)]'},
    'homothety':{d:'homothety(C,k,A)=punto A1 tal que vect(C,A1)=k*vect(C,A) es decir, en 2o es la semejanza de centro C, de coeficiente abs(k) y de ángulo arg(k).',p:'Pnt(C),Real(k),Pnt(A)'},
    'horner':{d:'Devuelve el valor de P(a) calculado según el método de Horner.',p:'Poly(P),Real(a)'},
    'hsv':{d:'',p:'Lst(h,s,v)||Color(c)'},
    'hsv2rgb':{d:'',p:'Lst(h,s,v)'},
    'hyp2exp':{d:'Transforma las funciones hiperbólicas en exponenciales',p:'ExprHyperb'},
    'hyperbola':{d:'hyperbola(F1,F2,M)=hipérbola de focos F1,F2 y pasa por M (o |MF1-MF2|=2*a geo2d) y hyperbola(p(x,y))=conic si deg(p)=2.',p:'Focus(F1),Focus(F2),(Pnt(M) or Real(a))'},
    'hypercube_graph':{d:'',p:'Intg(n)'},
    'i':{d:'Raíz cuadrada de -1'},
    'iPart':{d:'Devuelve el argumento sin su parte fraccional (type=DOM_FLOATNUM).',p:'Real||LstReal'},
    'i[]':{d:'i[] definido uno intervalo real(i[a,b]=[a..b]).',p:'Seq(a,b)',a:['[..]']},
    'iabcuv':{d:'Devuelve [u,v] tales que au+bv=c para 3 enteros a,b,c.',p:'Intg(a),Intg(b),Intg(c)'},
    'ibasis':{d:'Base de la intersección de dos espacios vectoriales',p:'Lst(Vect,..,Vect),Lst(Vect,..,Vect)'},
    'ibpdv':{d:'Integración por partes de f(x)=u(x)*v\'(x) con f(x) como 1º argumento y v(x) (o 0) como 2º argumento. Hay que especificar la variable de integración y cálculo de la integral (entre a y b).',p:'Expr(f(x)),Expr(v(x)),[Var(x)],[Real(a)],[Real(b)]'},
    'ibpu':{d:'Integración por partes con f(x)=u(x)*v\'(x) con f(x) como 1º argumento y u(x) (o 0) como 2º argumento. Hay que especificar la variable de integración y cálculo de la integral (entre a y b).',p:'Expr(f(x)),Expr(u(x)),[Var(x)],[Real(a)],[Real(b)]'},
    'icdf':{d:'',p:'Func,FuncParams'},
    'ichinrem':{d:'Restos chinos de enteros.',p:'LstIntg(a,p),LstIntg(b,q)',a:['ichrem']},
    'icomp':{d:'',p:'Intg(n),Intg(k),[zeros=true||false]'},
    'icontent':{d:'MCD de los coeficientes enteros de un polinomio.',p:'Poly,[Var]'},
    'icosahedron':{d:'Traza un icosaedro de centro A, vértice B donde el plano ABC contiene el vértice más cercano (dentro de los 5) de B.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'id':{d:'Es el nombre de la función identidad (ℝ^n -> ℝ^n).',p:'Seq'},
    'identify_graph':{d:'',p:'Graph(G)'},
    'identity':{d:'Devuelve la matriz identidad de la dimensión especificada n.',p:'Intg(n)',a:['idn']},
    'idivis':{d:'Devuelve la lista de divisores de un entero.',p:'Intg(a) or LstIntg',a:['divisors']},
    'idwt':{d:'',p:'(Lst||Mtrx)(T),[opts]'},
    'iegcd':{d:'Identidad de Bézout de 2 enteros.',p:'Intg,Intg',a:['igcdex','bezout_entiers']},
    'if':{d:'Test: if (condition){ true_action; } else { false_action; }'},
    'ifactor':{d:'Factorización de un entero en factores primos.',p:'Intg(a)',a:['factoriser_entier']},
    'ifactors':{d:'Devuelve la lista de factores primos de un entero y su orden de multiplicidad .',p:'Intg(a) or LstIntg',a:['facteurs_premiers']},
    'ifft':{d:'Inverse Fast Fourier Transform.',p:'Vect'},
    'ifourier':{d:'',p:'Expr(F(s)),[Var(s),[Var(x)]]'},
    'ifte':{d:'Si condición devuelve Expr1 sino devuelve Expr2.',p:'Cond,Expr1,Expr2',a:['IFTE']},
    'igamma':{d:'Calcula los valores de la función gamma en el punto (a,x). Si a,x>0, igamma(a,x)=int(e^{-t}*t^{a-1},t=0..x), (igamma(a,x,1)=igamma(a,x)/Gamma(a)).',p:'Real(a),Real(x),[1]'},
    'ihermite':{d:'Calcula la forma normal de Hermite para una matriz A con coeficientes enteros : devuelve L,U tales que L sea invertible en ℤ, U triang sup y U=L*A.',p:'Mtrx(A)'},
    'ilaplace':{d:'Anti-Transformada de Laplace de una fracción racional',p:'Expr,[Var],[IlapVar]',a:['invlaplace']},
    'im':{d:'Devuelve la parte imaginaria de un número complejo',p:'Cplx',a:['imag']},
    'image':{d:'Imagen de una aplicación lineal de matriz M',p:'Mtrx(M)||Strng(imgfname)'},
    'imfplot':{d:'',p:'Lst(imf),[opts]',a:['plotimf']},
    'implicitdiff':{d:'',p:'constr,[depvars],y,diffvars'},
    'import_graph':{d:'',p:'Str("filename"),[opts]'},
    'in':{d:'Iteración for ...end_for en uno conjunto o una lista.'},
    'inString':{d:'Comprueba si e está en la cadena l (devuelve -1, o k si l[k]=e).',p:'Str(l),Elem(e)'},
    'in_ideal':{d:'',p:'Poly,Lst,LstVar,[order]'},
    'incenter':{d:'',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'incidence_matrix':{d:'',p:'Graph(G)'},
    'incident_edges':{d:'',p:'Graph(G),Vrtx(v)'},
    'incircle':{d:'incircle(A,B,C) dibuja la circunferencia inscrita en el triángulo ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'increasing_power':{d:'',p:':=Intg(0 or 1)'},
    'independence_number':{d:'',p:'Graph(G)'},
    'index':{d:'',p:'Vect,Expr'},
    'induced_subgraph':{d:'',p:'Graph(G),Lst(V)'},
    'inertia':{d:'',p:'Mtrx(A),[B,[p0]]'},
    'infinity':{d:'Infinito, sin signo'},
    'information_centrality':{d:'',p:'Graph(G),[Vrtx(v)],[approx]'},
    'input':{d:'Instrucción en un programa que permite introducir una expresión y guardarla en var.',p:'[Str],Var(Var)',a:['Input','lis']},
    'inputform':{d:'En un programa, utilizado para hacer entradas.',p:'[Str],Var,[Str],[Var],[Str],[Var]'},
    'insert':{d:'Devuelve l donde el elemento b es de índice n.',p:'Vect(l)||Str(l),Intg(n),Val(b)'},
    'insmod':{d:'Instala un módulo dinámico creando los comandos que están, por ejemplo, en el fichero libprogfr.so poniendo la dirección de este archivo.',p:'Str(pwd)'},
    'instfreq':{d:'',p:'Vect(u)||Expr(u),[Var(x)]'},
    'instphase':{d:'',p:'Vect(u)||Expr(u),[Var(x)]'},
    'int':{d:'Integral indefinida, hay que especificar la variable de integración (entre a y b).',p:'Expr,[Var(x)],[Real(a)],[Real(b)]',a:['integrate','integrer']},
    'inter':{d:'Devuelve la intersección de 2 cruvas o superficies como un vector o un punto cercano de al tercero argumentole argumento.',p:'Curve,Curve,[Pnt|Lst]'},
    'interactive_plotode':{d:'Traza (en DispG) una solución para cada punto t0+i*y0 designado por el ratón (Esc=interrumpir).',p:'Expr,VectVar',a:['interactive_odeplot']},
    'interp':{d:'',p:'Lst(colors)||Seq(Image(A),Image(B)||Color(c))||Seq(Lst(x0),Lst(y0),Lst(x))||Seq(Lst(x),Lst(y))'},
    'intersect':{d:'intersect es un operador infijo para obtener la intersection de 2 conjuntos.',p:'(Vect or Set),(Vect or Set)'},
    'interval':{d:'Opción del comando convert o convertir.',p:'Opt'},
    'interval2center':{d:'Devuelve el centro del intervalo o el objeto.',p:'Interval or Real'},
    'interval_graph':{d:'',p:'Seq||Lst(a..b,c..d,...)'},
    'inv':{d:'Devuelve la inversa de una matriz o de una expresión.',p:'Expr||Mtrx||Image||Audio',a:['inverse']},
    'inversion':{d:'inversion(C,k,A)=punto A1 tal que A1 en line(C,A) y mes_alg(CA1*CA)=k',p:'Pnt(C),Real(k),Pnt(A)'},
    'invztrans':{d:'Anti-Transformada z de una fracción racional',p:'Expr,[Var],[InvZtransVar]'},
    'iquo':{d:'Cociente euclídeo de 2 enteros.',p:'Intg(a),Intg(b)',a:['intDiv']},
    'iquorem':{d:'Cociente euclídeo y resto de 2 enteros.',p:'Intg(a),Intg(b)',a:['divmod']},
    'irem':{d:'Resto euclídeo de 2 enteros.',p:'Intg(a),Intg(b)',a:['remain']},
    'is_acyclic':{d:'',p:'Graph(G)'},
    'is_arborescence':{d:'',p:'Graph(G)'},
    'is_biconnected':{d:'',p:'Graph(G)'},
    'is_bipartite':{d:'',p:'Graph(G),[Var(P)]'},
    'is_clique':{d:'',p:'Graph(G)'},
    'is_collinear':{d:'Devuelve 1 si los puntos están alineados, 2 si los puntos están confundidos y 0 si no.',p:'LstPnt'},
    'is_concyclic':{d:'Devuelve 1 si los 4 puntos forman una circunferencia, y 0 si no.',p:'LstPnt'},
    'is_conjugate':{d:'Devuelve 1 si los 3 (resp 4) argumentos son conjugados con respecto a la circunferencia (resp 2 rectas) y 0 si no.',p:'Crcle||Line,Pnt||Line,Pnt||Line,[Pnt||Line]'},
    'is_connected':{d:'',p:'Graph(G)'},
    'is_coplanar':{d:'Verifica si 4 puntos son coplanares.',p:'Pnt,Pnt,Pnt,Pnt'},
    'is_cospherical':{d:'Verifica si 5 puntos son coesferares.',p:'Pnt,Pnt,Pnt,Pnt'},
    'is_cut_set':{d:'',p:'Graph(G),Lst(E)'},
    'is_cycle':{d:'Deveulve 1 si el argumento es un ciclo y 0 si no.',p:'Lst'},
    'is_directed':{d:'',p:'Graph(G)'},
    'is_element':{d:'Devuelve 1 si el punto está sobre el objeto geométrico y 0 si no.',p:'Pnt,GeoObj'},
    'is_equilateral':{d:'Devuelve 1 si los 3 puntos (o el objeto) forman un triángulo equilátero y 0 si no.',p:'Pnt||Cplx,Pnt||Cplx,Pnt||Cplx'},
    'is_eulerian':{d:'',p:'Graph(G),[Var(T)]'},
    'is_forest':{d:'',p:'Graph(G)'},
    'is_graphic_sequence':{d:'',p:'Lst(L)'},
    'is_hamiltonian':{d:'',p:'Graph(G),[Var(hc)]'},
    'is_harmonic':{d:'Devuelve 1 si los 4 puntos forman una división armónica y 0 si no.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_harmonic_circle_bundle':{d:'Devuelve 1 si las circunferencias forman un haz, 2 si son concéntricos, 3 si son iguales y 0 si no.',p:'Lst(Crcle)'},
    'is_harmonic_line_bundle':{d:'Devuelve 1 si las rectas tienen un punto en común, 2 si son paralelas, 3 si son iguales y 0 si no.',p:'Lst(Line)'},
    'is_included':{d:'Verifica si una lista o conjunto es en una lista o conjunto.',p:'Lst||Ens,Lst||Ens'},
    'is_inside':{d:'Comprueba si un punto está en un polígono o circunferencia.',p:'Pnt,Polygon or Circle'},
    'is_integer_graph':{d:'',p:'Graph(G)'},
    'is_irreducible':{d:'',p:'Polynomial'},
    'is_isomorphic':{d:'',p:'Graph(G1),Graph(G2),[Var(I)]'},
    'is_isosceles':{d:'Devuelve 1,2 o 3 si los 3 puntos (o el objeto) forman un triángulo isósceles con vértices 1, 2, o 3, devuelve 4 si los 3 puntos (o el objeto) forman un triángulo equilátero y 0 si no.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_network':{d:'',p:'Graph(G),[Vrtx(s),Vrtx(t)]'},
    'is_orthogonal':{d:'Devuelve 1 si las 2 circunferencias son perpendiculares (tangentes ortogonales en un punto de intersección) o si las dos rectas son ortogonales y 0 si no.',p:'Line||Crcle,Line||Crcle'},
    'is_parallel':{d:'Devuelve 1 si 2 líneas son paralelas y 0 si no.',p:'Line or Plan ,Line or Plan'},
    'is_parallelogram':{d:'Devuelve 1,2,3 o 4 si los 4 puntos (o el objeto) forman una paralelogramo, (2 para un rombo, 3 para una rectángulo y 4 para un cuadrado) y 0 si no.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_permu':{d:'Devuelve 1 si el argumento es una permutación y 0 si no',p:'Lst',a:['est_permu']},
    'is_perpendicular':{d:'Devuelve 1 si dos líneas son perpendiculares',p:'Line or Plan,Line or Plan'},
    'is_planar':{d:'',p:'Graph(G)'},
    'is_prime':{d:'Test mixed/"p-1" Pocklington [1]/ APRCL [2] (devuelve los coeficientes demostrando la primalidad, 1 o 0)',p:'Intg,[1 || 2]'},
    'is_pseudoprime':{d:'Test de pseudo-primalidad (0 no primo, 1 probablemente primo, 2 primo)',p:'Intg'},
    'is_reachable':{d:'',p:'Graph(G),Vrtx(u),Vrtx(v)'},
    'is_rectangle':{d:'Devuelve 1, 2 o 3 si los 3 puntos (o el objeto) forman un triángulo rectángulo con vértices 1, 2 o 3 y 0 si no [o 1 si los 4 puntos (o el objeto) forman un rectángulo, 2 si los 4 puntos (o el objeto) forman un cuadrado y 0 si no].',p:'Pnt||Cplx,Pnt||Cplx,Pnt||Cplx,[Pnt||Cplx]'},
    'is_regular':{d:'',p:'Graph(G)'},
    'is_rhombus':{d:'Devuelve 1 o 2 si los 4 puntos (o el objeto) forman un rombo (2 para un cuadrado) y 0 si no.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_split_graph':{d:'',p:'Graph(G),[part]'},
    'is_square':{d:'Devuelve 1 si los 4 puntos (o el objeto) forman una cuadrado y 0 si no.',p:'Pnt,Pnt,Pnt,Pnt'},
    'is_strongly_connected':{d:'',p:'Graph(G)'},
    'is_strongly_regular':{d:'',p:'Graph(G),[Var(srg)]'},
    'is_subgraph_isomorphic':{d:'',p:'Graph(G1),Graph(G2),[opts]'},
    'is_tournament':{d:'',p:'Graph(G)'},
    'is_tree':{d:'',p:'Graph(G)'},
    'is_triconnected':{d:'',p:'Graph(G)'},
    'is_two_edge_connected':{d:'',p:'Graph(G)'},
    'is_vertex_colorable':{d:'',p:'Graph(G),Intg(k),[Var(col)]'},
    'is_weighted':{d:'',p:'Graph(G)'},
    'isinf':{d:'',p:'Expr'},
    'ismith':{d:'Calcula la forma normal de Smith de una matriz a coeficientes enteros: devuelve U,B,V tales que U y V invertibles en ℤ, B diagonal, B[j,j] divide a B[j+1,j+1] y B=U*A*V.',p:'Mtrx(A)'},
    'isnan':{d:'',p:'Expr'},
    'isobarycenter':{d:'isobarycenter(A,B,C,....) traza el isobaricentro de n puntos A,B,C,...',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'isolve':{d:'',p:'Eqn||List(Eqn),[Intg(n)||(Idnt(Z1),Idnt(Z2),...)]'},
    'isom':{d:'Encuentra los elementos de un isometría 2-d y 3-d',p:'Mtrx'},
    'isomorphic_copy':{d:'',p:'Graph(G),Permu(sigma)'},
    'isopolygon':{d:'Traza un polígono regular con abs(n) vértices, dado si n>0 por 2 vértices (o 2 vértices y 1 punto del plano) y dado si n<0 por su centro y 1 vértice (o centro, 1 vértice y 1 punto del plano).',p:'Pnt,Pnt,[Pnt],Intg(n)'},
    'isosceles_triangle':{d:'Traza el triángulo isósceles ABC AB=AC y angle(AB,AC)=t (o en el plan ABP angle(AB,AC)=angle(AB,AP) o angle(AB,AC)=t).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Angle(t) or Pnt(P) or Lst(P,t)),[Var(C)]'},
    'isposdef':{d:'',p:'Mtrx(A)'},
    'isprime':{d:'Test de primalidad (=true o false).',p:'Intg(a)',a:['isPrime']},
    'istft':{d:'',p:'Mtrx(data)'},
    'ithprime':{d:'Devuelve el n-ésimo número primo menor que 2.10^810000 (por ahora).',p:'Intg(n)'},
    'jacobi_equation':{d:'',p:'Expr(f),Var(x),Var(y),Expr(y0),Var(h),Real(a)'},
    'jacobi_linsolve':{d:'',p:'Mtrx(A),Vect(b),Real(eps),[Int(maxiter)]'},
    'jacobi_symbol':{d:'Símbolo de Jacobi',p:'Intg,Intg'},
    'johnson_graph':{d:'',p:'Intg(n),Intg(k)'},
    'join':{d:'',p:'Str(sep),Lst(strlst)'},
    'jordan':{d:'Devuelve la lista formada por la matriz de pasaje y la forma de Jordan de una matriz.',p:'Mtrx'},
    'jusque':{d:'Utilizado en una bucle pour o for (for...from ...to...[step...] do...od;).',a:['to']},
    'katz_centrality':{d:'',p:'Graph(G),Real(alpha),[Vrtx(v)]'},
    'keep_algext':{d:'',p:':=Intg(0 or 1)'},
    'keep_pivot':{d:'Opción de rref.',p:'Opt'},
    'ker':{d:'Núcleo de una aplicación lineal de matriz M',p:'Mtrx',a:['kernel','nullspace']},
    'kernel_density':{d:'',p:'Lst(L),[options]',a:['kde']},
    'kill':{d:'Para la ejecución paso a paso de un programa',p:'NULL',a:['tuer']},
    'kmeans':{d:'',p:'Mtrx||Lst(data),[opts]'},
    'kneser_graph':{d:'',p:'Intg(n),Intg(k)'},
    'kolmogorovd':{d:'',p:'Real(x)'},
    'kolmogorovt':{d:'',p:'Lst(l1),Lst(l2) || DistribLaw(s)'},
    'kovacicsols':{d:'',p:'Expr||Lst(eq),[Var(x),[Var(y)]]'},
    'kspaths':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t),Intg(k)'},
    'l1norm':{d:'Devuelve la norma l1 del vector=suma de los valores absolutos de sus coordenadas o matrix_norm.',p:'Vect'},
    'label':{d:'En un programa, se usa para marcar una instrucción con la etiqueta nom.',p:'Var(nom)'},
    'labels':{d:'labels=["u","v"] renombra los ejes en "u" y "v".',p:'Cplx or Lst,Str'},
    'lagrange':{d:'Devuelve el polinomio de grado n-1 tal que P(xk)=yk=f(x_k) k=0..n-1',p:'(Lst_xk,Lst_yk)||Mtrx_2*n||(Lst_xk,Fnc(f)),[Var||[]||lagrange]'},
    'laguerre':{d:'Devuelve el n-ésimo polinomio de Laguerre',p:'Intg(n)'},
    'laplace':{d:'Transformada de Laplace',p:'Expr,[Var],[LapVar]'},
    'laplacian':{d:'Calcula el laplaciano de Xpr con respecto a la lista de variables',p:'Expr(Xpr),LstVar'},
    'laplacian_matrix':{d:'',p:'Graph(G),[normal]'},
    'latex':{d:'Devuelve la expresión evaluada escrita en LaTeX.',p:'Expr',a:['TeX']},
    'lcf_graph':{d:'',p:'Lst(J),[Intg(k)]'},
    'lcm':{d:'Devuelve el mínimo común múltiplo de 2 polinomios de n variables o de 2 enteros o de 2 racionales.',p:'(Intg or Poly),(Intg or Poly)'},
    'lcoeff':{d:'Devuelve el coeficiente del término de mayor grado de un polinomio (l=leading=dominante).',p:'Poly||Lst'},
    'ldl':{d:'',p:'Mtrx(A),[opts]'},
    'left':{d:'Devuelve la parte izquierda de una igualdad, de un intervalo, de una lista o de una cadena.',p:'Equal(a=b) or Interval(a..b) or Str,Intg',a:['lhs','gauche']},
    'legend':{d:'legend(za,"aqui") (o legend([20,60],"aqui")) "aqui" está escrito en el punto de afijo za (o en la posición [20,60] en pixel) y legend=["m","s"] escribe "m","s" como unidad en los ejes.',p:'Cplx or Lst,Str'},
    'legendre':{d:'Devuelve el n-ésimo polinomio de Legendre',p:'Intg(n)'},
    'legendre_symbol':{d:'Símbolo de Legendre.',p:'Intg,Intg'},
    'leve_crayon':{d:'Levanta el lápiz para que la tortuga mueva sin dejar marcas.',p:'NULL',a:['penup']},
    'levenshtein':{d:'',p:'Str(s1)||Lst(s1),Str(s2)||Lst(s2)'},
    'lgcd':{d:'Devuelve el máximo común divisor de una lista de polinomios o de enteros',p:'Seq or Lst'},
    'limit':{d:'Límite de una expresión en un punto (a o +/-infinity)(d=-1 o +1).',p:'Expr,Var,Val,[Dir(d)]',a:['limite']},
    'lin':{d:'Linealización de exponenciales',p:'Expr',a:['lineariser']},
    'linabs':{d:'',p:'Expr,[Var]'},
    'line':{d:'line(A,B)(resp line(A,slope=m) o line(A,[1,m]) o line(a*x+b*y+c=0) o line(a*x+b*y+c*z+d=0,aa*x+bb*y+cc*z+dd=0 o line(A,u)) traza la recta AB (resp la recta pasando por A y de pendiente m, o vector director u, o de ecuación el argumento) en el plano o el espacio 3D.',p:'Pnt||Cplx||Eq,[Pnt||slope||Var]'},
    'line_graph':{d:'',p:'Graph(G)'},
    'line_paper':{d:'Traza las filas de la red formada por las rectas x=n*ux en los ejes OxY de ángulo t!=0.',p:'Real(ux),Real(t),[x=xmin..xmax,y=ymin..ymax]'},
    'line_segments':{d:'Devuelve la lista de las aristas (1 arista=segment) de un poliedro P.',p:'Polygon or Polyedr(P)'},
    'line_width_1':{d:'Opción de la instrucción display para una línea.',p:'Opt',a:['line_width_2','line_width_3','line_width_4','line_width_5','line_width_6','line_width_7','epaisseur_ligne_1','epaisseur_ligne_2','epaisseur_ligne_3','epaisseur_ligne_4','epaisseur_ligne_5','epaisseur_ligne_6','epaisseur_ligne_7']},
    'linear_interpolate':{d:'Da una muestra regular de una línea polígonal definida por una matriz con 2 líneas.',p:'Mtrx,xmin,xmax,xstep'},
    'linear_regression':{d:'Devuelve los coeficientes a y b de y=a*x+b: la mejor aproximación de la recta cuyas coordenadas son las filas de A (o las 2 listas).',p:'Lst||Mtrx(A),[Lst]'},
    'linear_regression_plot':{d:'Devuelve el gráfico de y=a*x+b: la mejor aproximación de la recta cuyas coordenadas son las filas de A (o las 2 listas).',p:'Lst||Mtrx(A),[Lst]'},
    'linfnorm':{d:'',p:'Mtrx'},
    'linsolve':{d:'Resolución de un sistema de ecuaciones lineales.',p:'LstLinEq,LstVar',a:['resoudre_systeme_lineaire']},
    'linspace':{d:'',p:'Real(a),Real(b),[Int(n)]'},
    'linstep':{d:'',p:'Expr,[Var]'},
    'list':{d:'Opción del comando convert o convertir (n-poly=>list).',p:'Opt'},
    'list2exp':{d:'',p:'List'},
    'list2mat':{d:'Devuelve la matriz de n columnas cuyos términos están dados por l completada posiblemente por 0.',p:'Lst(l),Intg(n)'},
    'list_edge_attributes':{d:'',p:'Graph(G),Edge(e)'},
    'list_graph_attributes':{d:'',p:'Graph(G)'},
    'list_vertex_attributes':{d:'',p:'Graph(G),Vrtx(v)'},
    'listplot':{d:'Traza la linea polígonal vinculando los puntos de abscisa 0,...,n y de ordenada l=[y0,...,yn] o la linea vinculando los puntos de abscisa la primera columna de M y de ordenadas la segundo columna.',p:'Lst(l)||Mtrx(M)',a:['plotlist']},
    'lll':{d:'(S,A,L,O):=lll(M), base corta de la red generada (L*O=A*M=S).',p:'Mtrx'},
    'ln':{d:'Logaritmo neperiano o Opción del comando convert o convertir (id trig2exp).',p:'Expr or Opt',a:['log','LN']},
    'lname':{d:'Lista de las variables de una expresión.',p:'Expr',a:['indets']},
    'lncollect':{d:'Aplica ln(a)+n*ln(b)->ln(a*b^n) para n entero.',p:'Expr'},
    'lnexpand':{d:'Desarrolla las expresiones logarítmicas.',p:'Expr'},
    'local':{d:'Definición de variables locales: f(x):={local (var1:=x),var2; instruction;};',a:['var']},
    'locus':{d:'locus(M,A) traza el lugar de M (o locus(d,A) traza la envoltura de d) cuando A:=element(C) (C es una curva). Las instrucciones de los ejemplos abajo, deben ser escritas en un nivel de geometría sobre distintas líneas.',p:'Pnt,Elem'},
    'log10':{d:'Logaritmo en base 10.',p:'Expr'},
    'log2':{d:'',p:'Expr'},
    'logarithmic_regression':{d:'Devuelve los coeficientes a y b de y=a*ln(x)+b: la mejor aproximación logarítmica cuyas coordenadas son las filas de A (o las 2 listas).',p:'Lst||Mtrx(A),[Lst]'},
    'logarithmic_regression_plot':{d:'Devuelve la gráfica de y=a*ln(x)+b: la mejor aproximación logarítmica cuyas coordenadas son las filas de A (o las 2 listas).',p:'Lst||Mtrx(A),[Lst]'},
    'logb':{d:'Logaritmo en base b.',p:'Real,Real'},
    'logistic':{d:'',p:'Real(x),[Real(x0),[Real(L),[Real(k)]]]'},
    'logistic_regression':{d:'Devuelve y,y\',C,y\'max,xmax,R : y es una función logística (sol de y\'/y=a*y+b) tal que y(x0)=y0 y donde el y\' es la mejor aproximación de los valores de L pour x=x0, x0+1...x0+k.',p:'Lst(L),Real(x0),Real(y0)'},
    'logistic_regression_plot':{d:'Devuelve el gráfico de la función logística y tal que y(x0)=y0 y donde el y\' es la mejor aproximación de los valores de L para x=x0, x0+1...x0+k.',p:'Lst(L),Real(x0),Real(y0)'},
    'lower':{d:'',p:'Mtrx||Strng'},
    'lowest_common_ancestor':{d:'',p:'Graph(T),Vrtx(r),Seq(u,v)||Lst([u1,v1],[u2,v2],...)'},
    'lowpass':{d:'',p:'Lst(s),Real(c),[Intg(samplerate)]'},
    'lp_assume':{d:'',p:'Opt',a:['lp_binary','lp_binaryvariables','lp_depthlimit','lp_integer','lp_integervariables','lp_maximize','lp_nonnegative','lp_nonnegint','lp_nodelimit','lp_method','lp_simplex','lp_interiorpoint','lp_maxcuts','lp_gaptolerance','lp_nodeselect','lp_varselect','lp_firstfractional','lp_lastfractional','lp_mostfractional','lp_pseudocost','lp_depthfirst','lp_breadthfirst','lp_bestlocalbound','lp_bestprojection','lp_hybrid','lp_iterationlimit','lp_timelimit','lp_verbose','lp_presolve','lp_heuristic','lp_nonnegint','nonnegint']},
    'lpsolve':{d:'',p:'Expr(o),[List(c)],[bounds],[options]'},
    'lsmod':{d:'Muestra las librerías dinámicas instaladas.',p:'NULL'},
    'lu':{d:'Para una matriz numérica A, devuelve permutación p, L y U tales que PA=LU (P=permu2mat(p)).',p:'Mtrx'},
    'lvar':{d:'Lista de variables de un objeto (con dependencia racional).',p:'Expr'},
    'mRow':{d:'Multiplica la fila n1 de la matriz A por Xpr.',p:'Expr(Xpr),Mtrx(A),Intg(n1)'},
    'mRowAdd':{d:'Multiplica la fila n1 de la matriz A por Xpr, y lo añade a la fila n2.',p:'Expr(Xpr),Mtrx(A),Intg(n1),Intg(n2)'},
    'make_directed':{d:'',p:'Graph(G),[Mrtx(A)]'},
    'make_weighted':{d:'',p:'Graph(G),[Mrtx(M)]'},
    'makelist':{d:'Devuelve una lista hecha a partir de una función o a partir de una constante.',p:'Fnc,InitVal,FinalVal,StepVal'},
    'makemat':{d:'Crea una matriz.',p:'Fnct(f),RowsNumb,ColsNumb'},
    'makesuite':{d:'Devuelve una secuencia a partir de un vector.',p:'Vect||Lst'},
    'makevector':{d:'Devuelve un vector a partir de una secuencia.',p:'Seq'},
    'map':{d:'Aplica la función f a todos los elementos de la lista l o a un polinomio dado en formato interno.',p:'Lst(l),Fnc(f)'},
    'maple2mupad':{d:'maple2mupad("file1","file2") traduce file1(Maple) en file2(MuPAD).',p:'Str("Name_Maplefile"),Str("Name_Mupadfile")'},
    'maple2xcas':{d:'maple2xcas("file1","file2") traduce file1(Maple) en file2(Xcas).',p:'Str("NameMapleFile"),Str("NameXcasFile")'},
    'maple_ifactors':{d:'Devuelve 1 o -1 para el signo y los factores primos con su multiplicidad de n en una matriz como ifactors en Maple.',p:'Intg(n)'},
    'markov':{d:'',p:'Mtrx(M),[Real(eps)]'},
    'mat2list':{d:'Devuelve la lista de términos de la matriz.',p:'Mtrx'},
    'mathml':{d:'Convierte la expresión en una cadena que permite mostrar matemáticas en la web.',p:'Expr'},
    'matpow':{d:'Calcula la potencia n-ésima de una matriz cuadrada por jordanización',p:'Mtrx,Intg(n)'},
    'matrix':{d:'Crea una matriz m(j,k) de p filas y q columnas, m(j,k)=f(j,k) o f(j,k)=a (o opción de apply).',p:'Intg(p),Intg(q),(Fnc(f) or Val(a))'},
    'matrix_norm':{d:'',p:'Mtrx,[2]||[inf]'},
    'max':{d:'Máximo de dos reales.',p:'Seq||Lst'},
    'maxflow':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)'},
    'maximal_independent_set':{d:'',p:'Graph(G)'},
    'maximize':{d:'',p:'Expr,[Constr],Vars,[Options]'},
    'maximum_clique':{d:'',p:'Graph(G)'},
    'maximum_degree':{d:'',p:'Graph(G)'},
    'maximum_independent_set':{d:'',p:'Graph(G)'},
    'maximum_matching':{d:'',p:'Graph(G)'},
    'maxnorm':{d:'Norma del max de un vector (o de una matriz): maxnorm([x1,x2,..,xn])=max(|x1|,..,|xn|).',p:'Vect or Mtrx'},
    'mean':{d:'Promedio de una lista ponderada, con el segundo argumento como peso, o de las columnas de una matriz.',p:'Lst||Mtrx,[Lst]',a:['moyenne']},
    'median':{d:'Devuelve la mediana de una lista, ponderada por el segundo argumento, o de las columnas de una matriz.',p:'Lst||Mtrx,[Lst]'},
    'median_line':{d:'median_line(A,B,C) traza la mediana en A del triángulo ABC',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'member':{d:'Comprueba si e está en la lista o conjunto l (=0, o k+1 con l[k]=e).',p:'Elem(e),(Lst(l) or Set(l))'},
    'mgf':{d:'',p:'Func,[Real(Param_1),Real(Param_2)]'},
    'mid':{d:'Devuelve la lista de n elementos (por defecto n=size(l)-d) extraída de l empezando con el índice d.',p:'Lst(l) or Str(l),Intg(d),Intg(n)'},
    'midpoint':{d:'midpoint(A,B) traza el punto medio del segmento AB',p:'(Pnt or Cplx),(Pnt or Cplx)'},
    'min':{d:'Mínimo de dos reales',p:'Seq||Lst'},
    'minimal_edge_coloring':{d:'',p:'Graph(G),[sto]'},
    'minimal_spanning_tree':{d:'',p:'Graph(G)'},
    'minimal_vertex_coloring':{d:'',p:'Graph(G),[sto]'},
    'minimax':{d:'',p:'Expr,Var=Real(a)..Real(b),Intg(n)||Lst(Intg(n),Intg(m)),[opts]'},
    'minimize':{d:'',p:'Expr,[Constr],Vars,[Options]'},
    'minimum_cut':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)'},
    'minimum_degree':{d:'',p:'Graph(G)'},
    'minimum_vertex_cover':{d:'',p:'Graph(G),[approx]'},
    'minus':{d:'minus es un operador infijo para obtener la diferencia de 2 conjuntos.',p:'(Vect or Set),(Vect or Set)'},
    'mixdown':{d:'',p:'Audio(clip1),(Real||Lst)(parm1),Audio(clip2),(Real||Lst)(parm2),...'},
    'mkisom':{d:'Matriz de una isometría dada por sus elementos propios.',p:'Vect,(Sign(1) or -1)'},
    'mksa':{d:'Convierte las unidades en unidades del sistema internacional MKSA',p:'Unit'},
    'mod':{d:'Operador infijo que devuelve n mod p un número de ℤ/pℤ.',p:'Intg(n),Intg(p)',a:['%']},
    'modf':{d:'',p:'Real(a)'},
    'modgcd':{d:'MCD de 2 polinomios, con el algoritmo modular.',p:'Poly,Poly'},
    'monotonic':{d:''},
    'montre_tortue':{d:'Muestra la tortuga.',p:'NULL'},
    'moving_average':{d:'',p:'Lst(A),Intg(n)'},
    'moyal':{d:'Producto de Moyal de 2 expresiones simbólicas.',p:'Expr,Expr,VectVar'},
    'mult_c_conjugate':{d:'Devuelve la expresión después de multiplicarla por el conjugado del denominador (o del numerador, si no hay denominador).',p:'Expr',a:['multiplier_conjugue_complexe']},
    'mult_conjugate':{d:'Devuelve la expresión después de multiplicarla por el conjugado del denominador (o del numerador, si no hay denominador).',p:'Expr',a:['multiplier_conjugue']},
    'multinomial':{d:'Devuelve n!/(k0!*k1!*..;kj!)*(p0^k0*p1^k1..*pj^kj) (sum(p)=1 et sum(k)=n).',p:'Intg(n),Vect(p),Vect(k)'},
    'multiply':{d:'Devuelve el producto de 2 argumentos.',p:'Intg or Lst, Intg or Lst'},
    'mupad2maple':{d:'mupad2maple("file1","file2") traduce file1(MuPAD) en file2(Maple).',p:'Str("NameMupadFile"),Str("NameMapleFile")'},
    'mupad2xcas':{d:'mupad2xcas("file1","file2") traduce file1(MuPAD) en file2(Xcas).',p:'Str("NameMupadFile"),Str("NameXcasFile")'},
    'mycielski':{d:'',p:'Graph(G)'},
    'nDeriv':{d:'Devuelve una aproximación de la derivada numérica en un punto: (Xpr(var+h)-Xpr(var-h))/(2*h) (por defecto h=0.001).',p:'Expr(Xpr),Var(Var),[Real(h)]'},
    'nSolve':{d:'Resolución numérica de una ecuación o de un sistema de ecuaciones',p:'Expr,Var,[Guess or Interval],[Method]'},
    'negbinomial':{d:'Devuelve comb(n+k-1,k)*p^k*(1-p)^n.',p:'Intg(n),Intg(k),Real(p in 0..1)'},
    'negbinomial_cdf':{d:'Devuelve Proba(X<=x) o Proba(x<=X<=y) cuando X sigue la ley negbinomial(n,p).',p:'Intg(n),Real(p),Real(x),[Real(y)]'},
    'negbinomial_icdf':{d:'Devuelve h tal que Proba(X<=h)=t cuando X sigue la ley negbinomial(n,p).',p:'Intg(n),Real(p),Real(t)'},
    'neighbors':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'network_transitivity':{d:'',p:'Graph(G)'},
    'neural_network':{d:'',p:'Vect(topology)||NeuralNet(net),[opts]'},
    'newList':{d:'Devuelve la lista de n ceros.',p:'Intg(n)'},
    'newMat':{d:'Devuelve la matriz de n filas y p columnas, con sólo ceros.',p:'Intg(n),Intg(p)'},
    'newton':{d:'newton(f(x),x,a,p) calcula una raíz de f(x) por el método de Newton comenzando en a con p iteraciones (por defecto p=20).',p:'Expr(f(x)),Var(x),[ApproxVal(a),NumIter(p)]'},
    'nextperm':{d:'Devuelve la permutación siguiente en orden lexicográfico.',p:'Intg(n)'},
    'nextprime':{d:'Siguiente número primo o pseudo-primo después de un entero dado.',p:'Intg(a)'},
    'nlp_initialpoint':{d:'',p:'Opt',a:['nlp_iterationlimit','nlp_nonnegative','nlp_precision','nlp_maximize','nlp_presolve','nlp_method','nlp_integervariables','nlp_integer','nlp_binaryvariables','nlp_binary','nlp_tolerance','nlp_verbose','nlp_nonnegint']},
    'nlpsolve':{d:'',p:'Expr(objective),[Lst(constr)],[Seq(bd)],[Seq(opts)]'},
    'nodisp':{d:'Para mostrar Done en lugar de un valor.',p:'Expr'},
    'non_recursive_normal':{d:'Simplifica las expresiones, pero sin simplificar al interior de expresiones no racionales.',p:'Expr'},
    'nop':{d:'Instrucción para no hacer nada.',p:'NULL'},
    'norm':{d:'Norma l2 de un vector=sqrt(x1^2+x2^2+...xn^2) o norma de una matriz induced by l2 norm.',p:'Vect or Mtrx',a:['l2norm']},
    'normal':{d:'Simplifica la expresión.',p:'Expr',a:['evala']},
    'normal_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según la ley Normal sea menor que x0 o entre x0 y y0 (mu es el promedio y sigma la desviación estándar).',p:'Real(mu),Real(sigma),Real(x0),[Real(y0)]',a:['normald_cdf']},
    'normal_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria Normal sea menor que h es p (mu es el promedio y sigma la desviación estándar).',p:'Real(mu),Real(sigma),Real(p)',a:['normald_icdf']},
    'normald':{d:'Devuelve la densidad de probabilidad de la ley Normal (mu es el promedio y sigma la desviación estándar).',p:'Real(mu),Real(sigma),Real(x0)',a:['NORMALD']},
    'normalize':{d:'Devuelve el vector dividido entre su norma l2. Es también una opción de plotfiefd.',p:'Lst||Cplx||Audio',a:['unitV']},
    'normalt':{d:'',p:'Lst,Real,[Real],Fnc,[Real]'},
    'not':{d:'Devuelve el inverso lógico del argumento.',p:'Boolean',a:['non']},
    'nprimes':{d:'Devuelve el número de número primo menor que n.',p:'Intg(n)'},
    'number_of_edges':{d:'',p:'Graph(G)'},
    'number_of_spanning_trees':{d:'',p:'Graph(G)'},
    'number_of_triangles':{d:'',p:'Graph(G)'},
    'number_of_vertices':{d:'',p:'Graph(G)'},
    'numdiff':{d:'',p:'Lst(X),Lst(Y),Real(x0),[Intg(n)]'},
    'numer':{d:'Devuelve el numerador de la fracción simplificada.',p:'Frac(a/b) or RatFrac'},
    'octahedron':{d:'Traza un octaedro de centro A, vértice B donde el plano ABC contiene 4 vértices.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'odd':{d:'Devuelve 1 si el entero es impar, devuelve 0 si no.',p:'Intg(n)'},
    'odd_girth':{d:'',p:'Graph(G)'},
    'odd_graph':{d:'',p:'Intg(n)'},
    'odesolve':{d:'odesolve(f(t,y),[t,y],[t0,y0],t1)=odesolve(t0..t1,f,y0)=y(t1) para y solución aprox de y\'=f(t,y) e y(t0)=y0 e y=vector para los sistemas.',p:'Expr,VectVar,VectInitCond,FinalVal,[tstep=Val,curve]'},
    'of':{d:'Devuelve el valor f(a).',p:'Fnc(f),Real(a)'},
    'open':{d:'Abre una archivo de nombre s, devuelve el número de handle del archivo.',p:'Str(s)'},
    'open_polygon':{d:'Devuelve y traza la línea poligonal cuyos vértices son los elementos de l.',p:'LstPnt||LstCplx'},
    'option':{d:'Palabra reservada para compatibilidad.'},
    'or':{d:'operador booleano infijo (o).',p:'Expr, Expr',a:['||','ou']},
    'ord':{d:'Devuelve el código ASCII de un carácter o del primer carácter de una cadena.',p:'Char||LstChar'},
    'order':{d:'',p:'g'},
    'order_size':{d:'Resto (término en O) de un desarrollo en serie: limit(x^a*order_size(x),x=0)=0 si a>0.',p:'Expr'},
    'ordinate':{d:'Devuelve la ordenada de un punto o de un vector.',p:'Pnt or Vect'},
    'orthocenter':{d:'Muestra el ortocentro de uno triángulo o del triángulo formado por 3 puntos.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'orthogonal':{d:'orthogonal(A,line(B,C)) traza el plan perpendicular a la recta BC pasando por A y orthogonal(A,plane(B,C,D)) traza la recta perpendicular al plan(B,C,D) pasando por A.',p:'(Pnt),(Line or Plan)'},
    'osculating_circle':{d:'',p:'Curve,Point'},
    'output':{d:'Instrucción en un programa que permite mostrar una expresión guardada en var.',p:'[Str],Var(Var)',a:['Output']},
    'p1oc2':{d:'Devuelve la permutación producto de p1 y c2.',p:'Permut,Cycle'},
    'p1op2':{d:'Devuelve la permutación producto de p1 y p2.',p:'Permut,Permut'},
    'pa2b2':{d:'Devuelve [a,b] tales que a^2+b^2=n (para n primo y n=1 (mod 4)).',p:'Intg(n)'},
    'pade':{d:'Approximación de Padé P/Q=Xpr mod x^(n+1) o mod N con grado(P)<p.',p:'Expr(Xpr), Var(x), (Intg(n) || Poly(N)), Intg(p)'},
    'paley_graph':{d:'',p:'Intg(p),[Intg(k)]'},
    'parabola':{d:'parabola(F,A)=parábola de foco F y vértice A (en el plan ABP) o (parabola(A,c) de ecua. y=yA+c*(x-xA)^2 c=1/(2*p) y FA=p/2 geo2d) y parabola(P(x,y)=conic si deg(P)=2.',p:'Pnt(F)||Pnt(xA+i*yA),Pnt(A)||Real(c),[Pnt(P)]'},
    'parallel':{d:'parallel(A,D) (resp parallel(A,P) o parallel(A,D,DD)) traza la recta (resp el plan) a través de A paralela a la recta D y, parallel(d,D) traza el plan paralelo a la recta D que pasa por d.',p:'Pnt or Line,Line or Plan,[Line]'},
    'parallelepiped':{d:'Traza un paralelepípedo con lados AB,AC,AD (las caras son paralelogramos).',p:'Pnt(A),Pnt(B),Pnt(C),Pnt(D)'},
    'parallelogram':{d:'Devuelve y traza el paralelogramo ABCD tal que vector(AB)+vector(AD)=vector(AC).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Pnt(C)||Cplx,[Var(D)]'},
    'parameq':{d:'parameq(C) devuelve el número complejo = ecuación paramétrica de la curva C.',p:'GeoObj'},
    'parameter':{d:'Palabra reservada'},
    'parfrac':{d:'Opción del comando convert o convertir (id a opción partfrac).',p:'Opt',a:['fullparfrac']},
    'pari':{d:'Ejecuta un comando de PARI/GP o exporta los comandos de PARI/GP.',p:'Str,arguments'},
    'part':{d:'Devuelve la n-ésima subexpresión de la expresión.',p:'Expr, Intg(n)'},
    'partfrac':{d:'Efectua la descomposición parcial de una fracción o Opción del comando convert o convertir (id a opción parfrac).',p:'RatFrac or Opt'},
    'parzen_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'pas_de_cote':{d:'La tortuga hace n pasos de lado izquierdo (-n pasos a la derecha si n negativo) sin dejar marcas (por defecto n=10).',p:'NULL or Real(n)'},
    'path_graph':{d:'',p:'Intg(n)||Lst(V)'},
    'pcar':{d:'Lista de los coeficientes del polinomio característico de una matriz o polinomio característico de una matriz de variable el segundo argumento.',p:'Mtrx,[Var]',a:['charpoly']},
    'pcar_hessenberg':{d:'Polinomio característico de una matriz por el método de Hessenberg (si los coeficientes están en un campo finito).',p:'Mtrx,[Var]'},
    'pcoeff':{d:'Devuelve los coeficientes de un polinomio cuyas raíces están dadas en argumento.',p:'Vect',a:['pcoef']},
    'perimeter':{d:'Perímetro de una circunferencia o de un polígono (por ejemplo triángulo, cuadrado, ...)',p:'Polygone'},
    'perimeterat':{d:'Escribe en el punto point(z0), con una leyenda, el perímetro de una circunferencia o de un polígono (por ejemplo triángulo, cuadrado, ...)',p:'Polygone, Pnt||Cplx(z0)'},
    'perimeteratraw':{d:'Escribe en el punto point(z0), el perímetro de una circunferencia o de un polígono (por ejemplo triángulo, cuadrado, ...)',p:'Polygone, Pnt||Cplx(z0)'},
    'period':{d:'',p:'Expr,[Var]'},
    'periodic':{d:'',p:'Expr,Var,Real(a),Real(b)||Expr,Var=a..b'},
    'perm':{d:'perm(n,p)=número de arreglos de p objetos tomados de n en n : n!/(n-p)!',p:'Intg(n),Intg(p)',a:['nPr']},
    'perminv':{d:'Devuelve la permutación inversa de la permutación a.',p:'Permut(a)'},
    'permu2cycles':{d:'Convierte una permutación en un producto de ciclos disjuntos.',p:'Permut'},
    'permu2mat':{d:'Devuelve la matriz donde las líneas de la matriz identidad son permutadas con la permutación p.',p:'Permut(p)'},
    'permuorder':{d:'Devuelve el orden de la permutación a.',p:'Permut(a)'},
    'permute_vertices':{d:'',p:'Graph(G),Lst(V)'},
    'perpen_bisector':{d:'perpen_bisector(A,B) dibuja la mediatriz (línea o plano) del segmento AB',p:'(Pnt or Cplx),(Pnt or Cplx)'},
    'perpendicular':{d:'perpendicular(A,line(B,C)) o perpendicular(A,B,C) traza la recta perpendicular a la recta BC, pasando por A, y perpendicular(d,plane(B,C,D)) traza le plan perpendicular al plane(B,C,D) a través de la recta d.',p:'(Pnt or Line),(Line or Plan)'},
    'petersen_graph':{d:'',p:'Intg(n),[Intg(k)]'},
    'peval':{d:'Evalua en un punto x0, un polinomio dado por sus coeficientes.',p:'Vect,Real(x0)',a:['polyEval']},
    'pi':{d:'El número pi',a:['Pi']},
    'piecewise':{d:'si condición1 devuelve expr1 sino... si condición2p devuelve expr2p sino devuelve expr2p+1.',p:'Cond1,Expr1,..,Cond2p,Expr2p,[Expr2p+1]'},
    'pivot':{d:'Devuelve la matriz obtenida a partir de A escribiendo ceros en la columna nc, por el método de Gauss-Jordan, utilizando el elemento A[nl,nc] como pivote.',p:'Mtrx(A),Intg(nl),Intg(nc)'},
    'pixoff':{d:'Desactiva un pixel.',p:'Real(x),Real(y)'},
    'pixon':{d:'Activa un pixel',p:'Real(x),Real(y)'},
    'planar':{d:'',p:'Opt'},
    'plane':{d:'plane(A,B,C) o plane(A,line(B,C)) (resp plane(a*x+b*y+c*z+d=0)) traza el plano ABC (resp de ecuación a*x+b*y+c*z+d=0).',p:'Pnt or Eq, [Pnt or Line],[Pnt]'},
    'plane_dual':{d:'',p:'Graph(G)||Lst(F)'},
    'playsnd':{d:'',p:'Vect'},
    'plex':{d:'Opción del comando gbasis o greduce para especificar un orden sobre los monomios (=orden por defecto=lexicográfico puro).',p:'Opt'},
    'plot':{d:'Traza la gráfica de una expresión (o de una lista de expresiónes) de 1 variable.',p:'(Expr or LstExpr),Var[=VarMin..VarMax],[color=LstColor]',a:['graphe']},
    'plot3d':{d:'Borra y traza el gráfico de una función o de una expresión de 2 variables o de una superficie parametrizada por una lista de 3 funciones o de 3 expresiones de 2 variables.',p:'Expr||Lst(3*Expr),Var,Var',a:['graphe3d']},
    'plotarea':{d:'Muestra el area bajo una curva, en opción el método de cuadratura.',p:'Expr,x=a..b,[n],[Method]',a:['areaplot']},
    'plotcdf':{d:'',p:'Func,FuncParams'},
    'plotcontour':{d:'Traza 11 líneas de nivel equidistantes entre z=z_mina,..,z=z_max de la superficie z=Xpr, con las líneas de contorno definidas por el 3er argumento.',p:'Expr(Xpr),[LstVar],[LstVal]',a:['contourplot','DrwCtour']},
    'plotdensity':{d:'Muestra en color el gráfico de una expresión de 2 variables en el plano.',p:'Expr,[x=xrange,y=yrange],[z],[xstep],[ystep]',a:['densityplot']},
    'plotfield':{d:'plotfield(f(t,y),[t,y]) traza el campo de las tangentes (normalizadas o no según la opción) de la ecuación diferencial y\'=f(t,y).',p:'Expr,VectVar,[Opt]',a:['fieldplot']},
    'plotfunc':{d:'Traza la gráfica de una expresión de 1 o 2 variables con superposición.',p:'Expr,[Var(x) or VectVar] ,[Intg(color)]',a:['funcplot','DrawFunc','Graph']},
    'plotimplicit':{d:'plotimplicit(f(x,y),x,y) o plotimplicit(f(x,y),[x,y]) gráfica de f(x,y)=0.',p:'Expr,Var1,Var2',a:['implicitplot']},
    'plotinequation':{d:'Muestra el gráfico de la solución de inecuaciones en 2 variables.',p:'Expr,[x=xrange,y=yrange],[xstep],[ystep]',a:['inequationplot']},
    'plotode':{d:'plotode(f(t,y),[t,y],[t0,y0])) traza la solución de y\'=f(t,y) con y(t0)=y0.',p:'Expr,VectVar,VectInitCond',a:['odeplot']},
    'plotparam':{d:'plotparam(a(x)+i*b(x),x=x0..x1) traza la curva X=a(x), Y=b(x) x=x0..x1 o plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) traza las superficies X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 y v=v0..v1.',p:'Cplx||Lst,Var||Lst(Var)',a:['paramplot','DrawParm','courbe_parametrique']},
    'plotpolar':{d:'plotpolar(f(x),x,a,b) traza la curva polar r=f(x) para x en [a,b].',p:'Expr,Var,VarMin,VarMax',a:['polarplot','DrawPol','courbe_polaire']},
    'plotproba':{d:'',p:'Matrix,[Vector]'},
    'plotseq':{d:'Permite visualizar los p primeros términos de la sucesión u(0)=a,u(n)=f(u(n-1)).',p:'Expr(f(Var)),Var=[a,xm,xM],Intg(p)',a:['seqplot','graphe_suite']},
    'plotspectrum':{d:'',p:'Audio(clip),[range=a..b]'},
    'plotwav':{d:'',p:'Audio(clip),[range=a..b]'},
    'pmin':{d:'Devuele el polinómio mínimo de una matriz A o el polinómio mínimo de un número algebraica a.',p:'Mtrx(A)||Real(a),[Var]'},
    'point':{d:'A:=point(za) o A:=point(a,b) (resp A:=point([a,b,c])) traza el punto de afijo za=a+ib (resp de coordenadas (a,b,c)) con la leyenda A.',p:'Cplx(za)||Vect'},
    'point2d':{d:'Define al azar, las coordenadas enteras (entre -5 y 5) de puntos 2d dados en argumento.',p:'SeqVar(A,B,C...)'},
    'point3d':{d:'Define al azar las coordenadas enteras (entre -5 y 5) de puntos 3d dados en argumento.',p:'SeqVar(A,B,C...)'},
    'point_width_1':{d:'Opción de la instrucción display para un punto.',p:'Opt',a:['point_width_2','point_width_3','point_width_4','point_width_5','point_width_6','point_width_7','epaisseur_point_1','epaisseur_point_2','epaisseur_point_3','epaisseur_point_4','epaisseur_point_5','epaisseur_point_6','epaisseur_point_7']},
    'poisson':{d:'Devuelve exp(-mu)*mu^k/k!',p:'Real(mu),Intg(k)'},
    'poisson_cdf':{d:'Devuelve Proba(X<=x) cuando X sigue la ley de Poisson con promedio mu.',p:'Real(mu),Real(x)'},
    'poisson_icdf':{d:'Devuelve h tal que Proba(X<=h)=p cuando X sigue una ley de Poisson con mu como parámetro.',p:'Real(mu),Real(p)'},
    'poisson_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'polar':{d:'Devuelve la recta de puntos conjugados de A con respecto a la circunferencia.',p:'Crcle,Pnt or Cplxe(A)'},
    'polar_coordinates':{d:'Devuelve la lista de la norma y de el argumento del afijo de un punto (2D) o de un número complejo o de la lista de coordenadas rectangulares.',p:'Pnt or Cplx or LstRectCoord'},
    'polar_point':{d:'Devuelve un punto (2D) de afijo r*exp(i*t).',p:'Real(r),Real(t)'},
    'pole':{d:'Devuelve el punto A teniendo la recta como polar con respecto a la circunferencia C.',p:'Crcle,Line'},
    'poly2symb':{d:'Devuelve el polinomio (o su valor) de coeficientes el primer argumento y de variable el segundo argumento (por defecto x).',p:'Lst,Var',a:['r2e']},
    'polygon':{d:'Devuelve y traza el polígono cuyos vértices son los elementos de l.',p:'LstPnt||LstCplx'},
    'polygone_rempli':{d:'El argumento es un entero <-1 que indica la cantidad de posiciones previas de la tortuga que forman un polígono y genera este polígono lleno.',p:'Intg(n)'},
    'polygonplot':{d:'Traza los polígonos unidos para j fijado y para k=0..nrows, los puntos (xk,yk) donde xk=elemento fila k columna 0 e yk=elemento fila k columna j, ordenando los xk (podemos obtener ncols-1 polígonos).',p:'Mtrx',a:['ligne_polygonale']},
    'polygonscatterplot':{d:'Traza los puntos (xk,y) y los polígonos unidos para j fijo y para k=0..nrows, los puntos (xk,yk) donde xk=elemento fila k columna 0 e yk=elemento fila k columna j, ordenando los xk (podemos obtener ncols-1 polígonos).',p:'Mtrx',a:['ligne_polygonale_pointee']},
    'polyhedron':{d:'Traza un poliedro convexo cuyos vértices están dentro de los argumentos.',p:'SeqPnt(A,B,C...)'},
    'polynom':{d:'Opción del comando convert o convertir y del comando taylor y series (list=>n-poly ou series=>poly).',p:'Opt'},
    'polynomial_regression':{d:'Devuelve los coeficientes (an,..,a1,a0) de y=an*x^n+..+a1*x+a0: la mejor aproximación polinomial para los puntos cuyas coordenadas están en las filas de A (o las 2 listas) (n es el segundo argumento).',p:'Lst||Mtrx(A),[Lst],Intg(n)'},
    'polynomial_regression_plot':{d:'Devuelve la gráfica de y=an*x^n+..+a1*x+a0: la mejor aproximación polinomial para los puntos con coordenadas en las filas de A (o las 2 listas) (n es el segundo argumento).',p:'Lst||Mtrx(A),[Lst],Intg(n)'},
    'position':{d:'Devuelve la posición de la tortuga en pixeles o pone la tortuga según el argumento sin cambiar de dirección.',p:'NULL or LstCoord'},
    'poslbdLMQ':{d:'Devuelve una lower bound  para las raíces reales positivas de P con el algoritmo Vincent-Akritas-Strzebonski\' Local Max Quadratic (LMQ).',p:'Poly(P)'},
    'posubLMQ':{d:'Devuelve una upper bound para las raíces reales positivas de P con el algoritmo Vincent-Akritas-Strzebonski\' Local Max Quadratic (LMQ).',p:'Poly(P)'},
    'potential':{d:'Devuelve U tal que grad(U)=derive(U,Vector_of_variable)=V.',p:'Vect(V),VectVar'},
    'pour':{d:'Bucle pour (pour...de ...jusque... [pas...] faire...fpour;).'},
    'pow':{d:'Calcula a^n(cálculo rápido).',p:'Intg(a),Intg(n)'},
    'pow2exp':{d:'Transforma las potencias en exponenciales.',p:'Expr'},
    'power_regression':{d:'Devuelve los coeficientes (m,b) de y=b*x^m: la mejor aproximación monomial para puntos con coordenadas en las filas de A (o las 2 listas).',p:'Lst|Mtrx(A),[Lst]'},
    'power_regression_plot':{d:'Devuelve la gráfica de y=b*x^m: la mejor aproximación monomial para puntos con coordenadas en las filas de A (o las 2 listas).',p:'Lst||Mtrx(A),[Lst]'},
    'powerpc':{d:'Devuelve lo número real d^2-R^2 (d=distancia entre punto y centro, R=radio).',p:'Cercle,Pnt or Cplx'},
    'powexpand':{d:'Expande la expresión en función del exponente.',p:'Expr'},
    'powmod':{d:'Calcula a^n modulo p o modulo p,P(x) (cálculo rápido).',p:'Intg(a),Intg(n),Intg(p),[Expr(P(x))],[Var]',a:['powermod']},
    'prepend':{d:'Pone el elemento al principio de la lista (conjunto o cadena) (L:=prepend(L,a) o L.prepend(a)).',p:'Lst||Set||Str(L),Elem(n)'},
    'preval':{d:'Devuelve F(b)-F(a).',p:'Expr(F(Var)),Real(a),Real(b),[Var]'},
    'prevperm':{d:'Devuelve la permutación anterior en orden lexicográfico.',p:'Intg(n)'},
    'prevprime':{d:'Número primo o pseudo-primo previo al entero dado a.',p:'Intg(a)'},
    'primpart':{d:'Devuelve el polinomio P dividido por el mcd de sus coeficientes.',p:'Poly(P),[Var]'},
    'print':{d:'Permite mostrar un resultado intermedio en un programa.',p:'Expr|| Str',a:['Disp']},
    'printf':{d:'',p:'Expr'},
    'prism':{d:'Traza un prisma con base plana ABCD...y lados paralelos a AA1 (las caras son paralelogramos).',p:'LstPnt([A,B,C,D]),Pnt(A1)'},
    'prism_graph':{d:'',p:'Intg(n)'},
    'proc':{d:'Empieza un proceso (como en MuPAD).'},
    'product':{d:'Producto de los valores de la expresión cuando la variable va desde a hasta b con paso p (product(expresión,var,inicio,fin,paso) por defecto p=1) o producto de elementos de una lista o producto componente por componente de 2 listas o matrices.',p:'Expr||Lst,[Var||Lst],[Intg(a)],[Intg(b)],[Intg(p)]',a:['mul']},
    'program':{d:'Palabra reservada.'},
    'projection':{d:'projection(C,A) es la proyección ortogonal de A sobre la curva C.',p:'Curve,Pnt'},
    'proot':{d:'Devuelve todas las raíces aproximadas de un polinomio dado por sus coeficientes (no funciona en general con raíces mútliples).',p:'Vect||Poly,[Intg(n)]'},
    'propfrac':{d:'Simplifica y escribe la facción (o fracción racional) A/B como Q+R/B con R<B (o deg(R)<deg(B)).',p:'Frac or RatFrac',a:['propFrac']},
    'pruefer_code':{d:'',p:'Vect(S)|Graph(T)'},
    'psrgcd':{d:'MCD de 2 polinomios, con el algoritmo sub resultante.',p:'Poly,Poly'},
    'ptayl':{d:'Devuelve el polinomio de Taylor Q tal que P(x)=Q(x-a).',p:'Expr||Poly(P(Var)),Var=Real || Real(a),[Order || Var]'},
    'purge':{d:'purge(nomvar) borra el valor guardado en la variable nomvar.',p:'Var',a:['DelVar','del']},
    'pwd':{d:'Repertorio de trabajo actual.',p:'NULL'},
    'pyramid':{d:'Traza un tetraedro regular directo de lado AB con una cara en el plan (A,B,C) cuando hay 3 argumentos y el pirámide ABCD cuando hay 4 argumentos.',p:'Pnt(A),Pnt(B),Pnt(C),[Pnt(D)]',a:['tetrahedron']},
    'python_compat':{d:'',p:'Intg(0) or 1'},
    'q2a':{d:'q2a(q(x,y),[x,y])=matriz simétrica asociada a la forma cuadrática q.',p:'QuadraForm, VectVar'},
    'qr':{d:'Para una matriz numérica A, devuelve R (derecha) tal que A=QR y Q es ortogonal.',p:'Mtrx'},
    'quadrant1':{d:'Opción de la instrucción display para escribir una leyenda.',p:'Opt',a:['quadrant2','quadrant3','quadrant4']},
    'quadric':{d:'Define una cuádrica por su ecuación cartesiana con x,y como variables por defecto, y la traza.',p:'Expr,[Lst(Var)]'},
    'quadrilateral':{d:'Devuelve y traza el cuadrilátero ABCD.',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Pnt(C)||Cplx,Pnt(D)||Cplx'},
    'quantile':{d:'Devuelve el quintil de los elementos de l correspondiente al valor de p (0<p<1).',p:'Lst(l),Real(p)'},
    'quartile1':{d:'Devuelve el primer cuartil de los elementos (o de las columnos) del argumento.',p:'Lst||Mtrx,[Lst]'},
    'quartile3':{d:'Devuelve el 3er cuartil de los elementos (o de las columnos) del argumento.',p:'Lst||Mtrx,[Lst]'},
    'quartiles':{d:'Mínimo, 1er cuartíl, mediana, 3er cuartil, máximo de los elementos (o de las columnas) del argumento.',p:'Lst||Mtrx,[Lst]'},
    'quest':{d:'Devuelve la n+1-ésima cuestión del histórico de comandos si n>=0, o la (-n)-ésima cuestión anterior si n<0 (por defecto n=-1 para la última expresión).',p:'Intg(n)',a:['entry']},
    'quo':{d:'Cociente euclidiano de 2 polinomios.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'quorem':{d:'Cociente y resto euclidianos de 2 polinomios.',p:'(Vect or Poly),(Vect or Poly),[Var]',a:['divide']},
    'quote':{d:'Devuelve su argumento sin evaluarlo (y también a:=quote(a) que purge a).',p:'Expr',a:['hold']},
    'radians':{d:'',p:'Real(deg)'},
    'radical_axis':{d:'Devuelve la recta de puntos con misma potencia respecto a las 2 circunferencias.',p:'Crcle,Crcle'},
    'radius':{d:'radius(C) devuelve el radio de la circunferencia C.',p:'Crcle'},
    'radius2':{d:'',p:'Crcle'},
    'rand':{d:'rand(n)=un número (resp rand(p,n)=un número real o rand(p..n)=una función real) aleatorio distribuido en 0..n-1 (resp en [p;n]) (rand()=rand(0,1)) o rand(n,b1,b2)= enteros entre b1 y b2 o rand(n,L)=lista de n elementos de L.',p:'Intg(n) or Interval(p..n) or NULL,[Intg(b1) or Lst(L)],[Intg(b2)]',a:['random']},
    'randbetad':{d:'Devuelve un número aleatorio distribuido según la ley Beta (parámetro a>0, b>0).',p:'Real(a),Real(b)',a:['betavariate']},
    'randbinomial':{d:'Devuelve un número aleatorio distribuido según la ley binomimal B(n,p).',p:'Intg(n),Real(p)'},
    'randchisquare':{d:'Devuelve un número aleatorio distribuido según la ley Chi-cuadrado, χ^2(n).',p:'Intg(n)'},
    'randexp':{d:'Devuelve un número aleatorio distribuido según la ley exponencial (parámetro a>0).',p:'Real(a)',a:['expovariate']},
    'randfisher':{d:'Devuelve un número aleatorio distribuido según la ley Fisher-Snedecor F(n,m).',p:'Intg(n),Intg(m)'},
    'randgammad':{d:'Devuelve un número aleatorio distribuido según la ley Gamma (parámetro a>0, b>0).',p:'Real(a),Real(b)',a:['gammavariate']},
    'randgeometric':{d:'',p:'Real(p)'},
    'randmarkov':{d:'',p:'Mtrx(M) || Vctr(v),Intg(i0),[Intg(n)]'},
    'randmultinomial':{d:'Devuelve un índice o un elemento de K aleatorio distribuido según la ley multinomimal de probabilidad P.',p:'List(P),[List(K)]'},
    'randnorm':{d:'Devuelve un número aleatorio distribuido según la ley normal N(mu,sigma).',p:'Real(mu),Real(sigma)',a:['randNorm','normalvariate']},
    'random_bipartite_graph':{d:'',p:'Intg(n)||Lst(a,b),Real(p)||Intg(m)'},
    'random_digraph':{d:'',p:'Intg(n)||Lst(V),Real(p)||Intg(m)'},
    'random_graph':{d:'',p:'Intg(n)||Lst(V),Real(p)||Intg(m)'},
    'random_network':{d:'',p:'Intg(a),Intg(b),[Real(p)],[opts]'},
    'random_planar_graph':{d:'',p:'Intg(n)||Lst(V),Real(p),[Intg(c)]'},
    'random_regular_graph':{d:'',p:'Intg(n)||Lst(V),Intg(d),[connected]'},
    'random_sequence_graph':{d:'',p:'Lst(L)'},
    'random_tournament':{d:'',p:'Intg(n)||Lst(V)'},
    'random_tree':{d:'',p:'Intg(n)||Lst(V),[Intg(d)||root[=Vrtx(v)]]'},
    'random_variable':{d:'',p:'Lst(W)||Mtrx(M)||Fnc(f),[params]',a:['randvar']},
    'randperm':{d:'Devuelve una permutación aleatoria de [0,1,2,..,n-1] o de L.',p:'Intg(n)||Lst(L)',a:['shuffle']},
    'randpoisson':{d:'Devuelve un número aleatorio distribuido según la ley poisson P(λ).',p:'Real(λ)'},
    'randpoly':{d:'Devuelve el polinomio de variable var (o x), de grado n y cuyos coeficientes son enteros aleatorios equirepartidos entre -99 y 99.',p:'[Var(Var)],Intg(n),[law]',a:['randPoly']},
    'randstudent':{d:'Devuelve un número aleatorio distribuido según la ley Student S(n).',p:'Intg(n)'},
    'randvector':{d:'Devuelve una lista de tamaño n constituida por enteros aleatorios uniformemente distribuidos entre -99 y 99 (o entre 0 y m-1) o de números aleatorios distribuidos según la ley puesta entre comillas.',p:'Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]',a:['ranv']},
    'randweibulld':{d:'Devuelve un número aleatorio distribuido según la ley Weibull (parámetro a>0, b>0).',p:'Real(a),Real(b)',a:['weibullvariate']},
    'range':{d:'Devuelve la lista [0,1..n-1] o la lista [a,a+1..b[ o la lista [a,a+p,a+2p..b[.',p:'Intg(n)||Intg(a),Intg(b),[Intg(p)]'},
    'rank':{d:'Devuelve el rango de una matriz.',p:'Mtrx'},
    'ranm':{d:'Devuelve una lista de tamaño n o una matriz n*m constituida por enteros aleatorios uniformemente distribuidos entre -99 y 99 o de números aleatorios distribuidos según la ley puesta entre comillas.',p:'Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]',a:['randMat','randmatrix']},
    'rat_jordan':{d:'Devuelve la lista formada por la matriz de pasaje y la forma de Jordan racional de una matriz.',p:'Mtrx'},
    'ratinterp':{d:'',p:'[Mtrx(P) || List(X)],[List(Y)],[Var(x)],[Intg(d)])'},
    'rationalroot':{d:'Devuelve la lista de raíces racionales de P sin indicar la multiplicidad.',p:'Poly(P)'},
    'ratnormal':{d:'Reescritura bajo forma de fracción irreducible.',p:'Expr'},
    'rdiv':{d:'División de a por b (versión prefija de /).',p:'Expr(a),Expr(b)'},
    're':{d:'Devuelve la parte real de un número complejo.',p:'Cplx or LstCplx',a:['real']},
    'reachable':{d:'',p:'Graph(G),Vrtx(u)'},
    'read':{d:'Para leer en el archivo fich_name las variables y sus valores.',p:'Str(fich_name)',a:['ramene']},
    'readrgb':{d:'Lee un archivo de imagen, con el tamaño original o especificado en argumento.',p:'Str(s),[Intg(w)],[Intg(h)]'},
    'readwav':{d:'Lee un archivo de sonido en el formato WAV.',p:'Str(s)'},
    'realroot':{d:'Devuelve la lista de intervalos de largo <=l donde están las raíces reales de P en a..b, con su multiplicidad. Con el algoritmo Vincent-Akritas-Strzebonski (VAS) o  en opción el método de Sturm (realroot(sturm,P)).',p:'[sturm],Poly(P),[Real(l)],[Cplx(a)],[Cplx(b)]'},
    'reciprocation':{d:'Devuelve la lista reemplazando un punto (resp una recta) por su polar (resp polo), con respecto a la circunferencia C.',p:'Crcle,Lst(Pnt,Line)'},
    'rect':{d:'',p:'Expr(x)'},
    'rectangle':{d:'Devuelve y traza el rectángulo ABCD, AD=k*AB si k>0 ABCD es directo si no, indirecto (en el plan ABP AD=AP o AD=k*AB).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Real(k)||Pnt(P)||Lst(P,k),[Var(D)],[Var(C)]'},
    'rectangle_plein':{d:'Traza un rectángulo (resp un cuadrado) lleno directo de lados a,b (resp a) a partir de la posición de la tortuga y por la izquierda.',p:'Real(a),[Real(b)]'},
    'rectangular_coordinates':{d:'Devuelve la lista de la abscisa y de la ordenada de un punto dado por la lista de sus coordenadas polares.',p:'LstPolCoord'},
    'recule':{d:'La tortuga vuelve por atrás de n pasos (por defecto n=10).',p:'NULL or Real(n)',a:['backward']},
    'reduced_conic':{d:'Devuelve el origen y la matriz de una base en la cual la cónica es reducida, 0 o 1 (0 si la cónica es degenerada) y la ecuación de la cónica en esta base y su ecuación paramétrica.',p:'Expr,[LstVar]'},
    'reduced_quadric':{d:'Devuelve el origen y la matriz de una base en la cual la cuádrica es reducida, la lista de valores propios y la ecuación de la cuádrica en esta base y su ecuación paramétrica.',p:'Expr, [LstVar]'},
    'ref':{d:'Reducción de Gauss de AX=b (M=A|(-b)).',p:'Mtrx(M)'},
    'reflection':{d:'reflection(D,C) (o reflection(A,C))=simétrico de C en la recta de simetría D (o punto de simetría A).',p:'(Pnt(A) or Line(D)),(Pnt(C) or Curve(C))'},
    'regroup':{d:'Agrupar y simplifica la expresión.',p:'Expr'},
    'relabel_vertices':{d:'',p:'Graph(G),Lst(L)'},
    'reliability_polynomial':{d:'',p:'Graph(G),[Var(p)]'},
    'rem':{d:'Resto euclidiano de 2 polinomios.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'remove':{d:'Borra los elementos a de l tales que f(a)=verdadero.',p:'FncBool(f)||a,Lst(l)'},
    'reorder':{d:'Reordena las variables en E según el orden dado en 2º argumento.',p:'Expr, LstVar'},
    'repeat':{d:'Bucle repeat (realiza la instrucción hasta cond==verdadero): repeat i1;i2; until cond; o repeter i1;i2;jusqua cond;',a:['until','repeter','jusqua','jusqu_a']},
    'repete':{d:'Instrucción permitiendo de repetir k veces los mismos comandos.',p:'Intg,SeqCmds'},
    'resample':{d:'',p:'Audio(clip),[Intg(s),[Intg(q)]]'},
    'residue':{d:'Devuelve el residuo en a de la expresión dependiente de la variable v.',p:'Expr,Var(v),Cplx(a)'},
    'restart':{d:'Purga todas las variables.',p:'NULL'},
    'resultant':{d:'Resultante de 2 polinomios.',p:'Poly,Poly,Var'},
    'return':{d:'Instrucción que interrumpe una función y devuelve su valor.',p:'Expr'},
    'reverse_graph':{d:'',p:'Graph(G)'},
    'reverse_rsolve':{d:'Si v=[v_0 ... v_(2n-1)], devuelve [b_n,...,b_0] tal que b_n*v_{n+k}+...+b_0*v_k=0 para k=0..n-1.',p:'Vect(v)',a:['berlekamp_massey']},
    'revert':{d:'Devuelve el desarrollo recíproco de un desarrollo en serie en 0.',p:'Expr'},
    'revlex':{d:'Opción de gbasis o greduce para especificar un orden sobre los monomios (grado total, luego orden antilexicográfico).',p:'Opt'},
    'revlist':{d:'Devuelve la lista L al revés; L:=revlist(L) o L.revlist().',p:'Lst(L)||Audio',a:['reverse']},
    'rgb':{d:'Opción de la instrucción display (o affichage) para que definir colores RGB.',p:'Lst(r,g,b)||Intg(rrggbb)||Str(rrggbb)||Color(c)'},
    'rgb2hsv':{d:'',p:'Lst(r,g,b)'},
    'rgb2xyz':{d:'',p:'Lst(r,g,b)||Color(c)'},
    'rhombus':{d:'Devuelve y traza el rombo ABCD tal que el ángulo (AB,AD)=a (o en el plano ABPangle(AB,AD)=angle(AB,AP) o angle(AB,AD)=a).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Angle(a)||Pnt(P)||Lst(P,a)),[Var(C)],[Var(D)]'},
    'rhombus_point':{d:'Opción de la instrucción display para un punto.',p:'Opt',a:['point_losange','plus_point','point_plus','square_point','point_carre','cross_point','point_croix','triangle_point','point_triangle','star_point','point_etoile','point_point','invisible_point','point_invisible']},
    'riemann_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'right':{d:'Devuelve la parte derecha de una igualdad, de un intervalo, de una lista o de una cadena.',p:'Equal(a=b) or Interval(a..b) or Str,Intg',a:['rhs','droit']},
    'right_triangle':{d:'Traza el triángulo ABC rectángulo en A con AC=k*AB (o en el plan ABP AC=AP o AC=k*AB).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Real(k) or Pnt(P) or Lst(P,k)),[Var(C)]'},
    'risch':{d:'Devuelve la primitiva de una expresión calculada con el algoritmo de Risch.',p:'Expr,[Var]'},
    'rm_a_z':{d:'Borra todos los nombres de variables que sólo tienen una letra minúscula como nombre.',p:'NULL'},
    'rm_all_vars':{d:'Borra todos los nombres de variables.',p:'NULL'},
    'rmbreakpoint':{d:'Quita un punto de ruptura.',p:'Intg'},
    'rmmod':{d:'Borra las librerías dinámicas instaladas.',p:'Str(pwd)'},
    'rms':{d:'',p:'Lst(X)'},
    'rmwatch':{d:'Borra una variable de la tabla de variables mostrada en paso a paso.',p:'Var'},
    'romberg':{d:'Devuelve el valor aproximado de integrate(f(x),x,a,b) por el método de Romberg.',p:'Expr(f(x)),Var(x),Real(a),Real(b)',a:['nInt']},
    'rond':{d:'Traza una circunferencia (resp un arco) de radio r (resp y de ángulo (0,a) o (a,b)), tangente a la posición de la tortuga.',p:'Real(r),[Real(a)],[Real(b)]'},
    'root':{d:'Calcula b^(1/a) (root(2,3)=sqrt(3)).',p:'Expr(a),Expr(b)'},
    'rootof':{d:'Polinomio en términos de la raíz de un Q polinomio irreducible.',p:'LstPoly(P),LstPoly(Q)'},
    'roots':{d:'Devuelve una matriz con 2 columnas y donde las filas son las raíces del polinomio con su multiplicidad (para 1 variable).',p:'Poly,[Var]'},
    'rotate':{d:'Devuelve la lista obtenida al cambiar el último elemento (o la cola a partir del n-ésimo elemento) por el primer elemento (por defecto n=-1);L:=rotate(L,n) o L.rotate(n).',p:'Lst||Str(L),[Intg(n)]'},
    'rotation':{d:'rotation(B,a1,A)(resp rotation(d,a1,A)) es la transformación de A por rotación de centro B (resp eje d) y ángulo a1.',p:'(Pnt(B) or Cplx or Dr3),Angle(a1),(Pnt(A) or Curve)'},
    'round':{d:'Redondea el número real (o complejo) al entero más cerca (o elemento de ℤ[i]), con n decimales.',p:'Real or Cplx,[Intg(n)]'},
    'row':{d:'Devuelve la fila n o la secuencia de filas n1..n2 de la matriz A, o argumento opcional de count,count_eq,count_inf,count_sup.',p:'Mtrx(A),Intg(n)||Interval(n1..n2)'},
    'rowAdd':{d:'Devuelve la matrix obtenida a partir de A reemplazando la fila n2, por la suma de las filas n1 y n2.',p:'Mtrx(A),Intg(n1),Intg(n2)'},
    'rowNorm':{d:'Devuelve el máximo de las sumas de los valores absolutos de los elementos encontrados sobre las líneas de la matriz: rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).',p:'Vect or Mtrx',a:['rownorm']},
    'rowSwap':{d:'Devuelve la matriz obtenida a partir de A intercambiando las filas n1 y n2.',p:'Mtrx(A),Intg(n1),Intg(n2)',a:['swaprow','rowswap','SWAPROW']},
    'rowdim':{d:'Número de filas de una matriz.',p:'Mtrx',a:['nrows','rowDim']},
    'rowspace':{d:'Devuelve una matriz donde las filas constituyen una base del espacio vectorial generado por las filas de la matriz A [d es la dimensión de este espacio].',p:'Mtrx(A), [Var(d)]'},
    'rref':{d:'Reducción a la forma escalonada de AX=b (M=A|(-b)) [Reducción sobre los columnas 0..k-1].',p:'Mtrx(M),[Intg(k)]||Opt',a:['gaussjord']},
    'rsolve':{d:'Valores de una secuencia recurrente o de un sistema de secuencias recurrentes.',p:'(Expr or LstExpr),(Var or LstVar),(InitVal or LstInitVal)'},
    'rur':{d:'',p:'Intg(n)'},
    'rur_certify':{d:'',p:'Intg(n)'},
    'same':{d:'Comprobación de igualdad.',p:'Expr,Expr'},
    'sample':{d:'randint(n1,n2)=un número un entero en [n1, n2] o [n2,n1].',p:'Intg(n1),Intg(n2)'},
    'samplerate':{d:'',p:'Audio(clip)'},
    'saute':{d:'La tortuga salta (avanza sin dejar marcas) de n pasos (por defecto n=10).',p:'NULL or Real(n)'},
    'save_history':{d:'Guarda el histórico de comandos en un archivo con nombre str.',p:'Str(str)'},
    'scale':{d:'Multiplica la fila n1 de la matriz A por Xpr.',p:'Mtrx(A),Expr(Xpr),Intg(n1)',a:['SCALE']},
    'scaleadd':{d:'Multiplica la fila n1 de la matriz A por Xpr, y lo añade a la fila n2.',p:'Mtrx(A),Expr(Xpr),Intg(n1),Intg(n2)',a:['SCALEADD']},
    'scatterplot':{d:'Traza para k=0..nrows, los puntos (xk,yk) donde xk=elemento fila k columna 0 e yk=elemento fila k columna j (j=1..ncols).',p:'Mtrx',a:['nuage_points']},
    'sec':{d:'Secante: sec(x)=1/cos(x).',p:'Expr'},
    'segment':{d:'segment(A,B) traza el segmento AB y segment([xM,yM],[xN,yN]) traza el vector con origen [xM,yM] de coordenadas [xN,yN] (i.e traza segment(M,point(M+N)) o Opción del comando .',p:'(Pnt or Cplx or Lst([xM,yM])),(Pnt or Cplx or Lst([xN,yN]),[Var],[Var] or Opt'},
    'seidel_spectrum':{d:'',p:'Graph(G)'},
    'seidel_switch':{d:'',p:'Graph(G),Lst(V)'},
    'select':{d:'Selecciona los elementos e de l tales que f(e)=verdadero.',p:'FncBool(f),Lst(l)'},
    'semi_augment':{d:'Devuelve una matriz formada por A y B, con n1+n2 filas y p columnas si dim(A)=[n1,p] y dim(B)=[n2,p].',p:'Mtrx(A),Mtrx(B)'},
    'seq':{d:'Devuelve la secuencia (2 o 3 arg) o la lista (4 o 5 arg) obtenida cuando var va desde a hasta b (paso=p) en Xpr (o la expresión Xpr es repetida n veces).',p:'Expr(Xpr),Var(Var)=Int(a..b),[Real(p)]||Expr(Xpr),Var(Var),Real(a),Real(b),[Real(p)]'},
    'seqsolve':{d:'Valores de una secuencia recurente (u_{n+1}=f(u_n) o u_{n+k}=f(u_n,u_{n+1}...u_{n+k-1})) o de un sistema de secuencias recurrentes.',p:'(Expr or LstExpr),(Var or LstVar),(InitVal or LstInitVal)'},
    'sequence_graph':{d:'',p:'Lst(L)'},
    'series':{d:'Desarrollo en serie finito o asintótico.',p:'Expr,Equal(var=limit_point),[Order],[Dir(1,0,-1)]'},
    'set[]':{d:'set[] o %{%} definido uno conjunto.',p:'Seq',a:['%{%}']},
    'set_channel_data':{d:'',p:'Audio(clip),Lst||Mtrx(data),[Intg(offset),Intg(chn)]||Image(img),Intg(chn),Intg(x),Intg(y),Mtrx(data)'},
    'set_edge_attribute':{d:'',p:'Graph(G),Edge(e),Seq(tag1=value1,tag2=value2,..)'},
    'set_edge_weight':{d:'',p:'Graph(G),Edge(e),Real(w)'},
    'set_graph_attribute':{d:'',p:'Graph(G),Seq(tag1=value1,tag2=value2,..)'},
    'set_pixel':{d:'',p:'Intg(x),Intg(y),Intg(col)',a:['draw_pixel']},
    'set_screen':{d:'',p:'Intg(x),Intg(y)'},
    'set_vertex_attribute':{d:'',p:'Graph(G),Vrtx(v),Seq(tag1=value1,tag2=value2,..)'},
    'set_vertex_positions':{d:'',p:'Graph(G),Lst(vp)'},
    'shift':{d:'Devuelve la lista obtenida al cambiar el último elemento (o la cola empezando al n-ésimo elemento) por el primer elemento y completada con 0 (por defecto n=-1);L:=shift(L,2) o L.shift(2).',p:'Lst,[Intg(n)]'},
    'shift_phase':{d:'shift_phase devuelve la expresión en donde las expresiones trigonométricas, una vez evaluadas, tienen fase aumentada de pi/2.',p:'Expr'},
    'shortest_path':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)||Lst(T)'},
    'show_pixels':{d:'',p:'NULL'},
    'si':{d:'Instrucción condicional : (si...alors...sinon...fsi).',a:['alors','sinon','fsi']},
    'sierpinski_graph':{d:'',p:'Intg(n),Intg(k),[triangle]'},
    'sign':{d:'Devuelve el signo (-1,0,+1) del argumento.',p:'Expr'},
    'sign2Heaviside':{d:'',p:'Expr'},
    'signature':{d:'Devuelve la signatura de una permutación.',p:'Permut'},
    'signe':{d:'Escribe la cadena s con la fuente 20 en el punto [10,10].',p:'Str(s)'},
    'similarity':{d:'similarity(B,k,a1,A)=transformación de A en la similitud (centro B o eje d, coef k, ángulo a1) (o también homothety(B,k*exp(i*a1),A)).',p:'Pnt or Dr3,Real,Angle,Pnt'},
    'simp2':{d:'Devuelve la lista [A/gcd(A,B),B/gcd(A,B)].',p:'Intg(A) or Poly(A),Intg(B) or Poly(B)'},
    'simplex_reduce':{d:'Reducción por el simplex para encontrar max(c.x) con A.x<=b y x>=0, b>=0. Devuelve el máximo,la solución aumentada x y la matriz reducida. Acepta también en argumento [[A|I|b],[-c|*|0]].',p:'Mtrx(A), Vect(b), Vect(c)'},
    'simplicial_vertices':{d:'',p:'Graph(G)'},
    'simplify':{d:'Simplifica una expresión.',p:'Expr',a:['simplifier']},
    'simplifyDirac':{d:'',p:'Expr,[Seq(vars)]'},
    'simpson':{d:'Opción del comando area',p:'Opt',a:['rombergt','rombergm','gauss15']},
    'simulated_annealing':{d:'',p:'x0,Func(cost),Func(dist),Func(step),Lst(csparam),[Lst(iterparam),[Real(maxstep)]]'},
    'simult':{d:'Devuelve la matriz donde la columna de índice k es solución de A*X=columna de índice k de B (=B[0..nf-1,k..k] con nf=número de filas de B).',p:'Mtrx(A),Mtrx(B)'},
    'sin':{d:'Seno o Opción del comando convert o convertir (id trigsin).',p:'Expr or Opt',a:['SIN']},
    'sin2costan':{d:'Reemplaza sin(x) por cos(x)*tan(x) en el argumento.',p:'Expr'},
    'sinc':{d:'',p:'Expr(x)'},
    'sincos':{d:'Transforma las exponenciales complejas en senos y cosenos (id exp2trig) o Opción del comando convert o convertir (id sincos).',p:'Expr or Opt'},
    'single_inter':{d:'Devuelve una entre las interseccións de 2 cruvas o superficies.',p:'Curve,Curve,[Pnt(A)||LstPnt(L)]',a:['line_inter']},
    'sinh':{d:'Seno hiperbólico.',p:'Expr'},
    'size':{d:'Devuelve el tamaño de una lista, cadena o secuencia de caracteres o de una secuencia.',p:'Lst||Str||Seq||Image||Audio',a:['nops','length','len']},
    'sizes':{d:'Devuelve la lista de tamaños de una lista de listas.',p:'Lst or Str or Seq'},
    'slope':{d:'Traza la pendiente de la recta definida en el argumento o es atributo de una recta.',p:'Line||Pnt||Cplx,[Pnt||Cplx]'},
    'slopeat':{d:'slopeat(d,z0) escribe en el punto point(z0), con una leyenda, el valor de la pendiente de la recta o segmento d.',p:'Line, Pnt||Cplx(z0)'},
    'slopeatraw':{d:'slopeatraw(d,z0) escribe en el punto point(z0), el valor de la pendiente de la recta o segmento d.',p:'Line, Pnt||Cplx(z0)'},
    'smith':{d:'',p:'Matr(A)'},
    'smod':{d:'Devuelve el resto simétrico de la división euclidiana de 2 enteros.',p:'Intg,Intg',a:['mods']},
    'solve':{d:'Resuelve una ecuación o un sistema de ecuaciones polinomiales.',p:'Expr,[Var]',a:['resoudre']},
    'sommet':{d:'Devuelve la cumbre de un operador.',p:'Op or Fnct'},
    'sort':{d:'Devuelve la lista (o secuencia) ordenada en orden creciente o según la función dada en segundo argumento, o ordena y recupera los términos iguales en las sumas y los productos.',p:'LstReal or Seq [Fnc]',a:['sorted']},
    'sorta':{d:'Ordena las listas en orden creciente.',p:'LstReal||Seq×||Mtrx'},
    'sortd':{d:'Ordena las listas en orden decreciente.',p:'LstReal||Seq||Mtrx'},
    'sortperm':{d:'',p:'Lst(V),[Permu(P)]'},
    'soundsec':{d:'',p:'Intg(n),[Intg(N)]'},
    'spanning_tree':{d:'',p:'Graph(G),[Vrtx(r)]'},
    'sphere':{d:'sphere(A,B) (resp sphere(A,r)) traza la esfera de diámetro AB (resp centro A Y radio r) en el espacio 3D.',p:'(Pnt or Vect),(Pnt or Real)'},
    'splice':{d:'',p:'Audio(clip1),Audio(clip2),[Intg(len),Real(p)]'},
    'spline':{d:'Spline natural pasando por los puntos dados por las listas lx y ly, variable x, de grado d.',p:'Lst(lx),Lst(ly),Var(x),Intg(d)'},
    'split':{d:'Separa las 2 variables var1,var2 de la expresión Xpr (sin no tiene denominador) o devuelve [0].',p:'(Expr(Xpr),Lst(var1,var2))||(Str(s),Str(sep))'},
    'spring':{d:'',p:'Opt'},
    'sq':{d:'Es el nombre de la función (ℝ^n -> ℝ)=suma del cuadrado de los argumentos.',p:'Seq'},
    'sqrfree':{d:'Factorización del argumento, reagrupando términos con el mismo exponente.',p:'Expr'},
    'sqrt':{d:'Raíz cuadrada.',p:'Expr'},
    'square':{d:'Devuelve y traza el cuadrado de lado AB (ABCD es directo) (en el plan ABP).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),[Pnt(P),Var(C),Var(D)]'},
    'srand':{d:'srand devuelve un entero e reinicia la secuencia de números aleatorios.',a:['randseed']},
    'sst':{d:'Ejecuta una instrucción paso a paso.',p:'NULL'},
    'sst_in':{d:'Se introduce al interior de una función en modo paso a paso.',p:'NULL'},
    'st_ordering':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)'},
    'stack':{d:'Palabra reservada.'},
    'star_graph':{d:'',p:'Intg(n)'},
    'stddev':{d:'Devuelve la desviación estándar de una lista ponderada por el segundo argumento o la lista de las desviaciones estándares de las columnas de una matriz.',p:'Lst||Mtrx,[Lst]',a:['ecart_type']},
    'stddevp':{d:'Devuelve la desviación estándar de la población de la cual viene la muestra descrita por los elementos de una lista ponderada por el segundo argumento.',p:'Lst||Mtrx,[Lst]',a:['stdDev','ecart_type_population']},
    'step':{d:'Incremento en una iteración (tamaño del salto).',a:['by','pas']},
    'stereo2mono':{d:'',p:'Audio(clip)'},
    'stft':{d:'',p:'Lst(data)'},
    'sto':{d:'Guarda el primer argumento en la variable dada como segundo argumento.',p:'(Real or Str),Var',a:['Store']},
    'str':{d:'Devuelve la expresión evaluada como una cadena de caracteres o Opción del comando convert o convertir (id string).',p:'Expr or Opt',a:['string']},
    'strip':{d:'',p:'Str(s)'},
    'strongly_connected_components':{d:'',p:'Graph(G)'},
    'student':{d:'Devuelve la densidad de probabilidad de la ley de Student (n es el número de grados de libertad).',p:'Intg(n),Real(x0)',a:['studentd']},
    'student_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley de Student sea menor que x0 (n es el número de grados de libertad).',p:'Intg(n),Real(x0)'},
    'student_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según Student sea menor que h es p (n es el número de grados de libertad).',p:'Intg(n),Real(p)'},
    'studentt':{d:'',p:'Lst,Real,[Real],Fnc,[Real]'},
    'sturm':{d:'Secuencia de Sturm asociada a un polinomio o número de cambios de signo de este polinomio en ]a;b].',p:'Poly,[Var],[Cplx(a)],[Cplx(b)]'},
    'sturmab':{d:'Número de cambios de signo de un polinomio en ]a;b] o de raíces complejas en a..b si a o b no es real.',p:'Poly,Var,Cplx(a),Cplx(b)'},
    'sturmseq':{d:'Secuencia de Sturm asociada a un polinomio o a una fracción racional.',p:'Poly,[Var]'},
    'style':{d:'Opción local (compatibilidad Maple) de una instrucción gráfica para trazar una recta punteada poniendo un style=point.',p:'Opt'},
    'subMat':{d:'Extrae una sub-matriz cuyo primer elemento es A[n1,n2] y el último es A[n3,n4].',p:'Mtrx(A),Intg(n1),Intg(n2),Intg(n3),Intg(n4).'},
    'subdivide_edges':{d:'',p:'Graph(G),Lst(E),[Intg(r)]'},
    'subgraph':{d:'',p:'Graph(G),Lst(E)'},
    'subs':{d:'Equivalente a subst excepto en modo Maple, donde los argumentos son permutados, en modo Maple escoge el segundo ejemplo.',p:'Expr or Var=value,Var=value or Expr'},
    'subsop':{d:'Reemplaza en la lista (o la matriz) el elemento de índice n por la expresión (con Maple los argumentos son permutados)(NULL suprime este elemento).',p:'Lst||Mtrx,Intg(n)=Expr'},
    'subst':{d:'Sustituye una variable por su valor en una expresión.',p:'Expr,Var(v)=value(a)',a:['substituer']},
    'subtype':{d:'Devuelve 1 para una secuencia, 2 para uno conjunto, 10 para uno polinómio y 0 si no.',p:'Expr'},
    'sum':{d:'Suma discreta o suma de elementos de una lista (o secuencia).',p:'Expr,Var,VarMin(a),VarMax(b),[VarStep(p)]',a:['somme','add']},
    'sum_riemann':{d:'Devuelve un equivalente en la vecindad de var1=+infini de la suma de Xpr(var1,var2) para var2:=1 a var1 cuando la suma es una suma de Riemann.',p:'Expr(Xpr),Lst(var1,var2)'},
    'suppress':{d:'Devuelve L sin el elemento de índice n; L:=suppress(L,n) o L.suppress(n).',p:'Vect(L)||Str(l),Intg(n)'},
    'surd':{d:'Potencia 1/n.',p:'Expr,Intg(n)'},
    'svd':{d:'Para una matriz cuadrada real numérica A, devuelve U ortogonal, S vector de Singular Values, Q ortogonal tales que A=U*diag(S)*tran(Q).',p:'Mtrx(A)'},
    'switch':{d:'Comprobación (múltiples opciones): switch(variable) {case 1: {bloc1;} default: {bloc2;}};'},
    'switch_axes':{d:'switch_axes() pone o quita los ejes en la pantalla de geometría.',p:'[Intg(0 or 1)]'},
    'sylvester':{d:'Matriz de Sylvester de 2 polinomios.',p:'Poly,Poly,Var'},
    'symb2poly':{d:'Devuelve los coeficientes de un polinomio con respecto al segundo argumento.',p:'Expr, LstVar or [Var]',a:['e2r']},
    'symbol_array':{d:'',p:'Strng(str),Seq(dim)'},
    'syst2mat':{d:'Devuelve la matriz M=A|(-b) asociada al sistema Y=AX+b.',p:'LstLinEq,LstVar'},
    'syzygy':{d:'',p:'List'},
    'table':{d:'Define una matriz cuyos índices son cadenas o números reales o define una table a partir de matriz .',p:'SeqEqual(index=value)'},
    'tablefunc':{d:'Tabla de valores de una función: debemos estar en una hoja de balance.',p:'Expr,Var'},
    'tableseq':{d:'Tabla de valores de una secuencia (en una hoja de balance).',p:'Expr,(Var or LstVar),(InitVal or LstInitVal)'},
    'tabsign':{d:'',p:'Expr,Var'},
    'tabvar':{d:'Tabla de variacións de una función.',p:'Expr,Var'},
    'tail':{d:'Devuelve la lista (o secuencia o cadena) sin su primer elemento.',p:'Lst or Seq or Str'},
    'tan':{d:'Tangente o Opción del comando convert o convertir (id halftan)',p:'Expr',a:['TAN']},
    'tan2cossin2':{d:'Reemplaza tan(x) por (1-cos(2*x))/sin(2*x) en el argumento.',p:'Expr'},
    'tan2sincos':{d:'Reemplaza tan(x) por sin(x)/cos(x) en el argumento.',p:'Expr'},
    'tan2sincos2':{d:'Reemplaza tan(x) por sin(2*x)/(1+cos(2*x)) en el argumento.',p:'Expr'},
    'tangent':{d:'tangent(C,A) traza la tangente (recta o plano) a C pasando por A.',p:'Curve(C),Pnt(A)',a:['tangente']},
    'tanh':{d:'Tangente hiperbólica.',p:'Expr'},
    'tantque':{d:'Bucle tantque (tantque...faire...ftantque;).'},
    'tar':{d:'',p:'String || Buffer || Buffer,String || Buffer,Int,String'},
    'taux_accroissement':{d:'',p:'Expr,Var,Val1,(Val1+Var or Val2)'},
    'taylor':{d:'Desarrollo en serie alrededor de puntos finitos o infinitos (por defecto x=0, orden relativo=5).',p:'Expr,[Var=limit_point],[Order]'},
    'tchebyshev1':{d:'Devuelve el n-ésimo polinomio de Tchebyshev de primer tipo.',p:'Intg(n)'},
    'tchebyshev2':{d:'Devuelve el n-ésimo polinomio de Tchebyshev de segundo tipo.',p:'Intg(n)'},
    'tcoeff':{d:'Devuelve el coeficiente del término de menor grado de un polinomio (t=trailing).',p:'Poly||Lst'},
    'tcollect':{d:'Agrupa expresiones trigonométricas.',p:'Expr',a:['tCollect','rassembler_trigo']},
    'tdeg':{d:'Opción del comando gbasis o greduce para especificar un orden sobre los monomios (grado total, luego orden lexicográfico).',p:'Opt'},
    'tensor_product':{d:'',p:'Seq(G1,G2,[G3])'},
    'test':{d:'Función de comprobación para desarrolladores.',p:'Var'},
    'texpand':{d:'Expande expresiones transcendentales.',p:'Expr',a:['tExpand','developper_transcendant']},
    'then':{d:'Usado en una comprobación if: if (condition) then instruction; end_if;'},
    'thickness':{d:'Opción (compatibilidad Maple) de una instrucción gráfica para definir el grosor de las líneas.',p:'Opt',a:['epaisseur']},
    'thiele':{d:'',p:'[Mtrx(P) || List(X)],[List(Y)],[Var(x)]'},
    'threshold':{d:'',p:'Lst,Real(bound)[=Expr(repl)] or Lst[Real(lower)[=Expr(rl)],Real(upper)[=Expr(ru)]],[Fnc(compare)],[abs[=true or false]]'},
    'time':{d:'Devuelve el tiempo de cálculo del comando o desde el inicio de la sesión.',p:'NULL'},
    'title':{d:'Opción global de una instrucción gráfica para poner un título al gráfico.',p:'Opt',a:['titre']},
    'tlin':{d:'Linealización trigonométrica',p:'ExprTrig',a:['lineariser_trigo']},
    'tonnetz':{d:'',p:'Intg(a),Intg(b),Intg(c),[Intg(d)]'},
    'topologic_sort':{d:'',p:'Graph(G)',a:['topological_sort']},
    'torus_grid_graph':{d:'',p:'Intg(m),Intg(n)'},
    'total_degree':{d:'',p:'Poly(P),Lst(Vars)'},
    'tourne_droite':{d:'La tortuga gira a la derecha de n grados (por defecto n=90).',p:'NULL or Real(n)'},
    'tourne_gauche':{d:'La tortuga gira a la izquierda de n grados (por defecto n=90).',p:'NULL or Real(n)'},
    'tpsolve':{d:'',p:'List(supply),List(demand),Mtrx(cost_matrix)'},
    'trace':{d:'Devuelve la traza de una matriz cuadrada o dibuja la traza de un objeto geométrico cuando los valores del parámetro cambian (ver Trace en el botón Menu de un nivel de geometría y escribe solamente una instrucción por línea).',p:'Mtrx or GeoObj'},
    'trail':{d:'',p:'Seq(V)'},
    'trail2edges':{d:'',p:'Trail(T)'},
    'train':{d:'',p:'NeuralNet(net),Mtrx(input),Mtrx||Vect(expected_output),[Intg(batchsize)])'},
    'tran':{d:'Transpone una matriz (sin conjugación).',p:'Mtrx',a:['transpose']},
    'transitive_closure':{d:'',p:'Graph(G),[weighted[=true||false]]'},
    'translation':{d:'translation(B-A,C) (resp translation([a,b,c],C)) es el traslado de C en la translación de vector AB (resp [a,b,c]).',p:'Vect, Pnt(C)'},
    'trapezoid':{d:'Opción del comando plotarea y del comando area.',p:'Opt',a:['middle_point','left_rectangle','right_rectangle','trapeze','point_milieu','rectangle_droit','rectangle_gauche']},
    'traveling_salesman':{d:'',p:'Graph(G),[Mtrx(M)],[opts]'},
    'tree':{d:'',p:'Opt'},
    'tree_height':{d:'',p:'Graph(T),[Vrtx(r)]'},
    'tri':{d:'',p:'Expr(x)'},
    'triangle':{d:'triangle(A,B,C) traza el triángulo ABC',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'triangle_paper':{d:'Traza las filas de la red formada por las rectas y=n*uy e en los ejes OxY de ángulo t!=0 las rectas x=n*ux e ux*y+uy*x=n*ux*uy.',p:'Real(ux),Real(t),Real(uy),[x=xmin..xmax,y=ymin..ymax]'},
    'triangle_plein':{d:'Traza un triángulo lleno directo de lados a,b y de ángulo t, a partir de la posición de la tortuga (por defecto t=90 o (b=a y t=60)).',p:'Real(a),[Real(b)],[Real(t)]'},
    'triangle_window':{d:'',p:'Lst,[Intg(d)],[Interval(n1..n2)]'},
    'trig2exp':{d:'Reemplaza en el argumento las funciones trigonométricas por exponenciales complejas sin linealización.',p:'Expr'},
    'trigcos':{d:'Simplifica el argumento usando las fórmulas sin(x)^2+cos(x)^2=1 y tan(x)=sin(x)/cos(x) prefiriendo los cosenos.',p:'Expr'},
    'trigexpand':{d:'Desarrolla las funciones trigonométricas.',p:'Expr'},
    'triginterp':{d:'',p:'List,Var=xmin..xmax'},
    'trigsimplify':{d:'',p:'Expr'},
    'trigsin':{d:'Simplifica el argumento usando las fórmulas sin(x)^2+cos(x)^2=1 y tan(x)=sin(x)/cos(x) prefiriendo senos.',p:'Expr'},
    'trigtan':{d:'Simplifica el argumento usando las fórmulas sin(x)^2+cos(x)^2=1 y tan(x)=sin(x)/cos(x) prefiriendo tangentes.',p:'Expr'},
    'trim':{d:'',p:'(Str||Vect||Audio||Image)(s),[opts],[left|right],[index]'},
    'trn':{d:'Devuelve la matriz adjunta de A=tran(conj(A)).',p:'Mtrx'},
    'true':{d:'Tipo de dato lógico (booleano) que vale verdadero o 1.',a:['TRUE','True']},
    'trunc':{d:'Devuelve el argumento sin su parte fraccional o trunca el argumento con n decimales (type=DOM_COMPLEX o DOM_FLOAT).',p:'Real||LstReal,Int(n)'},
    'truncate':{d:'Trunca el polinomio P al orden n.',p:'Poly(P),Intg(n)'},
    'truncate_graph':{d:'',p:'Graph(G)'},
    'try':{d:'Protección contra errores: try {instructions;} catch(variable) {error_instructions;} (dentro de un programa).'},
    'tsimplify':{d:'Disminuye el número de variables no racionales.',p:'Expr'},
    'tukey_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'tutte_polynomial':{d:'',p:'Graph(G),[Var(x),Var(y)]'},
    'two_edge_connected_components':{d:'',p:'Graph(G)'},
    'type':{d:'Devuelve n de [1..12] que define el tipo del argumento.',p:'Expr'},
    'ufactor':{d:'Factoriza una unidad en un objeto-unidad',p:'Unit,Unit'},
    'ugamma':{d:'Calcula los valores de la función ugamma en el punto (a,x):si a,x>=0 ugamma(a,x)=int(e^{-t}*t^{a-1},t=..inf),(ugamma(a,x)+igamma(a,x)=Gamma(a)).',p:'Real(a),Real(x),[1]'},
    'unapply':{d:'Devuelve una función definida por una expresión.',p:'Expr,Var'},
    'unarchive':{d:'Lee los valores de una variable o de una lista de variables que se encuentran en el archivo dado como argumento (archivo creado con archive).',p:'Str(namefich),Seq(Var)'},
    'undef':{d:''},
    'underlying_graph':{d:'',p:'Graph(G)'},
    'unfactored':{d:'Opción del comando plotimplicit.',p:'Opt.',a:['sans_factoriser']},
    'uniform':{d:'Devuelve la densidad de probabilidad de la ley de uniform.',p:'Real(a),Real(b),Real(x)',a:['uniformd']},
    'uniform_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley uniform sea menor que x0.',p:'Real(a),Real(b),Real(x0),[Real(y0)]',a:['uniformd_cdf']},
    'uniform_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según ley uniform sea menor que h es p (0<=p<=1).',p:'Real(a),Real(b),Real(p)',a:['uniformd_icdf']},
    'union':{d:'union es un operador infijo para obtener la unión de dos conjuntos.',p:'(Vect or Set),(Vect or Set)'},
    'unquote':{d:'Evalua una expresión entre comillas (por ejemplo purge(c);a:=c;unquote(a):=3; pone 3 en las variables a y c).',p:'Expr'},
    'upper':{d:'',p:'Mtrx||Strng'},
    'user_operator':{d:'Definición de un operador binario y devuelve 0 (fracaso) o 1 (éxito).',p:'Str(R),Fnc(f),Opt(Binary||Unary||Delete)'},
    'usimplify':{d:'Simplifica una unidad en un objeto-unidad',p:'Unit'},
    'valuation':{d:'Devuelve la evaluación del polinómio P (grado del término de grado menor).',p:'Poly(P)',a:['ldegree']},
    'vandermonde':{d:'Devuelve la matriz de Vandermonde=[V^0,V^1,..].',p:'Vect(V)'},
    'variables_are_files':{d:'Nombre que permite especificar si se quieren guardar las variables como "nombredevariable.cas".',p:':=Intg(0 or 1)'},
    'variance':{d:'Devuelve la varianza de los elementos de su argumento ponderado con el segundo argumento o la lista de varianzas de las columnas de una matriz.',p:'Lst||Mtrx,[Lst]'},
    'vector':{d:'Define un vector por dos puntos o por un par de coordenadas o por un par de afijos (en 2D) o con un punto y un vector o con un punto A (con origen [0,0,0]).',p:'Pnt,Pnt || Pnt,Vect'},
    'vers':{d:'Pone la tortuga en dirección del punto dado en argumento.',p:'Real,Real'},
    'version':{d:'Devuelve el número de versión de giac que se está usando: giac 0.4.0',p:'NULL'},
    'vertex_connectivity':{d:'',p:'Graph(G)'},
    'vertex_cover_number':{d:'',p:'Graph(G)'},
    'vertex_degree':{d:'',p:'Graph(G),Vrtx(v)'},
    'vertex_distance':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)||Lst(T)'},
    'vertex_in_degree':{d:'',p:'Graph(G),Vrtx(v)'},
    'vertex_out_degree':{d:'',p:'Graph(G),Vrtx(v)'},
    'vertices':{d:'Devuelve la lista de los vértices de un polígono o poliedro P.',p:'Polygon or Polyedr(P)',a:['vertices_abc']},
    'vertices_abca':{d:'Devuelve la lista [A,B,...A] de los vértices de un polígono o poliedro P.',p:'Polygon or Polyedr(P)'},
    'vpotential':{d:'Devuelve U tal que curl(U)=V.',p:'Vect(V),LstVar'},
    'watch':{d:'Añade una variable a la lista de las variables mostradas en paso a paso.',p:'Var'},
    'web_graph':{d:'',p:'Intg(a),Intg(b)'},
    'weibull':{d:'Devuelve la densidad de probabilidad de la ley de Weibull.',p:'Real(k),Real(lambda),Real(theta),Real(x)',a:['weibulld']},
    'weibull_cdf':{d:'Devuelve la probabilidad que una variable aleatoria según ley Weibull sea menor que x0.',p:'Real(k),Real(lambda),Real(theta),Real(x0)',a:['weibulld_cdf']},
    'weibull_icdf':{d:'Devuelve h tal que la probabilidad que una variable aleatoria según ley Weibull sea menor que h es p (0<=p<=1).',p:'Real(k),Real(lambda),Real(theta),Real(p)',a:['weibulld_icdf']},
    'weight_matrix':{d:'',p:'Graph(G)'},
    'weighted':{d:'',p:'Opt'},
    'weights':{d:'',p:'Opt'},
    'welch_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'wheel_graph':{d:'',p:'Intg(n)'},
    'when':{d:'Si condición (aún simbólica) devuelve Expr1 sino devuelve Expr2 (? es la versión infija de when).',p:'Cond,Expr1,Expr2'},
    'while':{d:'Bucle mientras (realiza la instrucción mientras cond==verdadero): while (cond) {i1;i2;};'},
    'white':{d:'Opción de la instrucción display para colores.',p:'Opt',a:['black','red','green','blue','yellow','magenta','cyan','orange','purple','pink','grey','brown','olive','teal','navy','gold','violet']},
    'widget_size':{d:'Cambia el tamaño de los carácters de la pantalla en xcas (tamaño=n) y con más parámetros define la configuración general.',p:'Intg(n)'},
    'wilcoxonp':{d:'',p:'Intg,[Intg]'},
    'wilcoxons':{d:'',p:'List,List || Real'},
    'wilcoxont':{d:'',p:'List,List || Real,[Func],[Real]'},
    'with_sqrt':{d:'',p:':=Intg(0 or 1)'},
    'write':{d:'Para escribir en el archivo fich_name las variables y sus valores.',p:'Str(fich_name),SeqVar',a:['sauve']},
    'writergb':{d:'Graba un archivo PNG imagen de nombres a partir de la lista [[number_channels,width,height],red,green,alpha,blue] donde red,green,alpha,blue son matrices.',p:'Str(s),Lst'},
    'writewav':{d:'Graba un archivo de sonido en el formato WAV.',p:'Str(s),Lst(l)'},
    'wz_certificate':{d:'',p:'Expr(U),[Expr(res)],[Var(n),Var(k)]'},
    'xcas_mode':{d:'Cambia a modo Xcas (0), Maple (1), Mupad (2), TI89 (3).',p:'Intg(0) or 1 or 2 or 3',a:['maple_mode']},
    'xml_print':{d:'',p:'Str'},
    'xor':{d:'O exclusivo (operador no fijado).',p:'Expr, Expr'},
    'xstep':{d:'',p:'Opt',a:['ystep','zstep','nstep','tstep','ustep','vstep']},
    'xyz2rgb':{d:'',p:'Lst(x,y,z)'},
    'xyztrange':{d:'xyztrange permite inicializar la pantalla de geometría (cf botón Cfg).',p:'SeqReal'},
    'zeros':{d:'Devuelve la lsita de zeros (reales o complejos según el modo) de la expresión (o la matriz cuyas filas son soluciones del sistema : expression1=0,expression2=0...).',p:'Expr,[Var]'},
    'zip':{d:'Devuelve la lista cuya j-ésimo elemento es f(l1[j],l2[j]): sin ningún valor por defecto, su largo es el mínimo de los largos de l1 y l2, y si no la lista más corta está completada con el valor por defecto.',p:'Fnc2d(f),Lst(l1),Lst(l2),[Val(default)]'},
    'znorder':{d:'',p:'Intg'},
    'znprimroot':{d:'',p:'Intg'},
    'ztrans':{d:'Transformada en z de una secuencia',p:'Expr,[Var],[ZtransVar]'},
    '{}':{d:'Bloque de instrucciones.'},
    '|':{d:'Operador infijo. Sustituye una variable por su valor en una expresión.',p:'Expr, Var(v1)=value(a1)[,v2=a2,...]'}
  },
  aliases: {
    '%':'mod',
    '%{%}':'set[]',
    '&&':'and',
    'ACOSH':'acosh',
    'ACOT':'acot',
    'ACSC':'acsc',
    'ASEC':'asec',
    'ASIN':'asin',
    'ASINH':'asinh',
    'ATAN':'atan',
    'ATANH':'atanh',
    'COS':'cos',
    'COSH':'cosh',
    'COT':'cot',
    'CSC':'csc',
    'ClrDraw':'ClrGraph',
    'DIGITS':'Digits',
    'DOM_int':'DOM_INT',
    'DelVar':'purge',
    'Disp':'print',
    'DrawFunc':'plotfunc',
    'DrawParm':'plotparam',
    'DrawPol':'plotpolar',
    'DrwCtour':'plotcontour',
    'ERROR':'error',
    'EXP':'exp',
    'EndDlog':'Dialog',
    'FALSE':'false',
    'False':'false',
    'Graph':'plotfunc',
    'IFTE':'ifte',
    'Input':'input',
    'LN':'ln',
    'NORMALD':'normald',
    'Output':'output',
    'Phi':'euler',
    'Pi':'pi',
    'PopUp':'choosebox',
    'ReLU':'MSE',
    'SCALE':'scale',
    'SCALEADD':'scaleadd',
    'SIN':'sin',
    'SWAPCOL':'colSwap',
    'SWAPROW':'rowSwap',
    'Store':'sto',
    'TAN':'tan',
    'TRUE':'true',
    'TeX':'latex',
    'True':'true',
    '[..]':'i[]',
    'adaptive':'MSE',
    'add':'sum',
    'alors':'si',
    'approx':'evalf',
    'arccos':'acos',
    'arccosh':'acosh',
    'arclen':'arcLen',
    'arcsin':'asin',
    'arcsinh':'asinh',
    'arctan':'atan',
    'arctanh':'atanh',
    'areaplot':'plotarea',
    'augment':'concat',
    'backward':'recule',
    'barplot':'bar_plot',
    'berlekamp_massey':'reverse_rsolve',
    'betavariate':'randbetad',
    'bezout_entiers':'iegcd',
    'black':'white',
    'block_size':'MSE',
    'blue':'white',
    'brent_solver':'bisection_solver',
    'brown':'white',
    'by':'step',
    'cSolve':'csolve',
    'cap_flat_line':'dash_line',
    'cap_round_line':'dash_line',
    'cap_square_line':'dash_line',
    'cauchyd':'cauchy',
    'cauchyd_cdf':'cauchy_cdf',
    'cauchyd_icdf':'cauchy_icdf',
    'ceiling':'ceil',
    'cfactor':'cFactor',
    'charpoly':'pcar',
    'chisquared':'chisquare',
    'chisquared_cdf':'chisquare_cdf',
    'chisquared_icdf':'chisquare_icdf',
    'chr':'char',
    'close':'fclose',
    'coeffs':'coeff',
    'colDim':'coldim',
    'colnorm':'colNorm',
    'color':'display',
    'colswap':'colSwap',
    'complex':'DOM_COMPLEX',
    'cond':'COND',
    'contourplot':'plotcontour',
    'convertir':'convert',
    'courbe_parametrique':'plotparam',
    'courbe_polaire':'plotpolar',
    'crossP':'cross',
    'cross_entropy':'MSE',
    'cross_point':'rhombus_point',
    'crossproduct':'cross',
    'cumsum':'cumSum',
    'cyan':'white',
    'dashdot_line':'dash_line',
    'dashdotdot_line':'dash_line',
    'deSolve':'desolve',
    'del':'purge',
    'densityplot':'plotdensity',
    'derive':'diff',
    'deriver':'diff',
    'developper':'expand',
    'developper_transcendant':'texpand',
    'divide':'quorem',
    'divisors':'idivis',
    'divmod':'iquorem',
    'dotP':'dot',
    'dotprod':'dot',
    'double':'DOM_FLOAT',
    'draw_pixel':'set_pixel',
    'droit':'right',
    'dsolve':'desolve',
    'e2r':'symb2poly',
    'ecart_type':'stddev',
    'ecart_type_population':'stddevp',
    'eigVc':'egv',
    'eigVl':'egvl',
    'eigenvalues':'eigenvals',
    'eigenvectors':'egv',
    'eigenvects':'egv',
    'end_for':'end',
    'end_if':'end',
    'end_while':'end',
    'entry':'quest',
    'epaisseur':'thickness',
    'epaisseur_ligne_1':'line_width_1',
    'epaisseur_ligne_2':'line_width_1',
    'epaisseur_ligne_3':'line_width_1',
    'epaisseur_ligne_4':'line_width_1',
    'epaisseur_ligne_5':'line_width_1',
    'epaisseur_ligne_6':'line_width_1',
    'epaisseur_ligne_7':'line_width_1',
    'epaisseur_point_1':'point_width_1',
    'epaisseur_point_2':'point_width_1',
    'epaisseur_point_3':'point_width_1',
    'epaisseur_point_4':'point_width_1',
    'epaisseur_point_5':'point_width_1',
    'epaisseur_point_6':'point_width_1',
    'epaisseur_point_7':'point_width_1',
    'est_permu':'is_permu',
    'et':'and',
    'evala':'normal',
    'evalm':'eval',
    'exact':'float2rational',
    'execute':'expr',
    'exponentiald':'exponential',
    'exponentiald_cdf':'exponential_cdf',
    'exponentiald_icdf':'exponential_icdf',
    'expovariate':'randexp',
    'expression':'DOM_SYMBOLIC',
    'extend':'concat',
    'facteurs_premiers':'ifactors',
    'factoriser':'factor',
    'factoriser_entier':'ifactor',
    'factoriser_sur_C':'cFactor',
    'faire':'do',
    'falsepos_solver':'bisection_solver',
    'fdistrib':'expand',
    'ffaire':'end',
    'ffonction':'end',
    'ffunction':'end',
    'fi':'end',
    'fieldplot':'plotfield',
    'fisherd':'fisher',
    'fisherd_cdf':'fisher_cdf',
    'fisherd_icdf':'fisher_icdf',
    'float':'DOM_FLOAT',
    'fonction':'function',
    'fonction_derivee':'function_diff',
    'forward':'avance',
    'fpour':'end',
    'frac':'fPart',
    'from':'de',
    'fsi':'end',
    'ftantque':'end',
    'fullparfrac':'parfrac',
    'func':'DOM_FUNC',
    'funcplot':'plotfunc',
    'fxnd':'f2nd',
    'gammavariate':'randgammad',
    'gauche':'left',
    'gauss15':'simpson',
    'gaussjord':'rref',
    'gcdex':'egcd',
    'gl_y':'gl_x',
    'gl_y_axis_color':'gl_x_axis_color',
    'gl_y_axis_name':'gl_x_axis_name',
    'gl_y_axis_unit':'gl_x_axis_unit',
    'gl_ytick':'gl_xtick',
    'gl_z':'gl_x',
    'gl_z_axis_color':'gl_x_axis_color',
    'gl_z_axis_name':'gl_x_axis_name',
    'gl_z_axis_unit':'gl_x_axis_unit',
    'gl_ztick':'gl_xtick',
    'gold':'white',
    'graphe':'plot',
    'graphe3d':'plot3d',
    'graphe_suite':'plotseq',
    'green':'white',
    'grey':'white',
    'heading':'cap',
    'hold':'quote',
    'hybrid_solver':'dnewton_solver',
    'hybridj_solver':'dnewton_solver',
    'hybrids_solver':'dnewton_solver',
    'hybridsj_solver':'dnewton_solver',
    'ichrem':'ichinrem',
    'identifier':'DOM_IDENT',
    'idn':'identity',
    'igcd':'gcd',
    'igcdex':'iegcd',
    'imag':'im',
    'implicitplot':'plotimplicit',
    'indets':'lname',
    'inequationplot':'plotinequation',
    'inf':'+infinity',
    'intDiv':'iquo',
    'integer':'DOM_INT',
    'integrate':'int',
    'integrer':'int',
    'interactive_odeplot':'interactive_plotode',
    'inverse':'inv',
    'invisible_point':'rhombus_point',
    'invlaplace':'ilaplace',
    'iratrecon':'fracmod',
    'isPrime':'isprime',
    'jusqu_a':'repeat',
    'jusqua':'repeat',
    'kde':'kernel_density',
    'kernel':'ker',
    'l2norm':'norm',
    'ldegree':'valuation',
    'learning_rate':'MSE',
    'left_rectangle':'trapezoid',
    'len':'size',
    'length':'size',
    'lhs':'left',
    'ligne_chapeau_carre':'dash_line',
    'ligne_chapeau_plat':'dash_line',
    'ligne_chapeau_rond':'dash_line',
    'ligne_polygonale':'polygonplot',
    'ligne_polygonale_pointee':'polygonscatterplot',
    'ligne_tiret':'dash_line',
    'ligne_tiret_point':'dash_line',
    'ligne_tiret_pointpoint':'dash_line',
    'ligne_trait_plein':'dash_line',
    'limite':'limit',
    'line_inter':'single_inter',
    'line_width_2':'line_width_1',
    'line_width_3':'line_width_1',
    'line_width_4':'line_width_1',
    'line_width_5':'line_width_1',
    'line_width_6':'line_width_1',
    'line_width_7':'line_width_1',
    'lineariser':'lin',
    'lineariser_trigo':'tlin',
    'lis':'input',
    'lis_phrase':'InputStr',
    'log':'ln',
    'log_loss':'MSE',
    'lp_bestlocalbound':'lp_assume',
    'lp_bestprojection':'lp_assume',
    'lp_binary':'lp_assume',
    'lp_binaryvariables':'lp_assume',
    'lp_breadthfirst':'lp_assume',
    'lp_depthfirst':'lp_assume',
    'lp_depthlimit':'lp_assume',
    'lp_firstfractional':'lp_assume',
    'lp_gaptolerance':'lp_assume',
    'lp_heuristic':'lp_assume',
    'lp_hybrid':'lp_assume',
    'lp_integer':'lp_assume',
    'lp_integervariables':'lp_assume',
    'lp_interiorpoint':'lp_assume',
    'lp_iterationlimit':'lp_assume',
    'lp_lastfractional':'lp_assume',
    'lp_maxcuts':'lp_assume',
    'lp_maximize':'lp_assume',
    'lp_method':'lp_assume',
    'lp_mostfractional':'lp_assume',
    'lp_nodelimit':'lp_assume',
    'lp_nodeselect':'lp_assume',
    'lp_nonnegative':'lp_assume',
    'lp_nonnegint':'lp_assume',
    'lp_presolve':'lp_assume',
    'lp_pseudocost':'lp_assume',
    'lp_simplex':'lp_assume',
    'lp_timelimit':'lp_assume',
    'lp_varselect':'lp_assume',
    'lp_verbose':'lp_assume',
    'lsq':'LSQ',
    'magenta':'white',
    'maple_mode':'xcas_mode',
    'middle_point':'trapezoid',
    'mods':'smod',
    'momentum':'MSE',
    'moustache':'boxwhisker',
    'moyenne':'mean',
    'mul':'product',
    'multiplier_conjugue':'mult_conjugate',
    'multiplier_conjugue_complexe':'mult_c_conjugate',
    'nCr':'comb',
    'nInt':'romberg',
    'nPr':'perm',
    'navy':'white',
    'ncols':'coldim',
    'newton_solver':'bisection_solver',
    'newtonj_solver':'dnewton_solver',
    'nlp_binary':'nlp_initialpoint',
    'nlp_binaryvariables':'nlp_initialpoint',
    'nlp_integer':'nlp_initialpoint',
    'nlp_integervariables':'nlp_initialpoint',
    'nlp_iterationlimit':'nlp_initialpoint',
    'nlp_maximize':'nlp_initialpoint',
    'nlp_method':'nlp_initialpoint',
    'nlp_nonnegative':'nlp_initialpoint',
    'nlp_nonnegint':'nlp_initialpoint',
    'nlp_precision':'nlp_initialpoint',
    'nlp_presolve':'nlp_initialpoint',
    'nlp_tolerance':'nlp_initialpoint',
    'nlp_verbose':'nlp_initialpoint',
    'non':'not',
    'nonnegint':'lp_assume',
    'nops':'size',
    'normald_cdf':'normal_cdf',
    'normald_icdf':'normal_icdf',
    'normalvariate':'randnorm',
    'nrows':'rowdim',
    'nstep':'xstep',
    'nuage_points':'scatterplot',
    'nullspace':'ker',
    'od':'end',
    'odeplot':'plotode',
    'olive':'white',
    'op':'feuille',
    'orange':'white',
    'otherwise':'default',
    'ou':'or',
    'paramplot':'plotparam',
    'pas':'step',
    'pcoef':'pcoeff',
    'pencolor':'crayon',
    'pendown':'baisse_crayon',
    'penup':'leve_crayon',
    'pie':'camembert',
    'pink':'white',
    'plotimf':'imfplot',
    'plotlist':'listplot',
    'plus_point':'rhombus_point',
    'point_carre':'rhombus_point',
    'point_croix':'rhombus_point',
    'point_etoile':'rhombus_point',
    'point_invisible':'rhombus_point',
    'point_losange':'rhombus_point',
    'point_milieu':'trapezoid',
    'point_plus':'rhombus_point',
    'point_point':'rhombus_point',
    'point_triangle':'rhombus_point',
    'point_width_2':'point_width_1',
    'point_width_3':'point_width_1',
    'point_width_4':'point_width_1',
    'point_width_5':'point_width_1',
    'point_width_6':'point_width_1',
    'point_width_7':'point_width_1',
    'polarplot':'plotpolar',
    'polyEval':'peval',
    'powermod':'powmod',
    'propFrac':'propfrac',
    'purple':'white',
    'quadrant2':'quadrant1',
    'quadrant3':'quadrant1',
    'quadrant4':'quadrant1',
    'r2e':'poly2symb',
    'ramene':'read',
    'randMat':'ranm',
    'randNorm':'randnorm',
    'randPoly':'randpoly',
    'randmatrix':'ranm',
    'random':'rand',
    'randseed':'srand',
    'randvar':'random_variable',
    'ranv':'randvector',
    'rassembler_trigo':'tcollect',
    'rational':'DOM_RAT',
    'real':'re',
    'rectangle_droit':'trapezoid',
    'rectangle_gauche':'trapezoid',
    'red':'white',
    'redim':'REDIM',
    'remain':'irem',
    'repeter':'repeat',
    'replace':'REPLACE',
    'resoudre':'solve',
    'resoudre_dans_C':'csolve',
    'resoudre_systeme_lineaire':'linsolve',
    'reverse':'revlist',
    'rhs':'right',
    'right_rectangle':'trapezoid',
    'rombergm':'simpson',
    'rombergt':'simpson',
    'rowDim':'rowdim',
    'rownorm':'rowNorm',
    'rowswap':'rowSwap',
    'sans_factoriser':'unfactored',
    'sauve':'write',
    'scalarProduct':'dot',
    'scalar_product':'dot',
    'schur':'SCHUR',
    'secant_solver':'bisection_solver',
    'seqplot':'plotseq',
    'shuffle':'randperm',
    'simplifier':'simplify',
    'sinon':'si',
    'sleep':'Pause',
    'snedecor':'fisher',
    'snedecor_cdf':'fisher_cdf',
    'snedecor_icdf':'fisher_icdf',
    'snedecord':'fisher',
    'snedecord_cdf':'fisher_cdf',
    'snedecord_icdf':'fisher_icdf',
    'solid_line':'dash_line',
    'somme':'sum',
    'sorted':'sort',
    'square_point':'rhombus_point',
    'star_point':'rhombus_point',
    'stdDev':'stddevp',
    'steffenson_solver':'bisection_solver',
    'string':'str',
    'studentd':'student',
    'substituer':'subst',
    'swapcol':'colSwap',
    'swaprow':'rowSwap',
    'symbol':'DOM_SYMBOLIC',
    'tCollect':'tcollect',
    'tExpand':'texpand',
    'tangente':'tangent',
    'teal':'white',
    'tetrahedron':'pyramid',
    'textinput':'InputStr',
    'throw':'error',
    'titre':'title',
    'to':'jusque',
    'topological_sort':'topologic_sort',
    'topology':'MSE',
    'trames':'frames',
    'transpose':'tran',
    'trapeze':'trapezoid',
    'triangle_point':'rhombus_point',
    'tstep':'xstep',
    'tuer':'kill',
    'uniformd':'uniform',
    'uniformd_cdf':'uniform_cdf',
    'uniformd_icdf':'uniform_icdf',
    'unitV':'normalize',
    'until':'repeat',
    'ustep':'xstep',
    'var':'local',
    'vertices_abc':'vertices',
    'violet':'white',
    'vstep':'xstep',
    'weibulld':'weibull',
    'weibulld_cdf':'weibull_cdf',
    'weibulld_icdf':'weibull_icdf',
    'weibullvariate':'randweibulld',
    'weight_decay':'MSE',
    'yellow':'white',
    'ystep':'xstep',
    'zstep':'xstep',
    '||':'or'
  }
};
