'use strict';
// Auto-generated from giac aide_cas — do not edit manually
// Generated: 2026-03-01
// Language: German (de)
// Commands: 1731 | Aliases: 481 | Descriptions: 1282 (74.1%)
// Source: https://raw.githubusercontent.com/s-celles/giac/main/doc/aide_cas

var GIAC_HELP = {
  cmds: {
    '!':{d:'Gibt das logische Inverse zurück, wenn als Präfix gebraucht und Fakultät, wenn als Infix gebraucht.',p:'Boolean'},
    '!=':{d:'Boolescher Infix-Operator, der die Nicht-Gleichheit testet.',p:'Expr,Expr'},
    '#':{d:'Transformiert (in einem Programm) einen String in den Namen einer Variablen',p:'Str'},
    '$':{d:'infix Version von seq.',p:'(Expr(Var)||Int(a..b)),(Var(Var)=Int(a..b))||Intg(n)||Real(p)'},
    '%/':{d:'',p:'Intg(a),Intg(b)'},
    '&*':{d:'Matrixmultiplikation (infix-Operator, &* kompatibel mit Maple)',p:'Mtrx,Mtrx'},
    '&^':{d:'Berechnet die n-te Potenz eines jeden Elements einer Matrix (infix-Operator, TI kompatibel)',p:'Mtrx,Intg(n)'},
    '\'':{d:'Gibt die Ableitung bzgl. des zweiten Arguments zurück. (postfix-Version von diff).',p:'Strng(str)'},
    '()':{d:'() gibt den Wert einer Funktion zurück oder substituiert Werte in einem Ausdruck'},
    '*':{d:'Skalarprodukt infix-Variante (oder Produkt von 2 Ausdrücken oder 2 Matrizen).',p:'Vect,Vect||Mtrx,Mtrx,||Xpr,Xpr'},
    '*=':{d:'Infix-Operator',p:'Var,Real'},
    '+':{d:'Verkettung zweier Strings oder Addition per Element von zwei Ausdrücke, Listen oder Matrizen (infix-Operator)',p:'Str||Lst||Expr||Pnt, Str||Lst||Expr||Pnt'},
    '+&':{d:'Verkettung zweier Strings oder Addition per Element von zwei Ausdrücke, Listen oder Matrizen (infix-Operator, TI Kompatibilität)',p:'Str||Lst, Str||Lst, Expr||Expr'},
    '+=':{d:'Infix-Operator',p:'Var,(Real or Str)'},
    '+infinity':{d:'Plus unendlich',a:['inf']},
    '-':{d:'',p:'Lst||Expr||Pnt,Lst||Expr||Pnt'},
    '-<':{d:'Infix-Operator (äquivalent zum Präfix-Operator color), der die Attribute eines geometrischen Objekts definiert.',p:'GeoObj,Attribut'},
    '-=':{d:'Infix operator : a-=b äquivalent zu a:=a-b',p:'Var,Real'},
    '->':{d:'Inifix-Operator der eine benutzerspezifische Funktion definiert:  x->f(x).',p:'VectVar(x),Expr(f(x))'},
    '-infinity':{d:'Minus unendlich'},
    '.*':{d:'Vollführt eine Multiplikation per Element von 2 Listen oder 2 Matrizen (infix-Operator, TI kompatibel)',p:'Lst||Mtrx,Lst||Mtrx'},
    '.+':{d:'Vollführt eine Summe Element zu Element von 2 Listen oder 2 Matrizen. Alternativ wird $a$ zu jedem Element einer Liste oder Matrix addiert. (infix-Operator, TI kompatibel)',p:'Lst||Mtrx, Real(a)||Lst||Mtrx'},
    '.-':{d:'Vollführt eine Subtraktion per Element von 2 List oder 2 Matrizen. Alternativ wird $a$ von jedem Element einer Liste oder Matrix subtrahiert. (infix-Operator, TI kompatibel)',p:'Lst||Mtrx,Real(a)||Lst||Mtrx'},
    './':{d:'Vollführt eine Division per Element von 2 Listen oder 2 Matrizen (infix-Operator, TI kompatibel)',p:'Lst||Mtrx,Lst||Mtrx'},
    '.^':{d:'Berechnet die Potenz eines jeden Elements einer Matrix (infix-Operator, TI kompatibel)',p:'Mtrx,Intg(n)'},
    '/%':{d:''},
    '/=':{d:'Infix-Operator: a/=b äquivalent zu a:=a/b.',p:'Var,Real'},
    ':=':{d:'Infix-Operator, der das zweite Argument in der Variable des ersten Arguments speichert.',p:'Var,(Real or Str)'},
    '<':{d:'Boolescher Infix-Operator, der die Ungleichheit testet.',p:'Expr,Expr'},
    '<=':{d:'Boolescher Infix-Operator, der die Ungleichheit testet.',p:'Expr,Expr'},
    '=':{d:'Infix-Symbol, dass 2 Teile einer Gleichung verbindet.',p:'Expr,Expr'},
    '=<':{d:'Infix-Operator der durch Referenz das zweite Argument in einer Variable (die eine Liste enthält), die im ersten Argument gegebenen wird, speichert.',p:'Var,(Real or Str)'},
    '==':{d:'Boolescher Infix-Operator, der die Gleichheit testet.',p:'Expr,Expr'},
    '=>':{d:'Infix-Operator der das erste Argument in der Variable des zweiten Arguments gspeichert. Oder die Infix-Version von convert.',p:'(Real or Str),Var'},
    '>':{d:'Boolescher Infix-Operator, der die Ungleichheit testet.',p:'Expr,Expr'},
    '>=':{d:'Boolescher Infix-Operator, der die Ungleichheit testet.',p:'Expr,Expr'},
    '?':{d:'? ist die Infix-Version von when: (Cond) ? Expr1:Expr2. Wenn Bedingung Cond=1 (sogar symbolisch) gebe Expr1 zurück sonst gebe Expr2 zurück.',p:'Cond,Expr1,Expr2'},
    '@':{d:'Ist der infix-Operator für die Komposition von Funktionen.',p:'Fnc,Fnc'},
    '@@':{d:'f @@ n is die Funktion fof..of (nmal) (infix-Operator)',p:'Fnc(f),Intg(n)'},
    'Airy_Ai':{d:'Gibt den Wert von Ai zurück. Ai ist die Airy-Funktions-Lösung von w‘‘-xw=0.Ai(x)=Ai(0)f(z)+Ai\'(0)g(z)(f und g sind die Taylorreihen-Entwicklungs-Lösungen von w\'\'-xw=0).',p:'Real'},
    'Airy_Bi':{d:'Gibt den Wert von Bi zurück. Bi ist die Airy-Funktions-Lösung von w‘‘-xw=0. Bi(x)=sqrt(3)(Bi(0)f(z)-Bi\'(0)g(z))(f und g sind die Taylorreihen-Entwicklungs-Lösungen von w\'\'-xw=0).',p:'Real'},
    'Archive':{d:'Schützt die Variablen, die im Argument gegeben wurden in einer Archiv-Datei',p:'SeqVar'},
    'BesselJ':{d:'besselJ(x,p) gibt die Bessel-Funktion erster Gattung Jp(x) zurück.',p:'Int(p),Real(x)'},
    'BesselY':{d:'besselY(x,p) gibt die Bessel-Funktion zweiter Gattung Yp(x) zurück.',p:'Int(p),Real(x)'},
    'Beta':{d:'Beta(a,b)=int(t^(a-1)*(1-t)^(b-1),t=0..1), Beta(a,b,p)=int(t^(a-1)*(1-t)^(b-1),t=0..p), Beta(a,b,p,1)=Beta(a,b,p)/Beta(a,b).(Beta(x,y) returns Gamma(x)*Gamma(y)/Gamma(x+y)).',p:'Expr,Expr,[Expr],[1]'},
    'BlockDiagonal':{d:'Gibt entweder die Diagonalmatrix, mit der Diagonalen l zurück oder die Diagonale von A.',p:'Lst(l)||Mtrx(A)'},
    'COND':{d:'Kondition einer Matrix, benutze COND(.,1) für l1, COND(.,2) für l2 und COND(.,inf) für l\'unendlich (1 ist Standardeinstellung).',p:'Mtrx,[2]||[inf]',a:['cond']},
    'CST':{d:'Name einer Variablen, die es erlaubt in einer Binde ein Menü zu erstellen. Dafür muss man "cust" drücken.',p:'Lst'},
    'Celsius2Fahrenheit':{d:'Wandelt Celsius in Fahrenheit um.',p:'Unit'},
    'Ci':{d:'Cosinusintegral int(cos(t)/t,t=-inf..x)',p:'Expr'},
    'Circle':{d:'Zeichnet den Kreis mit dem Zentrum (xc,yc) und dem Radius r (Ohne Spezifikation = 1 und Option=0 löscht den Kreis).',p:'Real(xc),Real(yc),Real(r),[Intg(option)]'},
    'ClrGraph':{d:'Löscht alle Grafen und die geometrischen Objekte auf dem Grafikbildschirm DispG.',p:'NULL',a:['ClrDraw']},
    'ClrIO':{d:'Lösche den output-Bildschirm',p:'NULL'},
    'Col':{d:'Gibt die Zahl der Spalte der erleuchteten Zelle im Matrix-Editor zurück.',p:'NULL'},
    'CopyVar':{d:'Kopiert den Speicher, ohne Evaluation von var1 in var2.',p:'Var(var1),Var(var2)'},
    'CyclePic':{d:'Erschafft eine automatische Folge von n Bilder (die z.B. in StoPic gespeichert wurden, mit den Namen des1, des2, des3..desn). Diese werden n mal angezeigt mit einer Pause von p Sekunden, zwischen jedem Bild.',p:'Str(),Intg(n),Real(p),Intg(n)'},
    'DOM_COMPLEX':{d:'DOM_COMPLEX oder "complex" repräsentiert den Typ einer komplexen Zahl oder einer komplexen Variable, zurückgegeben vom Typ Befehl. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['complex']},
    'DOM_FLOAT':{d:'DOM_FLOAT oder "float" ist ein integer, der den Typ einer "float" Variable repräsentiert, welcher vom "type" Befehl widergegeben wird. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['float','double']},
    'DOM_FUNC':{d:'DOM_FUNC oder func repräsentiert den Typ einer Funktion, zurückgegeben vom Typ Befehl. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['func']},
    'DOM_IDENT':{d:'DOM_IDENT oder "identifier" ist ein integer, der den Typ einer "identifier" Variable repräsentiert, welcher vom "type" Befehl widergegeben wird. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['identifier']},
    'DOM_INT':{d:'DOM_INT oder integer oder DOM_int ist ein integer, der den Typ einer "integer" Variable repräsentiert, welcher vom "type" Befehl widergegeben wird. DOM_INT wird verwendet, wenn der integer <2^31 ist. Es ist zudem eine Option für den assume Befehl.',p:'Opt',a:['integer','DOM_int']},
    'DOM_LIST':{d:'DOM_LIST oder "vector" repräsentiert den Typ einer Liste oder Folge, zurückgegeben vom type Befehl. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['vector']},
    'DOM_RAT':{d:'DOM_RAT oder rational repräsentiert den Typ einer rationalen Zahl, zurückgegeben vom Typ Befehl. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['rational']},
    'DOM_STRING':{d:'DOM_STRING oder "string" repräsentiert den Typ eines Strings, zurückgegeben vom Typ Befehl. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['string']},
    'DOM_SYMBOLIC':{d:'DOM_SYMBOLIC oder "symbol" ist ein integer, der den Typ einer "symbolic" Variable repräsentiert, welcher vom "type" Befehl widergegeben wird. Es ist zudem eine Option für den "assume" Befehl.',p:'Opt',a:['symbol','expression']},
    'DelFold':{d:'Löscht den gewählten Ordner (Es gibt eine Fehlermeldung, wenn dieser Ordner nicht leer ist).',p:'Var'},
    'Det':{d:'Determinante einer quadratischen Matrix M, ohne Auswertung.',p:'Mtrx'},
    'Dialog':{d:'In einem Programm, macht Einträge: Dialog{Title("title");Text("Schüler"+ string(c));Request("Name=",a);Request("Alter=",b);DropDown("Stufe",["eins","zwei"],n);}',p:'Title;Text;Request;Request;DropDown;EndDlog',a:['EndDlog']},
    'Digits':{d:'Pseudo-Variable, um die Anzahl der signifikanten Stellen zu modifizieren (Digits:=n).',p:':=Intg(n)',a:['DIGITS']},
    'Dirac':{d:'Diracdistribution',p:'Real'},
    'DispG':{d:'Zeigt das DispG-Fenster an (DispG ohne ()).'},
    'DispHome':{d:'Schließt das DispG-Fenster.'},
    'DrawInv':{d:'Zeichnet den Grafen der Spiegelung des Ausdrucks bezüglich y=x.',p:'Expr,[Var]'},
    'DrawSlp':{d:'Zeichnet die Linie mit Steigung m, die durch den Punkt (a,b) geht: y-b=m(x-a).',p:'Real(a),Real(b),Real(m)'},
    'DropDown':{d:'In einem Programm, Instruktion eines Dialogfensters.',p:'Str,LstVal,Var'},
    'Ei':{d:'Exponentialintegral int(exp(t)/t,t=-inf..x)',p:'Expr'},
    'Factor':{d:'Faktorisiert ein Polynom ohne Auswertung.',p:'Expr'},
    'Fahrenheit2Celsius':{d:'Wandelt Fahreinheit zu Celsius um.',p:'Unit'},
    'Fill':{d:'Füllt die Liste oder die Matrix, die in A gespeichert wurde mit Xpr',p:'Expr(Xpr),Var(A)'},
    'Fourier':{d:'',p:'Expr(f),Var(t),Var(omega)'},
    'GF':{d:'Erschafft ein Galois Feld mit Charakteristik p mit p^n Elementen. Das Minimalpolynom ist primitiv außer, wenn es gegeben wird oder wenn 0 als letztes Argument gegeben wird.',p:'Intg(p), Intg(n)|Minpoly,[Variable],[0|undef|Poly]'},
    'Gamma':{d:'Berechnet den Wert von der Eulerschen Gamma-Funktion am Punkt a (Gamma(n+1)=n! wenn n ganzzahlig) wenn a>0, Gamma(a)=int(e^{-t}*t^{a-1},t=0..inf)) und Gamma(a)=Gamma(a+1)/a und Gamma(a,b)=ugamma(a,b).',p:'Real(a),[Real(b)]'},
    'Gcd':{d:'Gibt den größten gemeinsamen Teiler von 2 Polynomen oder 2 ganzer Zahlen ohne Auswertung an.',p:'(Intg or Poly),(Intg or Poly)'},
    'GetFold':{d:'Gibt den Namen des aktuellen Ordners zurück.',p:'Var'},
    'Heaviside':{d:'Funktion gleich 0, wenn x<0 und gleich 1, wenn x>=0.',p:'Real'},
    'Heaviside2sign':{d:'',p:'Expr'},
    'Hilbert':{d:'',p:'Expr(f),Var(x)'},
    'InputStr':{d:'Instruktion in einem Programm, mit der man einen String eingeben kann und in var speichern kann.',p:'[Str],Var(Var)',a:['textinput','lis_phrase']},
    'Int':{d:'Gibt die Stammfunktion oder die Berechnung des Integrals zurück (Grenzen a und b) ohne Evaluation.',p:'Expr,[Var(x)],[Real(a)],[Real(b)]'},
    'Inverse':{d:'Gibt das reziproke oder die Matrixinverse zurück, ohne Evaluation.',p:'Expr||Mtrx'},
    'JordanBlock':{d:'Gibt eine n*n Matrix zurück, die a auf der Diagonalen, 1 darüber und 0 sonst hat.',p:'Expr(a),Intg(n)'},
    'LQ':{d:'Für eine numerische Matrix A, wird eine untere Dreiecksmatrix L, eine orthogonale Matrix Q und eine Permutationsmatrix P wiedergegeben, sodass P*A=L*Q ist.',p:'Mtrx(A)'},
    'LSQ':{d:'Gibt den Vektor (bzw. die Matrix) X zurück, die die euklidische Norm (bzw. die Frobeniusnorm) von A*X-B minimiert. Dies korrespondiert dem linearem Gleichungssystems A*X=B, wenn B ein Vektor (bzw. eine Matrix) ist.',p:'Mtrx(A),(Mtrx || Vect)(B)',a:['lsq']},
    'LU':{d:'Für eine numerische Matrix A, wird in L eine untere Dreiecksmatrix, in U eine obere Dreiecksmatrix und in P eine Permutationsmatrix gespeichert, sodass P*A=L*U.',p:'Mtrx(A),Var(L),Var(U),Var(P)'},
    'LambertW':{d:'',p:'Real(x),[Intg(n)]'},
    'Li':{d:'Logarithmisches Integral Li(x)=Ei(ln(x)) Stammfunktion von 1/ln(x)',p:'Expr'},
    'Line':{d:'Zeichnet das Segment [a+i*b,c+i*d].',p:'Expr(a),Expr(b),Expr(c),Expr(d)'},
    'LineHorz':{d:'Zeichnet die horizontale Linie y=a.',p:'Expr(a)'},
    'LineTan':{d:'Zeichnet die Tangente zu y=f(x) bei x=a. Verwenden Sie keine Klammern und setzen Sie keine Klammern außen herum.',p:'Expr(f(x)),[Var],Expr(a)'},
    'LineVert':{d:'Zeichnet die vertikale Linie x=a.',p:'Expr(a)'},
    'MSE':{d:'',p:'Opt',a:['cross_entropy','log_loss','ReLU','learning_rate','weight_decay','block_size','adaptive','momentum','topology']},
    'NewFold':{d:'Erstellt einen neuen Ordner, indem man sich danach befindet.',p:'Var'},
    'NewPic':{d:'Kreiert ein Bild namens pic1, welches aus den Punkten gemacht ist, die durch die Zeilen von A definiert werden.',p:'Mtrx_nrows_2cols(A),Var(pic1)'},
    'Nullspace':{d:'„Inert Form“ von nullspace für modulare Berechnung (irem/mod)',p:'Mtrx'},
    'Ox_2d_unit_vector':{d:'Ox_2d_unit_vector() zeichnet den Einheitsvektor der x-Achsen des 2-d Grafikbildschirm.',p:'NULL'},
    'Ox_3d_unit_vector':{d:'Ox_2d_unit_vector() zeichnet den Einheitsvektor der x-Achsen des 3-d Grafikbildschirm.',p:'NULL'},
    'Oy_2d_unit_vector':{d:'5 Ox_2d_unit_vector() zeichnet den Einheitsvektor der y-Achsen des 2-d Grafikbildschirm.',p:'NULL'},
    'Oy_3d_unit_vector':{d:'Ox_2d_unit_vector() zeichnet den Einheitsvektor der y-Achsen des 3-d Grafikbildschirm.',p:'NULL'},
    'Oz_3d_unit_vector':{d:'Ox_2d_unit_vector() zeichnet den Einheitsvektor der z-Achsen des 3-d Grafikbildschirm.',p:'NULL'},
    'Pause':{d:'Pause; In einem Programm wird dessen Ausführung gestoppt (Diese wird fortgesetzt, wenn Eingabe gedrückt wird). [Pausen; unterbricht die die Ausführung für n Sekunden]',a:['sleep']},
    'Psi':{d:'Psi(a,n)=n-th Ableitung der Funktion DiGamma (=ln@Gamma) am Punkt A (Psi(a,0)=Psi(a)).',p:'Real(a),Intg(n)'},
    'QR':{d:'Für eine numerische Matrix A, wird in Q eine orthogonale Matrix und in U eine obere Dreiecksmatrix mit A=Q*R gespeichert. [O wird ausgetauscht durch Elemente mit abs(el)<eps]',p:'Mtrx,Var(Q),Var(R),[Real(eps)]'},
    'Quo':{d:'Gibt den euklidischen Quotient von 2 Polynomen ohne Auswertung zurück.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'REDIM':{d:'Schrumpfe oder Vergrößere eine Matrix (oder einen Vektor) mit 0, sodass sie anschließend die Dimension n1,n2 hat.',p:'Mtrx||Vect,Intg(n1),Intg(n2)',a:['redim']},
    'REPLACE':{d:'Ersetze einen Teil der Matrix A mit Matrix B beginnend mit den Indizes n1,n2.',p:'Mtrx(A),Lst(n1,n2),Mtrx(B)',a:['replace']},
    'RandSeed':{d:'Initialisiert zufällige Zahlen.',p:'Intg'},
    'RclPic':{d:'Fügt zu der Grafik im DispG Bildschirm das Bild, welches mit "StoPic" gespeichert wurde, hinzu.',p:'Var(pic1)'},
    'Rem':{d:'Gibt den euklidischen Rest von 2 Polynomen ohne Auswertung zurück.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'Request':{d:'In einem Programm, Instruktion eines Dialogfensters.',p:'Str,Var'},
    'Resultant':{d:'„Inert Form“ von resultant für modulare Berechnung (irem/mod).',p:'Poly,Poly,Var'},
    'Row':{d:'Gibt die Zahl der Zeile der erleuchteten Zelle im Matrix-Editor zurück.',p:'NULL'},
    'RplcPic':{d:'Lösche und ersetze die Grafik im DisG Bildschirm, mit der Grafik in "StoPic".',p:'Var(pic1)'},
    'Rref':{d:'Gibt die Zeilenreduktion auf Echelon-Form (Treppenform) von AX=b (M=A|(-b)) ohne Auswertung zurück.',p:'Mtrx(M)'},
    'SCHUR':{d:'Reduziert eine Matrix auf die Hessenberg-Form. Gibt [P,B] zurück, sodass B=inv(P)*A*P: SCHUR(A)=Hessenberg(A,-1).',p:'Mtrx(A)',a:['schur']},
    'SVD':{d:'Singulärwertzerlegung einer numerischen reellen Matrix A, gibt U orthogonale Matrix, S den Vektor der Singulärwerte von A und eine orthogonale Matrix U zurück, sodass A=U*diag(S)*trn(Q).',p:'Mtrx(A)'},
    'SVL':{d:'Für eine numerische reelle Matrix A wird der Singulärwert-Vektor wiedergegeben. Also sqrt(eigenvals(A*trn(A))).',p:'Mtrx(A)'},
    'SetFold':{d:'Gibt den Namen des aktuellen Ordners zurück und wählt den angewählten Namen als neuen Ordner (main für den Ursprungsordner).',p:'Var'},
    'Si':{d:'Sinusintegral int(sin(t)/t,t=0..x)',p:'Expr'},
    'SortA':{d:'Sortiert die Liste mit aufsteigender Reihenfolge (wie TI). Alternativ die erste Zeile einer Matrix in aufsteigender Reihenfolge, wobei die Spalten beibehalten werden.',p:'LstReal||Seq||Mtrx'},
    'SortD':{d:'Sortiert die Liste mit absteigender Reihenfolge (wie TI). Alternativ die erste Zeile einer Matrix in absteigender Reihenfolge, wobei die Spalten beibehalten werden.',p:'LstReal||Seq||Mtrx'},
    'StoPic':{d:'Da, um mehrere Grafiken in einer Variablen mit dem selben Pfad-Namen zu speichern (radical1,radical2..) und dann die Grafiken in CyclePic zu animieren.',p:'Var'},
    'Text':{d:'In einem Programm, Instruktion eines Dialogfensters.',p:'Str'},
    'Title':{d:'In einem Programm, Instruktion eines Dialogfensters.',p:'Str'},
    'UTPC':{d:'Gibt Wahrscheinlichkeitsdichte der Chiquadrat-Verteilung zurück (n ist die Anzahl der Freiheitsgrade).',p:'Intg(n),Real(x0)'},
    'UTPF':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine F-verteilte Zufallsvariable größer als x0 ist (n und d sind Anzahle von Freiheitsgraden).'},
    'UTPN':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine normalverteile Zufallsvariable größer als x0 ist (my ist das Mittel und v die Varianz).',p:'Real(mu),Real(v),Real(x0)'},
    'UTPT':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Student Zufallsvariable größer als x0 ist (n ist die Anzahl der Freiheitsgrade).',p:'Intg(n),Real(x0)'},
    'Unarchiv':{d:'Hebt den Schutz der Variable im Argument auf.',p:'SeqVar'},
    'VARS':{d:'Liste der Variablen und Ordner im aktuellen Pfad.',p:'NULL'},
    'VAS':{d:'Gibt eine Liste der Intervalle zurück, die reelle Wurzeln von P enthalten. Vincent-Akritas-Strzebonski\'s Methode (VAS) wird verwendet.',p:'Poly(P)'},
    'VAS_positive':{d:'Gibt eine Liste der Intervalle zurück, die positive Wurzeln von P enthalten. Vincent-Akritas-Strzebonski\'s Methode (VAS) wird verwendet.',p:'Poly(P)'},
    'WAIT':{d:'WAIT(n); in einem Programm wird die Ausführung für n Sekunden angehalten.',p:'Var(n)'},
    'Zeta':{d:'Gibt wenn a>1 sum(1/n^a,n,1,+infinity) zurück.',p:'Real(a)'},
    '^':{d:'Berechnet die n-te Potenz einer Zahl (infix-Operator).',p:'Expr(a),Intg(n)'},
    '_(cm/s)':{d:'Centimeter pro Sekunde'},
    '_(ft*lb)':{d:''},
    '_(ft/s)':{d:'Fuß pro Minute'},
    '_(m/s)':{d:'Meter pro Sekunde'},
    '_(m/s^2)':{d:'Meter pro Quadratsekunde'},
    '_(rad/s)':{d:'Rad (Winkel) pro Sekunde'},
    '_(rad/s^2)':{d:'Rad pro Sekunde-Quadrat'},
    '_(tr/min)':{d:'Umdrehungen pro Minute'},
    '_(tr/s)':{d:'Umdrehungen pro Sekunde'},
    '_A':{d:'Ampère'},
    '_Angstrom':{d:'Angstrom'},
    '_Bq':{d:'Becquerel'},
    '_Btu':{d:'Btu British thermal unit (Britische Temperatureinheit)'},
    '_Ci':{d:'Curie'},
    '_F':{d:'Farad'},
    '_F_':{d:'Faraday\'sche Konstante'},
    '_Fdy':{d:'Faraday'},
    '_G_':{d:'Gravitationskonstante'},
    '_Gal':{d:'Gal=0.01_(m/s^2).'},
    '_Gy':{d:'Gray (Energiedosis)'},
    '_H':{d:'Henry'},
    '_Hz':{d:'Hertz'},
    '_J':{d:'Joule'},
    '_K':{d:'Kelvin'},
    '_Kcal':{d:'Kilokalorie.'},
    '_MHz':{d:'Megahertz'},
    '_MW':{d:'Megawatt'},
    '_MeV':{d:'Megaelektronenvolt.'},
    '_N':{d:'Newton'},
    '_NA_':{d:'Avogadro-Konstante'},
    '_Ohm':{d:'Ohm'},
    '_P':{d:'Poise (Maß für Viskosität)'},
    '_PSun_':{d:'Leistung der Sonnenoberfläche'},
    '_Pa':{d:'Pascal'},
    '_R':{d:'Röntgen 1_R='},
    '_REarth_':{d:'Erdradius'},
    '_RSun_':{d:'Sonnenradius'},
    '_R_':{d:'Universale Gas Konstante'},
    '_Rankine':{d:'Grad Rankine'},
    '_Rinfinity_':{d:'Rydberg-Konstante'},
    '_S':{d:'Siemens'},
    '_St':{d:'Stokes'},
    '_StdP_':{d:'Standarddruck'},
    '_StdT_':{d:'Standardtemperatur'},
    '_Sv':{d:'Sievert'},
    '_T':{d:'Tesla'},
    '_V':{d:'Volt'},
    '_Vm_':{d:'Molares Volumen'},
    '_W':{d:'Watt'},
    '_Wb':{d:'Weber'},
    '_Wh':{d:'Watt-Stunde'},
    '_a':{d:'a (100 m^2)'},
    '_a0_':{d:'Bohrradius'},
    '_acre':{d:'Hektar'},
    '_alpha_':{d:'Feinstrukturkonstante'},
    '_arcmin':{d:'Bogenminute'},
    '_arcs':{d:'Bogensekunde'},
    '_atm':{d:'Atmosphären'},
    '_au':{d:'Astronomische Einheit'},
    '_b':{d:'Barn'},
    '_bar':{d:'bar'},
    '_bbl':{d:'Barrel'},
    '_bblep':{d:'Äquivalent zu einem Barrel (Fass) Öl'},
    '_bu':{d:'Bushel (Hohlmaß 1bu=8_galUK)'},
    '_buUS':{d:'US bushel (amerikanischer Buschel, Hohlmaß)'},
    '_c3_':{d:'Wiensche Verschiebungs-Konstante'},
    '_c_':{d:'Vakuum-Lichtgeschwindigkeit'},
    '_cal':{d:'Kalorie'},
    '_cd':{d:'Candela'},
    '_chain':{d:'Chain (1 chain = 66 feet oder 22 yards)'},
    '_cm':{d:'Zentimeter'},
    '_cm^2':{d:'Quadratzentimeter'},
    '_cm^3':{d:'Kubikzentimeter'},
    '_ct':{d:'Carat'},
    '_cu':{d:'US-Amerikanische Einheit cup'},
    '_d':{d:''},
    '_dB':{d:'Dezibel'},
    '_deg':{d:'Grad (Winkel)'},
    '_degreeF':{d:'Grad Fahrenheit'},
    '_dyn':{d:'Dyn'},
    '_eV':{d:'Elektronenvolt'},
    '_epsilon0_':{d:'Permittivität des Vakuums'},
    '_epsilon0q_':{d:'epsilon0/q (Permittivität/Ladung des Elektrons)'},
    '_epsilonox_':{d:'Dielektrizitätskonstante von Silizium-Dioxid'},
    '_epsilonsi_':{d:'Dielektrizitätskonstante'},
    '_erg':{d:'Erg'},
    '_f0_':{d:'Photonen-Frequenz (e/h)'},
    '_fath':{d:'Fathom (nautischer Faden)'},
    '_fbm':{d:'Fathom (nautischer Faden)'},
    '_fc':{d:'Footcandle (1 footcandle entspricht 10.764 lux)'},
    '_fermi':{d:'Fermi'},
    '_flam':{d:'Footlambert (Einheit für die Leuchtdichte)'},
    '_fm':{d:''},
    '_ft':{d:'Fuß (internationaler foot)'},
    '_ftUS':{d:'Survey foot (US-Einheit)'},
    '_ft^2':{d:'Quadrat-Fuß'},
    '_ft^3':{d:'Kubik-Fuß'},
    '_g':{d:'Gramm'},
    '_g_':{d:'Schwerebeschleunigung'},
    '_ga':{d:'Standard freefall (Standard freier Fall)'},
    '_galC':{d:'Kanadische Gallone'},
    '_galUK':{d:'Britische Gallon'},
    '_galUS':{d:'US Gallone'},
    '_gf':{d:'Gramm-Kraft (gravitatinal metric)'},
    '_gmol':{d:'Gramm-mol'},
    '_gon':{d:'Grad'},
    '_grad':{d:'Grad-mol'},
    '_grain':{d:'grain (Masseneinheit 1 grain entspricht 0,0648 Gramm)'},
    '_h':{d:'Stunde'},
    '_h_':{d:'Planks Konstante'},
    '_ha':{d:'Hektar'},
    '_hbar_':{d:'Dirac‘s Konstante'},
    '_hp':{d:'horsepower (Pferdestärke)'},
    '_in':{d:'Inch'},
    '_inH20':{d:'inches of mercury (inches (mehrzahl inch, US Längeneinheit) von Quecksilber), 0 Grad Celsius'},
    '_inHg':{d:''},
    '_in^2':{d:'Quadrat-Inch'},
    '_in^3':{d:'Kubik-Inch'},
    '_j':{d:'Tag'},
    '_kWh':{d:'Kilowatt-Stunde'},
    '_k_':{d:'Boltzmann-Konstante'},
    '_kg':{d:'Kilogram'},
    '_kip':{d:'Kilopound-force (1000 Pfund Gravitationskraft)'},
    '_km':{d:'Kilometer.'},
    '_km^2':{d:'Quadratkilometer'},
    '_knot':{d:'Semeilen pro Stunde (Knoten)'},
    '_kph':{d:'Kilometer pro Stunde'},
    '_kq_':{d:'k/q (Boltzmann/Ladung des Elektrons)'},
    '_l':{d:'Liter'},
    '_lam':{d:'Lambert'},
    '_lambda0_':{d:'Photonen-Wellenlänge (ch/e)'},
    '_lambdac_':{d:'Compton-Wellenlänge'},
    '_lb':{d:'Pfund (1 Pfund = 16 oz)'},
    '_lbf':{d:'pound-force (Gewichtskraft eines Pfundes)'},
    '_lbmol':{d:'Pfund-mol'},
    '_lbt':{d:'troy pound'},
    '_lep':{d:'Äquivalent zu einem Liter Öl'},
    '_liqpt':{d:'US liquid pint (1_galUS=8_liqpt) (US Volumeneinheit)'},
    '_lm':{d:'Lumen'},
    '_lx':{d:'Lux'},
    '_lyr':{d:'Lichtjahr'},
    '_m':{d:''},
    '_mEarth_':{d:'Erdmasse'},
    '_m^2':{d:'Quadratmeter.'},
    '_m^3':{d:'Kubikmeter'},
    '_me_':{d:'Elektronenrestmasse'},
    '_mho':{d:'Mho (andere Bezeichnung für Siemens)'},
    '_miUS':{d:'US statute mile'},
    '_miUS^2':{d:'Quadrat-US-Meile'},
    '_mi^2':{d:'Quadrat-Meile'},
    '_mil':{d:'Mil (angloamerikanischer Längenmaß)'},
    '_mile':{d:'Internationale Meile'},
    '_mille':{d:'Nautische Meile'},
    '_ml':{d:'Milliliter'},
    '_mm':{d:'Millimeter.'},
    '_mmHg':{d:'Millimeter Quecksilber (torr), 0 Grad Celsius'},
    '_mn':{d:'Minute'},
    '_mol':{d:'Mol'},
    '_mp_':{d:'Protonrestmasse'},
    '_mph':{d:'Meilen pro Stunde'},
    '_mpme_':{d:'Spezifische Ladung (Verhältnis Ladung/Masse) des Protonen'},
    '_mu0_':{d:'Permeabilität des Vakuums'},
    '_muB_':{d:'Bohrsches Magneton'},
    '_muN_':{d:'Nukleares Magneton'},
    '_oz':{d:'Unze'},
    '_ozUK':{d:'UK flüssige Unze'},
    '_ozfl':{d:'US flüssige Unze'},
    '_ozt':{d:'Troy ounce (Troy Unze, US Gewichtseinheit)'},
    '_pc':{d:'Parsec'},
    '_pdl':{d:'Poundal (Kraft)'},
    '_ph':{d:'Phot (alte Einheit für Beleuchtungsstärke)'},
    '_phi_':{d:'Quantum magnetischer Fluss'},
    '_pk':{d:'US peck (Maßeinheit des Raumes)'},
    '_psi':{d:'Pfund pro Quadratinch'},
    '_ptUK':{d:'Britisches pint (Volumeneinheit 1_galUK=8_ptUK)'},
    '_qe_':{d:''},
    '_qepsilon0_':{d:'q*epsilon0 (Ladung des Elektrons*Permittivität)'},
    '_qme_':{d:'Spezifische Ladung (Verhältnis Ladung/Masse) des Elektrons'},
    '_qt':{d:'Viertel (eines Gallons)'},
    '_rad':{d:'Radiant (Art Winkel anzugeben)'},
    '_rad_':{d:'1 Rad'},
    '_rd':{d:'Rad 1_rd=0.01_Gy'},
    '_rem':{d:'Rem (Einheit für Strahlendosis)'},
    '_rod':{d:'Rod (Rute) 1_rod=5.029215842_m'},
    '_rpm':{d:'Umdrehungen pro Minute'},
    '_s':{d:'Sekunde'},
    '_sb':{d:'Stilb (alte Einheit für die Leuchtdichte)'},
    '_sd_':{d:'Dauer eines Sternentages'},
    '_sigma_':{d:'Stefan-Boltzmann-Konstante'},
    '_slug':{d:'Slug (US Maßeneinheit)'},
    '_sr':{d:'Steradiant (Einheit für den Raumwinkel)'},
    '_st':{d:'Ster (Volumenmaß, oft für Brennholz verwendet)'},
    '_syr_':{d:'Dauer eines Sternenjahres (Sternzeit)'},
    '_t':{d:'Metrische Tonne'},
    '_tbsp':{d:'Tablespoon (Esslöffel)'},
    '_tec':{d:'Äquivalent zu einer Tonne Kohle'},
    '_tep':{d:'Äquivalent zu einer Tonne Öl'},
    '_tex':{d:'tex=10^-6 _(kg/m).'},
    '_therm':{d:'EEC therm'},
    '_ton':{d:'short ton (kurze Tonne, 1 short ton = 2000 pounds bzw. Pfund)'},
    '_tonUK':{d:'long ton (UK)'},
    '_torr':{d:'Torr (mmHg)'},
    '_tr':{d:'tour=2*pi _rad.'},
    '_tsp':{d:'Teaspoon (Teelöffel)'},
    '_u':{d:'Atomare Maßeneinheit'},
    '_yd':{d:'internationaler yard'},
    '_yd^2':{d:'Quadrat-Yard'},
    '_yd^3':{d:'Kubik-Yard'},
    '_yr':{d:'Jahr'},
    '_µ':{d:''},
    'a2q':{d:'a2q(A,X)=die quadratische Form q assoziiert mit A, X=Vektor aus Variablen.',p:'Mtrx,VectVar'},
    'abcuv':{d:'Gibt [u,v] zurück, sodass au+bv=c für drei Polynome a,b,c.',p:'Poly(a),Poly(b),Poly(c),[Var]'},
    'about':{d:'Gibt die Annahme zur Variable a, die mit assume gemacht wurde, wieder',p:'Var(a)||Image||Audio'},
    'abs':{d:'Gibt den Betrag oder die Norm des Argumentes zurück.',p:'Cplx||LstCplx'},
    'abscissa':{d:'Gibt die Abszisse einer Punkts oder Vektors wieder.',p:'Pnt or Vect'},
    'accumulate_head_tail':{d:'Gibt die Liste zurück, bei der die ersten p und die letzten q Elemente von l durch ihre Summe ersetzt wurden.',p:'Lst(l),Intg(p),Intg(q)'},
    'acos':{d:'Arccosinus',p:'Expr',a:['arccos']},
    'acos2asin':{d:'Ersetze arccos(x) durch pi/2-arcsin(x) im Argument.',p:'Expr'},
    'acos2atan':{d:'Ersetzt arccos(x) durch pi/2-arctan(x/sqrt(1-x^2)) im Argument.',p:'Expr'},
    'acosh':{d:'Arcus Cosinus hyperbolikus',p:'Expr',a:['arccosh','ACOSH']},
    'acot':{d:'Arcus Kotangenz',p:'Expr',a:['ACOT']},
    'acsc':{d:'Arccosecant: acsc(x)=asin(1/x).',p:'Expr',a:['ACSC']},
    'acyclic':{d:'',p:'Opt'},
    'add_arc':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'add_edge':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'add_vertex':{d:'',p:'Graph(G),Vrtx(v)||Lst(V)'},
    'additionally':{d:'Macht eine zusätzliche Annahme über eine Variable.',p:'Expr'},
    'addtable':{d:'',p:'fourier||laplace,f(x),F(s),Var(x),Var(s)'},
    'adjacency_matrix':{d:'',p:'Graph(G)'},
    'adjoint_matrix':{d:'Gibt das charakteristische Polynom von A und die Streichungsmatrizen von A-xI.',p:'Mtrx'},
    'affix':{d:'Komplexe Zahl gleich dem Repräsentant in der komplexen Zahlenebene (Punkt oder Vektor).',p:'Pnt||Vect'},
    'algsubs':{d:'Ersetzt im Ausdruck Xpr, den algebraischen Ausdruck Xpr1 durch den algebraischen Ausdruck Xpr2.',p:'Equal(Xpr1=Xpr2),Expr(Xpr)'},
    'algvar':{d:'Liste der Variablen angegeben in aufsteigender Reihenfolge bezüglich der algebraischen Entwicklung.',p:'Expr'},
    'all_trig_solutions':{d:'',p:':=Intg(0 or 1)'},
    'allpairs_distance':{d:'',p:'Graph(G)'},
    'alog10':{d:'Funktion x->10^x',p:'Expr'},
    'altitude':{d:'altitude(A,B,C) zeichnet die Höhe durch A des Dreiecks ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'and':{d:'boolescher infix-Operator (und).',p:'Expr, Expr',a:['&&','et']},
    'angle':{d:'angle(A,B,C) ist der Wert des Maßes des Winkels (AB,AC).',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'angle_radian':{d:'Pseudo-Variable, um mit Radiant (angle_radian:=1) oder Grad (angle_radian:=0) zu arbeiten.',p:':=Intg(0 or 1)'},
    'angleat':{d:'angleat(A,B,C,z0) zeigt am Punkt(z0) mit einer Legende den Wert des Maßes des Winkel (AB,AC) an.',p:'Pnt(A),Pnt(B),Pnt(C),(Pnt or Cplx(z0))'},
    'angleatraw':{d:'angleat(A,B,C,z0) zeigt am Punkt(z0) den Wert des Maßes des Winkel (AB,AC) an.5 angleat(A,B,C,z0) zeigt am Punkt(z0) mit einer Legende den Wert des Maßes des Winkel (AB,AC) an.',p:'Pnt(A),Pnt(B),Pnt(C),(Pnt or Cplx(z0))'},
    'animate':{d:'Animiert einen Graphen von Xpr, abhängig von x mit der Variable t, indem der Befehl "plot" aufgerufen wird.',p:'Expr(Xpr),x=xmin..xmax,t=tmin..tmax,frames=nframes'},
    'animate3d':{d:'Animiert einen Graphen von Xpr abhängig von [x,y] mit dem Parameter t, indem der Befehl "plotfunc" aufgerufen wird.',p:'Expr(Xpr),[x=xmin..xmax,y=ymin..ymax],t=tmin..tmax,frames=nframes'},
    'animation':{d:'Zeichnet in einer Schleife jedes Objekt einer Folge von geometrischen Objekten.',p:'Mtrx'},
    'ans':{d:'Gibt die n+1 te Antwort des Befehlsverlaufs zurück, wenn n>=0 oder die (-n)te vorherige Antwort, wenn n<0 (ohne Spezifizierung ist n=-1 für die vorherige Antwort)',p:'Intg(n)'},
    'antiprism_graph':{d:'',p:'Intg(n)'},
    'append':{d:'Fügt ein Element an eine Liste an.',p:'(Lst||Set||Str(L),Elem)'},
    'apply':{d:'Wendet die Funtkion f auf die Elemente einer Liste l an (Option matrix für eine Matrix).',p:'Fnc(f),Lst(l)'},
    'approx_mode':{d:'Pseude-Variable, um im approximativen Modus (approx_mode:=1) oder im exakten Modus (approx_mode:=0) zu arbeiten.',p:':=Intg(0 or 1)'},
    'arc':{d:'Zeichnet einen Kreisbogen gegeben durch zwei Vertices and den Winkel am Zentrum [Xcas wird das Zentrum in C und den Radius in r legen]',p:'Pnt, Pnt, Real,[Var(C)],[Var(r)],[Opt(segment)]'},
    'arcLen':{d:'Gibt die Länge eines Bogens oder einer Kurve definiert durch y=Xpr(oder durch x=Xpr1,y=Xpr2) zurück. Die Werte des Parameters sind zwischen a und b.',p:'Expr(Xpr) or Lst([Xpr1,Xpr2]),Var,Real(a),Real(b)',a:['arclen']},
    'archive':{d:'Archiviert den Wert einer Variable oder einer Liste von Variablen, die im Argument gegeben werden. Dies geschieht in einer spezifischen Datei (Lesbar mit unarchive).',p:'Str(namefich),Seq(Var)'},
    'area':{d:'Algebraische Fläche eines Kreises oder eines Sterns (Polygon) (zum Beispiel Dreieck, Quadrat,…) oder die Fläche unter einer Kurve, optional mit Angabe der Methode (trapezoid (=Trapez),left_rectangle (=linksbündige Rechtecke),right_rectangle(=rechtsbündige Rechtecke),middle_point (=nutzt den Mittelpunkt),simpson,rombergt,rombergm).',p:'Polygone || Expr,x=a..b,[n],[Method]'},
    'areaat':{d:'Zeigt am Punkt (z0) mit einer Legende den algebraischen Inhalt eines Kreises oder eines Sterns (Polygon)(zum Beispiel Dreieck, Quadrat,…) an.',p:'Polygone, Pnt||Cplx(z0)'},
    'areaatraw':{d:'5 Zeigt am Punkt (z0) den algebraischen Inhalt eines Kreises oder eines Sterns (Polygons)(zum Beispiel Dreieck, Quadrat,…) an.',p:'Polygone, Pnt||Cplx(z0)'},
    'arg':{d:'Argumentfunktion einer komplexen Zahl.',p:'Expr'},
    'args':{d:'In einem Programm ist args(NULL) die Liste der Funktion und seiner Argumente.',p:'NULL'},
    'array':{d:'Option für convert für Definitionen von dünnbesetze Matrizen.',p:'Opt'},
    'arrivals':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'articulation_points':{d:'',p:'Graph(G)'},
    'as_function_of':{d:'Gibt ein Element, das als Funktion von einem vorher definierten Element definiert ist, zurück.',p:'VarResult,VarArg'},
    'asc':{d:'Gibt die Liste der ASCII Codes eines Strings an.',p:'Str'},
    'asec':{d:'Arcsecant: asec(x)=acos(1/x).',p:'Expr',a:['ASEC']},
    'asin':{d:'Arcsin.',p:'Expr',a:['arcsin','ASIN']},
    'asin2acos':{d:'Ersetzt arcsin(x) durch pi/2-arccos(x) im Argument.',p:'Expr'},
    'asin2atan':{d:'Ersetzt arcsin(x) durch arctan(x/sqrt(1-x^2)) im Argument.',p:'Expr'},
    'asinh':{d:'Arcus-Sinus hyperbolikus',p:'Expr',a:['arcsinh','ASINH']},
    'assert':{d:'',p:'Boolean(b)'},
    'assign':{d:'Speichert das zweite Argument (der Gleichung) in der Variablen, die als erstes Argument (der Gleichung) gegeben wurde. (Maple-Kompatibilität)',p:'(Var,value) or Equal or LstEq.'},
    'assign_edge_weights':{d:'',p:'Graph(G),Seq(m,n)||Intrv(a..b)'},
    'assume':{d:'Macht eine Annahme über eine Variable.',p:'Expr'},
    'at':{d:'at(l,j) (oder at(m,[j,k])) ist das Element einer Liste l (oder Matrix m) für Index=j (oder Index j,k).',p:'Lst(l)||Mtrx(m),Index(j)||Lst([j,k])'},
    'atan':{d:'Arkustangenz',p:'Expr',a:['arctan','ATAN']},
    'atan2':{d:'',p:'Real(y),Real(x)'},
    'atan2acos':{d:'Ersetzt arctan(x) durch pi/2-arccos(x/sqrt(1+x^2)) im Argument.',p:'Expr'},
    'atan2asin':{d:'Ersetzt arctan(x) durch arcsin(x/sqrt(1+x^2)) im Argument.',p:'Expr'},
    'atanh':{d:'Arkus-Tangens hyperbolikus.',p:'Expr',a:['arctanh','ATANH']},
    'atrig2ln':{d:'Schreibt den Ausdruck, der inverse trigonometrische Funktionen beinhaltet, indem logarithmische Funktionen benutzt werden.',p:'Expr'},
    'auto_correlation':{d:'',p:'Lst'},
    'autosimplify':{d:'Das Argument ist ein Befehl den Xcas verwendet um Antworten umzuschreiben (der Anfangswert ist regroup oder 1 und um nicht zu vereinfachen ist es nop oder 0).',p:'Cmds'},
    'avance':{d:'Die Schildkröte macht n Schritte vorwärts (Ohne Spezifikation n=10).',p:'NULL or Real(n)',a:['forward']},
    'avgRC':{d:'Gibt (Xpr(var+h)-Xpr(var))/h zurück (ohne Spezifikation h=0.001).',p:'Expr(Xpr),Var(Var),[Real(h)]'},
    'axes':{d:'Globale Option (kompatibel mit Maple) der Grafik-Befehle, um die Achsen zu setzen oder nicht.',p:'Opt'},
    'axis':{d:'',p:'xmin,xmax,ymin,ymax,[zmin,zmaz]'},
    'back':{d:'Gibt das letzte Element eines Vektors oder, einer Sequenz oder eines Strings zurück.',p:'Vect or Seq or Str'},
    'backquote':{d:'``',p:'Expr'},
    'baisse_crayon':{d:'Nimmt den Stift herunter, sodass sich die Schildkröte mit Spuren bewegt.',p:'NULL',a:['pendown']},
    'bandwidth':{d:'',p:'Opt'},
    'bar_plot':{d:'Zeichnet ein Balkendiagramm einer statistischen Reihe mit einer Variablen.',p:'Mtrx',a:['barplot']},
    'bartlett_hann_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'barycenter':{d:'barycenter([Punkt1,Koeffizient1],…) zeichnet das Baryzentrum von Punkt1 mit Gewicht Koeffizient1.',p:'[Pnt,Real],[Pnt,Real],[Pnt,Real]'},
    'base':{d:'Option für convert: convert(p,base,b)= [a0,a1,..an] oder convert([a0,a1,..an],base,b)=p mit p=a0+a1*b+....an*b^(n-1).',p:'Opt'},
    'basis':{d:'Extrahiert eine Basis aus einer Menge von Vektoren, die einen Raum aufspannen.',p:'Lst(vector1,..,vectorn)'},
    'batons':{d:'Zeichnet für k=0..nrows die Segmente (xk,0)-(xk,yk), wobei xk=Element Zeile k, Spalte 0 und yk=Element Zeile k, Spalte j (j=1..ncols).',p:'Mtrx'},
    'begin':{d:'Beginnt bloc.'},
    'bellman_ford':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)||Lst(T)'},
    'bernoulli':{d:'bernoulli(n) ist die n-te Bernoulli-Zahl und bernoulli(n,x) ist das n-te Bernoulli-Polynom und das zweite Argument ist die Variable.',p:'Intg||(Intg,Var)'},
    'bernoulli_mod':{d:'',p:'Intg,Intg'},
    'besselJ':{d:'besselJ(x,p) gibt die Bessel-Funktion erster Gattung Jp(x) zurück.',p:'Real(x),Int(p)'},
    'besselY':{d:'besselY(x,p) gibt die Bessel-Funktion zweiter Gattung Yp(x) zurück.',p:'Real(x),Int(p)'},
    'betad':{d:'Gibt die Wahrscheinlichkeitsdichte der Beta-Verteilung zurück (=Gamma(a+b)*x^(a-1)*(1-x)^(b-1)/(Gamma(a)*Gamma(b))).',p:'Real(a>0),Real(b>0),Real(0<=x<=1)'},
    'betad_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine betaverteilte Zufallsvariable (mit a und b als Parameter) kleiner als x0 (bzw. zwischen x0 und y0) ist.',p:'Real(a>0),Real(b>0),Real(0<=x0<=1),[Real(0<=y0<=1)]'},
    'betad_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine betaverteilte Zufallsvariable kleiner als h ist, p ist (0<=p<=1).',p:'Real(a>0),Real(b>0),Real(0<=p<=1)'},
    'betweenness_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'bezier':{d:'Bezier-Kurve definiert von Kontrollpunkten.',p:'Lst,[plot]'},
    'bezoutian':{d:'',p:'Poly,Poly'},
    'biconnected_components':{d:'',p:'Graph(G)'},
    'binomial':{d:'Gibt comb(n,k)*p^k*(1-p)^(n-k) zurück oder comb(n,k), wenn es kein drittes Argument gibt.',p:'Intg(n),Intg(k),[Real(p in 0..1)]'},
    'binomial_cdf':{d:'Gibt Proba(X<=x) oder Proba(x<=X<=y) zurück, wenn X die B(n,P)-Verteilung einhält.',p:'Intg(n),Real(p),Real(x),[Real(y)]'},
    'binomial_icdf':{d:'Gibt h zurück, sodass Proba(X<=h)=t, wenn X der B(n,p)-Verteilung folgt.',p:'Intg(n),Real(p),Real(t)'},
    'bins':{d:'',p:'Opt'},
    'bipartite':{d:'',p:'Opt'},
    'bipartite_matching':{d:'',p:'Graph(G,[maximize||minimize,[epsilon=Real(eps)]])'},
    'bisection_solver':{d:'Argument für "fsolve", dass die Lösungsmethode zum Lösen einer numerischen Gleichung vorgibt.',p:'Opt',a:['brent_solver','falsepos_solver','newton_solver','secant_solver','steffenson_solver']},
    'bisector':{d:'Zeichnet die Winkelhalbierende des Winkels (AB,AC) gegeben durch 3 Punkte A,B,C.',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Pnt(C) or Cplx)'},
    'bit_depth':{d:'',p:'Audio(clip)||Image(img)'},
    'bitand':{d:'Logisches und Bit.',p:'Intg,Intg'},
    'bitor':{d:'Inklusive dem "logischen Oder"-Bit.',p:'Intg,Intg'},
    'bitxor':{d:'Exklusive dem "logischen Oder"-Bit.',p:'Intg,Intg'},
    'blackman_harris_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'blackman_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'bloc':{d:'Reserviertes Wort.'},
    'blockmatrix':{d:'Gibt die Matrix zurück, die man erhält, wenn man eine Liste in n Listen der Länge m zerteilt.',p:'Intg(n),Intg(m),Lst'},
    'bohman_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'border':{d:'Gibt die Matrix zurück, die man erhält, wenn man b von rechts an A anfügt. Wenn nrows(A)=size(b), border(A,b)=tran(append(tran(A),b)).',p:'Mtrx(A),Lst(b)'},
    'box_constraints':{d:'',p:'Vect(x),Mtrx(bounds)'},
    'boxcar':{d:'',p:'Real(a),Real(b),Expr(x)'},
    'boxwhisker':{d:'Boxplot für eine statistischen Reihe.',p:'Lst,[Lst],[x=a..b||y=a..b]',a:['moustache']},
    'break':{d:'Unterbricht eine Schleife: while (Bedingung) {Instruktion1; if (Bedingung) {Instruktion2;break;}}.'},
    'breakpoint':{d:'Fügt einen breakpoint hinzu (einen Punkt zum Stoppen).',p:'Intg'},
    'bspline':{d:'',p:'Lst(c),[x[=Lst(t)||a..b],Intg(p)]'},
    'bvpsolve':{d:'',p:'Expr(f(x,y,y\')),Lst(x=a..b,y),Lst(y(a),y(b),[y\'(1)]),[options]'},
    'c1oc2':{d:'Gibt die Permutation zurück, die aus dem Produkt der zwei Zykel gebildet wurde.',p:'Cycle,Cycle'},
    'c1op2':{d:'Gibt die Permutation zurück, die aus dem Produkt von Permutation und Zykel gebildet wurde.',p:'Cycle,Permut'},
    'cFactor':{d:'Faktorisierung des Ausdrucks in ℂ‚ (Auf Gaußsche Zahlen, wenn dort mehr als zwei Variablen sind.)',p:'Expr',a:['cfactor','factoriser_sur_C']},
    'cZeros':{d:'Gibt die Liste der komplexen Lösungen von Xpr=0 an oder die Matrix, bei der die Zeile die Lösung des Systems: Xpr1=0, Xpr2=0,.. ist.',p:'Expr(Xpr)||LstExpr, [Var||LstVar]'},
    'cache_tortue':{d:'Versteckt die Schildkröte.',p:'NULL'},
    'camembert':{d:'Zeichnet ein Tortendiagramm einer statistischen Reihe mit einer Variablen.',p:'Mtrx',a:['pie']},
    'canonical_form':{d:'kanonische Form eines Polynoms zweiten Grades.',p:'Trinom(a*x^2+b*x+c),[Var]'},
    'canonical_labeling':{d:'',p:'Graph(G)'},
    'cap':{d:'Gibt die Orientierung der Schildkröte wieder in Grad oder dreht die Schildkröte abhängig vom Argument.',p:'NULL or Real',a:['heading']},
    'cartesian_product':{d:'',p:'Seq(G1,G2,[G3])'},
    'cas_setup':{d:'Dieser Befehl erlaubt den cas zu initialisieren: Approx,Cplx_var,Cplx,Angle,Format,Epsilon,Digit',p:'Int,Int,Int,Int,Int,Real,Int'},
    'case':{d:'Test (multiple choice (=Wahl aus mehreren Möglichkeiten)): switch(Variable){Fall 1: {bloc1;} Standard: {bloc2;}};'},
    'cat':{d:'Evaluiert die Argumente und verkettet sie anschließend in einen String.',p:'SeqObj'},
    'catch':{d:'Schutz vor einem Error (=Fehler):try {Instruktion} catch (Variable) {Instruktion für den Fall eines Fehlers}(in einem Programm).',p:'Var'},
    'cauchy':{d:'Gibt die Wahrscheinlichkeitsdichte am Punkt x der Cauchyverteilung mit den Parametern x0 und a zurück (Standardeinstellung x0=0 und a=1).',p:'Real(x0),Real(a),Real(x)',a:['cauchyd']},
    'cauchy_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Cauchy verteilte Zufallsvariable kleiner als x ist.',p:'Real(x0),Real(a),Real(x),[Real(y)]',a:['cauchyd_cdf']},
    'cauchy_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine Cauchy verteilte Zufallsvariable kleiner h ist, p ist.',p:'Real(x0),Real(a),Real(p)',a:['cauchyd_icdf']},
    'cd':{d:'Wechselt Richtung',p:'Str'},
    'cdf':{d:'Kumulierte Verteilungsfunktion eines Wahrscheinlichkeitsgesetzes.',p:'Func,FuncParams'},
    'ceil':{d:'Gibt die kleinste ganze Zahl >= das Argument zurück.',p:'Real or Cplx',a:['ceiling']},
    'center':{d:'Zeigt den Mittelpunk eines Kreises.',p:'Crcle'},
    'center2interval':{d:'Gibt die Liste von Intervallen zurück, die mit a0 beginnen und die Liste l als Zentrum haben.',p:'LstVal(l),[Real(a0)]'},
    'centered_cube':{d:'Zeichnet den Würfel mit Zentrum A, Vertex b sodass die Ebene ABC eine Symmetrieachse enthält.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'centered_tetrahedron':{d:'Zeichnet den regulären Tetraeder mit Zentrum A, Vertex B und einem Vertex in der Ebene (A,B,C).',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'cfsolve':{d:'Numerische Lösung in den komplexen Zahlen einer Gleichung oder eines Gleichungssystems.',p:'Expr,Var,[Guess or Interval],[Method]'},
    'changebase':{d:'Gibt die Matrix B=inv(P)*A*P zurück.',p:'Mtrx(A),Mtrx(P)'},
    'channel_data':{d:'',p:'Audio(clip),[Intg(chn) or matrix],[range=a..b]||Image(img),Intg(chn),Intg(x),Intg(y),Intg(width),Intg(height)'},
    'channels':{d:'',p:'Audio(clip)||Image(img)'},
    'char':{d:'Gibt den String zurück, der den Zeichen-Code des Arguments hat.',p:'Intg or Lst(Intg)',a:['chr']},
    'chinrem':{d:'Chinesischer Rest eines Polynoms, dass als Liste oder in symbolischer Form übergeben werden kann.',p:'[Lst||Expr,Lst||Expr],[Lst||Expr,Lst||Expr]'},
    'chisquare':{d:'Gibt die Wahrscheinlichkeitsdichte der Chi^2-Verteilung bei x0 zurück (n ist die Zahl der Freiheitsgrade).',p:'Intg(n),Real(x0)',a:['chisquared']},
    'chisquare_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Chi^2 verteilte Zufallsvariable kleiner als x0 ist (n ist die Zahl der Freiheitsgrade).',p:'Intg(n),Real(x0)',a:['chisquared_cdf']},
    'chisquare_icdf':{d:'Gibt h so zurück, dass die Wahrscheinlichkeit, dass eine Chi^2 verteilte Zufallsvariable kleiner als h ist, p ist. (n ist die Anzahl der Freiheitsgrade und 0<=p<=1).',p:'Intg(n),Real(p)',a:['chisquared_icdf']},
    'chisquaret':{d:'Chi^2 Test: Testet inwiefern 2 (oder n) Datenmengen oder 1 Datenmenge mit einer Verteilungsfunktion übereinstimmen.',p:'Data,[Func],[FuncParams]'},
    'choice':{d:'',p:'Lst(L)'},
    'cholesky':{d:'Für eine numerische symmetrische Matrix A, wird die Matrix L zurückgegeben, sodass A=L*tran(L).',p:'Mtrx'},
    'choosebox':{d:'In einem Programm, macht einen Eintrag mit der Anzeige einer Liste, aus der gewählt werden kann.',p:'Str(titel),LstVal,Var',a:['PopUp']},
    'chrem':{d:'Chinesischer Rest einer ganzen Zahl oder eines Polynoms.',p:'LstIntg(a,b,c....),LstIntg(p,q,r,....)'},
    'chromatic_index':{d:'',p:'Graph(G)'},
    'chromatic_number':{d:'',p:'Graph(G)'},
    'chromatic_polynomial':{d:'',p:'Graph(G),[Var(t)]'},
    'circle':{d:'Definiert für 2-D einen Kreis mit Durchmesser (arg2=Punkt) oder durch Zentrum und Radius (arg2=Komplex, abs(arg2)=Radius) [oder den Bogen AB, A Winkel a, B Winkel b (arg1+arg2=Winkel 0)] oder durch seine Gleichung. In 3-D mit Durchmesser und einem dritten Punkt.',p:'(Pnt(M) or Cplx(M),(Pnt(N) or Cplx(zN)),[Real(a)],[Real(b)],[Var(A)],[Var(B)]'},
    'circumcenter':{d:'',p:'(Pnt or Cplx),(Pnt or Cplx),((Pnt or Cplx)'},
    'circumcircle':{d:'circumcircle(A,B,C)=Umkreis des Dreiecks ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),((Pnt or Cplx)'},
    'classes':{d:'Gibt die Matrix [[Klasse, Nummer],..,] zurück, die mit class_min und class_size erhalten wurde. Siehe auch Initialisierung von geo oder Argumente 2 und 3. Alternativ kann die Matrix mit der Liste des Zentrums der Klassen erhalten werden.',p:'Lst(l),[ClassMin],[ClassSize||Lst(Center)]'},
    'clear':{d:'',p:'NULL'},
    'click':{d:'Interaktive Eingabe einer komplexen Zahl mit einem Klick auf einem geometrischen Bildschirm.',p:'NULL'},
    'clique_cover':{d:'',p:'Graph(G),[Intg(k)]'},
    'clique_cover_number':{d:'',p:'Graph(G)'},
    'clique_number':{d:'',p:'Graph(G)'},
    'closeness_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'cluster':{d:'',p:'Lst(data),[opts]'},
    'clustering_coefficient':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'coeff':{d:'Gibt die Liste der Koeffizienten eines Polynoms bezüglich des zweiten Arguments zurück oder die Liste der Koeffizienten des Grades, der im dritten Argument gegeben wurde.',p:'Expr(P),[Var]',a:['coeffs']},
    'col':{d:'Gibt die Spalte n oder die Folge der Reihen n1..n2 der Matrix A zurück, oder mit den optionalen Argumenten: count,count_eq,count_inf,count_sup.',p:'Mtrx(A),Intg(n)||Interval(n1..n2)'},
    'colNorm':{d:'Gibt das Maximum der l1_Norm der Spalten einer Matrix zurück:rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).',p:'Vect or Mtrx',a:['colnorm']},
    'colSwap':{d:'Gibt die Matrix zurück, die man erhält, wenn man die n1-ste und die n2-te Spalte vertauscht.',p:'Mtrx(A),Intg(n1),Intg(n2)',a:['swapcol','colswap','SWAPCOL']},
    'coldim':{d:'Anzahl der Spalten einer Matrix.',p:'Mtrx',a:['ncols','colDim']},
    'collect':{d:'Ganzzahliges Faktorisieren eines Polynoms (oder eine Liste aus Polynomen).',p:'Poly or LstPoly'},
    'colormap':{d:'',p:'Str(palette)||Lst(palettes),[Intg(n)||Real(t)||Str(colorname)||display]'},
    'colspace':{d:'Gibt eine Matrix zurück, deren Spalten einen Basis für den Vektorraum, generiert von den Spalten der Matrix A, sind[d ist die Dimension dieses Raumes].',p:'Mtrx(A), [Var(d)]'},
    'comDenom':{d:'Gibt den Ausdruck zurück, nachdem sie auf den selben Nenner gebracht wurde. Nenner und Zähler werden entwickelt [bezüglich Potenzen der Variable var].',p:'Expr,[Var(Var)]'},
    'comb':{d:'comb(n,r)= Zahl der Kombinationen von r Objekten, die aus n genommen wurden: n!/(r!(n-r)!) (Wenn n<0 comb(n,r)=n(n-1)..(n-r+1)/r!).',p:'Intg(n),Intg(r)',a:['nCr']},
    'combine':{d:'Kombiniert die Terme in einem Ausdruck nach einer [Klasse von] Funktion f [übergeben im zweiten Argument].',p:'Expr(Xpr),Fnc(f).'},
    'comment':{d:'Kommentar in einem Programm.',p:'Expr'},
    'common_perpendicular':{d:'Zeichnet das gemeinsame Lot auf die Linien D1 und D2.',p:'Line(D1),Line(D2)'},
    'companion':{d:'Begleitmatrix eines Polynoms (an=1).',p:'Poly,Var'},
    'compare':{d:'Gibt 1 zurück, wenn type(arg1)<type(arg2) oder wenn type(arg1)=type(arg2)',p:'Obj(arg1),Obj(arg2)'},
    'complete_binary_tree':{d:'',p:'Intg(n)'},
    'complete_graph':{d:'',p:'Intg(n)||Lst(V)||Seq(n1,n2,...,nk)'},
    'complete_kary_tree':{d:'',p:'Intg(k),Intg(n)'},
    'complex_mode':{d:'Pseudo-Variabel, um im komplexen (complex_mode:=1) oder im reellen (complex_mode:=0) zu arbeiten.',p:':=Intg(0 or 1)'},
    'complex_variables':{d:'Pseudo-Variabel, um mit komplexen Variablen (complex_variables:=1) oder mit reellen Variablen (complex_variables:=2) zu arbeiten.',p:':=Intg(0 or 1)'},
    'complexroot':{d:'Gibt eine Liste der komplexen Intervalle zurück, die eine Größe <=1 haben und Wurzeln von P enthalten (z.B. i[1.1,1.2]+i[2,2.4]*i für [1.1,1.2]x[2,2.4] mit optionalen a=1+2*i,b=2+3*i), mit Multiplizitäten.',p:'Poly(P),Real(l),[Cplx(a)],[Cplx(b)]'},
    'concat':{d:'Verknüpft zwei Listen oder zwei Strings oder zwei Folgen oder zwei Matrizen (die 2 Matrizen müssen dieselbe Anzahl an Zeilen haben und werden Linie für Linie verknüpft).',p:'Lst,Lst||Seq,Seq||Str,Str||Mtrx,Mtrx',a:['augment','extend']},
    'condensation':{d:'',p:'Graph(G)'},
    'cone':{d:'Zeichnet einen Kegel mit Vertex a, Richtung v und dem Öffnungswinkel t[und mit Höhe h und -h]',p:'Pnt(A),Vect(v),Real(t),[Real(h)]'},
    'confrac':{d:'Option des convert oder convertir Befehls (Beispiel id L:=dfc(sqrt(2),1e-10)).',p:'Opt'},
    'conic':{d:'Definiert einen Kegelschnitt durch seine Gleichung mit x,y als Standardvariablen und zeichnet ihn.',p:'Expr,[LstVar]'},
    'conj':{d:'Gibt die Konjugierte einer komplexen Zahl zurück.',p:'Cplx'},
    'conjugate_equation':{d:'',p:'Expr(y0),Lst(P),Lst(V),Var(x),Real(a)'},
    'conjugate_gradient':{d:'Konjugierter Gradient Algorithmus um A*x=y näherungsweise zu lösen (Präzision eps), wobei A eine symmetrische positiv definite Matrix und so ein optionaler (geratener) Anfangspunkt ist.',p:'Mtrx(A),Vect(y),[Vect(x0),Real(eps)]'},
    'connected':{d:'',p:'Opt'},
    'connected_components':{d:'',p:'Graph(G)'},
    'cont':{d:'Führt die Ausführung eines gestoppten Programms fort.',p:'NULL'},
    'contains':{d:'Tester, ob eine Menge einen Ausdruck enthält (gibt den Index+1 oder 0 zurück.)',p:'(Lst(l) or Set(l)),Elem(e)'},
    'content':{d:'Gibt den größten gemeinsamen Teiler der Koeffizienten des, im Argument übergebenen, Polynoms p zurück.',p:'Poly(P),[Var]'},
    'continue':{d:'In einem Programm. Führt nicht das Ende der Iteration aus, sondern die nächste:while (Bedingung) {i1; if(Bedingung) continue; i2;}.'},
    'contract_edge':{d:'',p:'Graph(G),Edge(e)'},
    'contract_subgraph':{d:'',p:'Graph(G),Lst(S),[lb]'},
    'convert':{d:'Gibt den Wert von cmd(Xpr) zurück. cmd ist der Name eines Befehls spezifiziert durch das zweite Argument (zum Beispiel Option sin=commande trigsin).',p:'Expr(Xpr),Cmd(cmd)',a:['convertir']},
    'convex':{d:'',p:'Expr(f),Lst(x,y,..),[simplify]'},
    'convexhull':{d:'',p:'Lst'},
    'convolution':{d:'',p:'Lst(u),Lst(v)'},
    'coordinates':{d:'Gibt die eine List (bzw. eine Matrix) der Abszissen und Ordinaten eines Punktes oder eines Vektors zurück (respektive von Punkten oder Vektoren).',p:'Pnt or Cplx or Vect'},
    'copy':{d:'A:=copy(B) kopiert die Liste oder Matrix B in A.',p:'Mtrx,Var'},
    'correlation':{d:'Gibt Korrelation der Elemente im Argument zurück.',p:'Lst||Mtrx,[Lst]'},
    'cos':{d:'Cosinus oder Option des convert bzw. convertir Befehls (identisch trigcos).',p:'Expr or Opt',a:['COS']},
    'cos2sintan':{d:'Ersetzt cos(x) durch sin(x)/tan(x) im Argument.',p:'Expr'},
    'cosh':{d:'Cosinus Hyperbolikus.',p:'Expr',a:['COSH']},
    'cosine_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'cot':{d:'Kotangens',p:'Expr',a:['COT']},
    'cote':{d:'Dritte Koordinate (z) eines 3D Punktes.',p:'Vect'},
    'count':{d:'Gibt f(l[0])+f(l[1])+...+f(l[size(l)-1]) zurück oder die Zahl, wie oft eine ganze Zahl in einem Vektor aus ganzen Zahlen vorkommt.',p:'Fnc(f)||LstIntg,(Lst||Mtrx)(l),[Opt(row||col)]'},
    'count_eq':{d:'Gibt die Zahl der Elemente von L gleich a an.',p:'Real(a),(Lst||Mtrx)(L),[Opt(row||col)]'},
    'count_inf':{d:'Gibt die Zahl der Elemente von L echt kleiner a an.',p:'Real(a),(Lst||Mtrx)(L),[Opt(row||col)]'},
    'count_sup':{d:'Gibt die Zahl der Elemente von L echt größer a an.',p:'Real(a),(Lst||Mtrx)(L),[Opt(row||col)]'},
    'covariance':{d:'Gibt die Kovarianz der Elemente des Arguments zurück.',p:'Lst||Mtrx,[Lst]'},
    'covariance_correlation':{d:'Gibt die Liste der Kovarianz und Korrelation der Elemente im Argument zurück.',p:'Lst||Mtrx,[Lst]'},
    'cpartfrac':{d:'Führt Partialbruchzerlegung eines Bruches in C durch.',p:'RatFrac'},
    'crationalroot':{d:'Gibt die Liste der komplex rationalen Wurzeln von P zurück, ohne die Multiplizität mitanzugeben.',p:'Poly(P)'},
    'crayon':{d:'Ändert die Farbe des Stiftes (ohne Parameter ist der Stift rot).',p:'Color',a:['pencolor']},
    'createwav':{d:'',p:'Lst(data),[opts]'},
    'cross':{d:'Dachprodukt',p:'Vect(v1),Vect(v2)',a:['crossproduct','crossP']},
    'cross_correlation':{d:'',p:'cross_correlation(Lst(u),Lst(v))'},
    'cross_ratio':{d:'Gibt die komplexe Zahl gleich ((c-a)/(c-b))/((d-a)/(d-b)) zurück.',p:'Pnt or Cplx(a),Pnt or Cplx(b),Pnt or Cplx(c),Pnt or Cplx(d)'},
    'csc':{d:'Cosecant: csc(x)=1/sin(x).',p:'Expr',a:['CSC']},
    'csolve':{d:'Gibt die Liste der komplexen Lösungen einer Gleichung, alternativ einer Matrix zurück, wobei die Zeilen die komplexen Lösungen eines Systems polynomialer Gleichungen sind.',p:'LstEq,LstVar',a:['cSolve','resoudre_dans_C']},
    'csv2gen':{d:'',p:'Strng(filename),Strng(sep),Strng(nl),Strng(decsep),Strng(eof),[string]'},
    'cube':{d:'Zeichnet den Würfel mit den Vertices A,B und einer Seite in der Ebene(A,B,C).',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'cumSum':{d:'Gibt die Liste (oder die Folge oder den String) lr zurück, bei dem die Elemente die kumulierte Summe der Liste l: lr[k]=sum(l[j],j=0..k) ist (oder lr=sum(l[j],j=0..k)$(k=0..size(l)-1)).',p:'Lst(l)||Seq||Str',a:['cumsum']},
    'cumulated_frequencies':{d:'Zeichnet das Diagramm der kumulierten Häufigkeiten (Zeilen = [Wert, Häufigkeit])',p:'Lst || Mtrx'},
    'curl':{d:'Rotation (Differentialoperator) ([A,B,C],[x,y,z])=[dC/dy-dB/dz,dA/dz-dC/dx,dB/dx-dA/dy].',p:'Lst(A,B,C),Lst(x,y,z)'},
    'current_sheet':{d:'Inhalt des Matrix-Editors oder der Tabelle.',p:'[Intg||Inter],[Intg||Letter],[Letter]'},
    'curvature':{d:'Krümmung der Kurve C am Punkt M.',p:'Curve,Point'},
    'curve':{d:'Reserviertes Wort.',p:'Expr'},
    'cycle2perm':{d:'Wandelt den Zykel c in eine Permutation um.',p:'Cycle'},
    'cycle_basis':{d:'',p:'Graph(G)'},
    'cycle_graph':{d:'',p:'Intg(n)||Lst(V)'},
    'cycleinv':{d:'Gibt den inversen Zykel vom Zykel zurück.',p:'Cycle(c)'},
    'cycles2permu':{d:'Wandelt ein Produkt aus Zykeln in eine Permutation um.',p:'Lst(Cycle)'},
    'cyclotomic':{d:'N-tes Kreisteilungspolynome.',p:'Expr'},
    'cylinder':{d:'Zeichnet einen Zylinder mit der Achse (A,v), mit Radius r [und mit Höhe h]',p:'Pnt(A),Vect(v),Real(r),[Real(h)]'},
    'dash_line':{d:'Option des Befehls display für eine Linie.',p:'Opt',a:['ligne_tiret','solid_line','ligne_trait_plein','dashdot_line','ligne_tiret_point','dashdotdot_line','ligne_tiret_pointpoint','cap_flat_line','ligne_chapeau_plat','cap_square_line','ligne_chapeau_carre','cap_round_line','ligne_chapeau_rond']},
    'dayofweek':{d:'dayofweek(d,m,y) gibt den Tag des gegeben Datums (Tag,Monat,Jahr) zurück: 0 für Sonntag, 1 für Montag..6 für Samstag.',p:'Int,Int,Int'},
    'de':{d:'Benutzt in For-Schleife (for...from ...to... [step...] do...od;) Übersetzt:(Für...von ...bis...[Schritt...]mache...Endefür;).',a:['from']},
    'debug':{d:'Startet die Debugging-Session.',p:'Expr'},
    'debut_enregistrement':{d:'Markiert den Anfang der Aufzeichnung der Befehle, deren Zeichnung den Namen hat, der im Argument gegeben wurde.',p:'Var(nom_du_dessin)'},
    'default':{d:'Standard-Fall der Instruktion der switch Funktion.',a:['otherwise']},
    'degree':{d:'Grad des Polynoms P bezüglich des zweiten Arguments.',p:'Poly(P),Var(Var)'},
    'degree_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'degree_sequence':{d:'',p:'Graph(G)'},
    'degrees':{d:'',p:'Real(rad)'},
    'delcols':{d:'Gibt die Matrix zurück, bei der die Spalten n1..n2 (oder n1) der Matrix A gelöscht wurden.',p:'Mtrx(A),Interval(n1..n2)||n1'},
    'delete_arc':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'delete_edge':{d:'',p:'Graph(G),Edge(e)||Trail(T)||Lst(E)'},
    'delete_vertex':{d:'',p:'Graph(G),Vrtx(v)||Lst(V)'},
    'delrows':{d:'Gibt die Matrix zurück, bei der die Zeilen n1..n2 (oder n1) der Matrix A gelöscht wurden.',p:'Mtrx(A),Interval(n1..n2)||n1'},
    'deltalist':{d:'',p:'Lst'},
    'denom':{d:'Gibt den Nenner des vereinfachten Bruches zurück.',p:'Frac(a/b) or RatFrac'},
    'departures':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'desolve':{d:'Löst eine Differentialgleichung oder ein System linearer Differentialgleichungen mit konstanten Koeffizienten.',p:'Eq,[TimeVar],FncVar',a:['deSolve','dsolve']},
    'dessine_tortue':{d:'Zeichnet das ganze (oder nicht, wenn n=1) Dreieck, dass die Schildkröte darstellt.',p:'[Intg(n)]'},
    'det':{d:'Determinante eine quadratischen Matrix M.',p:'Mtrx'},
    'det_minor':{d:'Gibt die Determinante zurück, die durch Streichungsmatrizen berechnet wird.',p:'Mtrx(A)'},
    'dfc':{d:'Gibt die Entwicklung des Kettenbruchs von x0 der Ordnung n zurück. Alternativ wird bis zur Präzision eps entwickelt.',p:'Real(x0),Int(n)||Real(eps)'},
    'dfc2f':{d:'Transformiert einen Kettenbruch in eine reelle Zahl.',p:'LstFrac_Cont)'},
    'diag':{d:'Mit dem ersten Argument gibt man entweder die Diagonalmatrix, mit der Diagonalen l zurück oder die Diagonale von A. Mit dem zweiten Argument gibt man entweder den großen linken Teil von A oder den großen recht Teil von A zurück oder teilt A in drei Teile: strikt links,Diagonale,strikt rechts. Mit dem dritten Argument gibt man die tridiagonale Matrix zurück, mit den Diagonalen l, d, u.',p:'Lst(l)||(Mtrx(A),[left||right||lu])||Lst(l),Lst(d),Lst(u)'},
    'diff':{d:'Gibt die Ableitung bzgl. des zweiten Arguments zurück.',p:'Expr or Fnc,[SeqVar or LstVar],[n]',a:['derive','deriver']},
    'digraph':{d:'',p:'[Lst(V)],[Set(E)],[Mtrx(A)],[options]'},
    'dijkstra':{d:'',p:'Graph(G),Vrtx(v),[Vrtx(w)||Lst(W)]'},
    'dim':{d:'Gibt die Liste zurück die die Dimension der Matrix angibt, die im Argument übergeben wurde.',p:'Mtrx'},
    'directed':{d:'',p:'Opt'},
    'discard_edge_attribute':{d:'',p:'Graph(G),Edge(e),Seq(tag1=value1,tag2=value2,..)'},
    'discard_graph_attribute':{d:'',p:'Graph(G),Seq(tag1=value1,tag2=value2,..)'},
    'discard_vertex_attribute':{d:'',p:'Graph(G),Vrtx(v),Seq(tag1=value1,tag2=value2,..)'},
    'discriminant':{d:'',p:'Poly,Var'},
    'disjoint_union':{d:'',p:'Seq(G1,G2,...)'},
    'display':{d:'Zeichnet ein geometrische Objekt mit der Farbe schwarz=0, rot=1, grün=2, gelb=3, blau=4 ausgefüllt. Oder füllt die Farbe in das innere einer geschlossenen Kurve, line_width_n (0<n<8) ist für die Breite der Linie und dash_line ist für eine gepunktete Linie.',p:'[GeoObj or legende],Intg',a:['color']},
    'disque':{d:'Zeichnet eine Scheibe (oder einen Kreissektor) mit Radius r (respektive mit dem Winkel (0,a) oder (a,b)), anliegend an die Position der Schildkröte.',p:'Real(r),[Real(a)],[Real(b)]'},
    'disque_centre':{d:'Zeichnet eine Scheibe (oder einen Kreissektor) mit Radius r (respektive mit dem Winkel (0,a) oder (a,b)), mit der Schildkröte im Mittelpunkt.',p:'Real(r),[Real(a)],[Real(b)]'},
    'distance':{d:'Berechnet den Abstand zwischen zwei Punkten oder den zwischen einem Punkt und einer Kurve.',p:'(Pnt or Cplx),(Pnt or Cplx or Curve)'},
    'distance2':{d:'Berechnet das Quadrat des Abstands zwischen zwei Punkten oder den zwischen einem Punkt und einer Kurve.',p:'(Pnt or Cplx),(Pnt or Cplx or Curve)'},
    'distanceat':{d:'distanceat(A,B,z0) zeigt am Punkt(z0) mit einer Legende den Abstand zwischen 2 geometrischen Objekten an.',p:'GeoObj(A),GeoObj(B),(Pnt or Cplx)'},
    'distanceatraw':{d:'distanceat(A,B,z0) zeigt am Punkt(z0) den Abstand zwischen 2 geometrischen Objekten an.',p:'GeoObj(A),GeoObj(B),(Pnt or Cplx(z0))'},
    'div':{d:'Euklidischer Quotient aus zwei Ganzzahlen (infix-Variante)',p:'Intg,Intg'},
    'divergence':{d:'Divergenz (Differentialoperator) ([A,B,C],[x,y,z])=dA/dx+dB/dy+dC/dz.',p:'Lst(A,B,C),Lst(x,y,z)'},
    'divis':{d:'Gibt die Liste der Teiler eines Polynoms zurück.',p:'Poly(P) or LstPoly'},
    'division_point':{d:'Gibt den Punkt M zur Zahl z in der komplexen Ebene zurück mit (z-a)=k*(z-b) (MA=k*MB).',p:'Pnt or Cplx(a),Pnt or Cplx(b),Cplx(k)'},
    'divpc':{d:'Taylor-Polynom vom Grad n für den Quotienten von 2 Polynomen.',p:'Poly,Poly,Intg(n)'},
    'dnewton_solver':{d:'Argument für "fsolve", dass die Lösungsmethode zum Lösen einer numerischer Gleichungen vorgibt.',p:'Opt',a:['hybrid_solver','hybrids_solver','hybridj_solver','hybridsj_solver','newtonj_solver']},
    'do':{d:'Schlüsselwort in einer Schleife.',a:['faire']},
    'dodecahedron':{d:'Zeichnet einen Dodekaeder mit Zentrum A, Vertex B und sodass die Ebene ABC eine Symmetrieachse des Dodekaeders enthält.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'domain':{d:'',p:'Expr'},
    'dot':{d:'Skalarprodukt.',p:'Vect(v1),Vect(v2)',a:['dotP','scalarProduct','scalar_product','dotprod']},
    'dot_paper':{d:'Zeichnet ein Rechteck [xmin..xmax]*[ymin..ymax] mit den Schnittpunkten des Netzwerks konstruiert durch die Linien y=n*uy und in Richtung der Achse OxY mit dem Winkel t!=0 Linien konstruiert durch x=n*ux',p:'Real(ux),Real(uy),Real(t)'},
    'draw_arc':{d:'',p:'Intg(x),Intg(y),Intg(rx),Intg(ry),Real(theta1),Real(theta2),Intg(col)'},
    'draw_circle':{d:'',p:'Intg(x),Intg(y),Intg(r),Intg(col)'},
    'draw_graph':{d:'',p:'Graph(G),[opts]'},
    'draw_line':{d:'',p:'Intg(x1),Intg(y1),Intg(x2),Intg(y2),Intg(col)'},
    'draw_polygon':{d:'',p:'Lst(l),Intg(col)'},
    'draw_rectangle':{d:'',p:'Intg(x),Intg(y),Intg(w),Intg(h),Intg(col)'},
    'droite_tangente':{d:'Zeichnet die Tangente zu y=f(x) bei x=a.',p:'Expr(f(x)),[Var],Expr(a)'},
    'duration':{d:'',p:'Audio(clip)'},
    'dwt':{d:'',p:'(Lst||Mtrx)(data),[opts]'},
    'e':{d:'exp(1)'},
    'ecef2geodetic':{d:'',p:'Real(x),Real(y),Real(z)'},
    'ecm_factor':{d:'',p:'Intg(a),[Intg(B1)]'},
    'ecris':{d:'Schreibe einen String s mit der Schriftart n (ohne Spezifikation n=14) am Punkt [x,y] (ohne Spezifikation dort, wo die Schildkröte ist.',p:'Str(s),[Intg(n)],[Real(x)],[Real(y)]'},
    'edge_connectivity':{d:'',p:'graph(G)'},
    'edges':{d:'',p:'Graph(G),[weights]'},
    'efface':{d:'Löscht den Schildkrötenbildschirm oder die Schildkröte geht n Schritte zurück beim Löschen.',p:'NULL or Real(n)'},
    'egcd':{d:'Erweitertet größter gemeinsamer Teiler von 2 Polynomen.',p:'(Poly or Lst),(Poly or Lst),[Var]',a:['gcdex']},
    'egv':{d:'Berechnet die Eigenvektoren einer diagonalisierbaren Matrix.',p:'Mtrx',a:['eigenvectors','eigenvects','eigVc']},
    'egvl':{d:'Gibt die Jordannormalform von A zurück, wenn die Eigenwerte berechenbar sind.',p:'Mtrx(A)',a:['eigVl']},
    'eigenvals':{d:'Gibt die Folge der (berechenbaren) Eigenwerte einer Matrix zurück.',p:'Mtrx',a:['eigenvalues']},
    'element':{d:'Zeigt einen Punkt, der auf einer Kurve gewählt wurde oder eine reelle Zahl, die in einem Intervall gewählt wurde.',p:'(Curve or Real_interval),[Val]'},
    'elif':{d:'Kurze Schreibweise von else if, die verwendet wird, falls es mehrere if...else if… und so weiter gibt: if Bedingung1 then Instruktion1; elif Bedingung2 then Instruktion2;...[else Instruktion;] end'},
    'eliminate':{d:'Eliminiert die Variable vars in der Liste der algebraischen Gleichungen.',p:'LstEq(eqs),LstVar(vars)'},
    'ellipse':{d:'ellipse(F1,F2,M)=Ellipse mit Brennpunkten F1,F2 durch M oder so das MF1+MF2=2*a (geo2d). ellipse(p(x,y)) zeichnet den Kegelschnitt wenn deg(p)=2.',p:'Pnt(F1),Pnt(F2),(Pnt(M) or Real(a))'},
    'else':{d:'Steht vor der Instruktion, die ausgeführt werden soll, wenn in einer „if“-Struktur die Bedingung nicht erfüllt wird:if (condition){instruction1;} else {instruction2;}'},
    'emd':{d:'',p:'Lst(data),[opts]'},
    'end':{d:'Ende eines Blocks.',a:['end_for','fpour','end_while','ftantque','end_if','fi','fsi','od','ffaire','ffonction','ffunction']},
    'enumerate':{d:'',p:'Lst(l),[Intg(start)]'},
    'envelope':{d:'Gibt die Umhüllende wieder, die durch die Kurven der Gleichung Xpr=0 erzeugt wird, wenn t bewegt wird.',p:'Expr(Xpr),Var(t)||[x,y,t]'},
    'epsilon':{d:'Gibt den Wert von Epsilon der CAS-Konfiguration zurück.',p:'NULL'},
    'epsilon2zero':{d:'Werte < epsilon werden durch 0 ersetzt.',p:'Expr'},
    'equal':{d:'Präfix-Version von =',p:'Expr,Expr'},
    'equal2diff':{d:'A=B oder equal(A,B) wird in die Differenz A-B umgewandelt.',p:'Equal'},
    'equal2list':{d:'A=B oder equal(A,B) wird in die Liste [A,B] umgewandelt.',p:'Equal'},
    'equation':{d:'equation gibt die kartesische Gleichung einer Kurve an.',p:'GeoObj, VectParam'},
    'equilateral_triangle':{d:'equilateral_triangle(A,B) (bzw. equilateral_triangle(A,B,P)) zeichnet das direkte gleichseitige Dreieck ABC  von der Seite AB aus (bzw in der Halb-Ebene ABP).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),[Pnt(P)],[Var(C)]'},
    'erase':{d:'Löscht den Grafik-Bildschirm.',p:'NULL'},
    'erase3d':{d:'Löscht den 3D Grafikbildschirm.',p:'NULL'},
    'erf':{d:'Gibt den approximativen Wert von 2/sqrt(pi)*int(exp(-t^2),t,0,x0) zurück.',p:'Real(x0)'},
    'erfc':{d:'Gibt den approximativen Wert von 2/sqrt(pi)*int(exp(-t^2),t,x0,+infinity) zurück.',p:'Real(x0)'},
    'error':{d:'Ermöglicht das Anzeigen eines Fehlers im Programm.',p:'Str',a:['ERROR','throw']},
    'euler':{d:'',p:'Intg(n)',a:['Phi']},
    'euler_gamma':{d:'Eulers Konstante=euler_gamma=limit(sum(1/k,k,1,n)-ln(n),n,+infinity).'},
    'euler_lagrange':{d:'',p:'Expr(f),[(Var(x),[Var||Lst(y)]) || y(x) || Lst(y(x))]'},
    'eval':{d:'Evaluiert das Argument.',p:'Expr',a:['evalm']},
    'eval_level':{d:'Auswertungs-Niveau im interaktiven Modus (n sagt wie oft man eine Variable durch seine Wert ersetzt umgekehrt ist es standardmäßig der Wert von eval aus der Konfiguration von CAS)',p:'[Intg(n)]'},
    'evalb':{d:'Boolesche Auswertung des Arguments.',p:'Expr'},
    'evalc':{d:'Gibt einen komplexen Ausdruck in der vereinfachten Form real+i*imag zurück.',p:'Expr'},
    'evalf':{d:'Numerische Auswertung des ersten Arguments (wir können im zweiten Argument die Zahl der Nachkommastellen angeben).',p:'Expr,[Int]',a:['approx']},
    'even':{d:'Gibt für gerade Zahlen 1 und für ungerade Zahlen 0 zurück.',p:'Intg(n)'},
    'evolute':{d:'Evolute einer Kurve C.',p:'Curve'},
    'exbisector':{d:'Zeichnet die äußere Winkelhalbierende des Winkels (AB,AC) gegeben durch die Punkte A,B,C.',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Pnt(C) or Cplx)'},
    'excenter':{d:'',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'excircle':{d:'excircle(A,B,C) zeichnet den Ankreis (A-excircle) an das Dreieck ABC relativ zum Punkt A.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'exp':{d:'Exponentialfunktion oder Option des Befehls convert/convertir (identisch trig2exp).',p:'Expr or Opt',a:['EXP']},
    'exp2list':{d:'Gibt die Liste wieder, die mit der rechten Seite von (var=expr0 oder var=expr1) gemacht wurde, damit sie nach der Lösung im TI Modus verwendet werden kann.',p:'Expr'},
    'exp2pow':{d:'Transformiert exp(n*ln(x)) in x^n.',p:'Expr'},
    'exp2trig':{d:'Wandelt die komplexe Exponentialfunktion in Sinus und Kosinus um.',p:'Expr'},
    'expand':{d:'Ausmultipliziert vollständig.',p:'Expr',a:['fdistrib','developper']},
    'expexpand':{d:'',p:'Expr'},
    'expln':{d:'Option des convert oder convertir Befehls (id trig2exp).',p:'Opt'},
    'exponential':{d:'Gibt die Wahrscheinlichkeitsdichte bei x der Exponentialverteilung mit dem Parameters lambda zurück.',p:'Real(lambda),Real(x)',a:['exponentiald']},
    'exponential_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine exponentialverteilte Zufallsvariable (mit Parameter lambda) auf [a,b] kleiner als x0 (bzw. zwischen x0 und y0 ist).',p:'Real(lambda),Real(x0),[Real(y0)]',a:['exponentiald_cdf']},
    'exponential_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine standardverteilte Zufallsvariable (mit Parameter lambda) auf [a,b] kleiner als h ist, p ist (0<=p<=1).',p:'Real(lambda),Real(x0),Real(p)',a:['exponentiald_icdf']},
    'exponential_regression':{d:'Gibt die Koeffizienten (a,b) von y=b*a^x zurück: Das ist die Exponentialfunktion, die die Punkte, die durch die Zeilen von A (oder zwei Listen) gegeben wurden, am besten approximiert.',p:'Lst||Mtrx(A),[Lst]'},
    'exponential_regression_plot':{d:'Gibt den Plot von y=b*a^x zurück: Das ist die Exponentialfunktion, die die Punkte, die durch die Zeilen von A (oder zwei Listen) gegeben wurden, am besten approximiert.',p:'Lst||Mtrx(A),[Lst]'},
    'export_graph':{d:'',p:'Graph(G),Str("filename"),[opts]'},
    'export_mathml':{d:'',p:'Expr,[display||content]'},
    'expr':{d:'Instruktion die einen String in einen Befehl oder eine Zahl umformt.',p:'Str',a:['execute']},
    'extract_measure':{d:'extract_measure gibt den Wert, der im Argument berechnet wird, als Antwort.',p:'Var'},
    'extrema':{d:''},
    'ezgcd':{d:'Größter gemeinsamer Nenner von 2 Polynomen mit mindestens 2 Variablen, mit dem ezgcd Algorithmus.',p:'Poly,Poly'},
    'f2nd':{d:'Gibt die Liste der Zähler und Nenner der vereinfachte Brüche zurück.',p:'Frac or RatFrac',a:['fxnd']},
    'fMax':{d:'Gibt die Abszisse des Maximums eines Ausdrucks zurück.',p:'Expr,[Var]'},
    'fMin':{d:'Gibt die Abszisse des Minimums eines Ausdrucks zurück.',p:'Expr,[Var]'},
    'fPart':{d:'Gibt die Bruchzahl zurück.',p:'Real||LstReal',a:['frac']},
    'faces':{d:'Gibt die Liste der Seiten (1Seite=matrix(n,3) wobei die n Zeilen die n Ecken der Seite sind) des Polyeders P.',p:'Polygon or Polyedr(P)'},
    'factor':{d:'Faktorisiert ein Polynom.',p:'Expr',a:['factoriser']},
    'factor_xn':{d:'Faktorisiert x^n in P(n=Grad des Polynoms P).',p:'Poly(P)'},
    'factorial':{d:'factorial(n)=n! . Für nicht ganzzahlige Argumente factorial(a)=G(a+1) G ist die Eulersche Gamma-Funktion',p:'Intg(n)|| Real(a)'},
    'factors':{d:'Gibt die Liste der Primfaktoren eines Polynoms zurück (jedem Faktor folgt seine Multiplizität).',p:'Poly or LstPoly'},
    'fadeev':{d:'Option des Kommandos pcar oder charpoly, um den Algorithmus zu spezifizieren.',p:'Opt'},
    'false':{d:'boolean gleich falsch (0)',a:['FALSE','False']},
    'fclose':{d:'Schließt die Datei f.',p:'File(f)',a:['close']},
    'fcoeff':{d:'Gibt das Polynom zurück, das durch die Liste (Nullstellen oder Pole, Multiplizität) beschrieben wird.',p:'Lst(root||pole,order)'},
    'feuille':{d:'Gibt die Argumente eines Operators als Folge zurück.',p:'Op or Fnc',a:['op']},
    'fft':{d:'Schnelle Fouriertransformation (Fast Fourier Transform) in â„? oder im endlichen Körper â„¤/pâ„¤ mit a als einfache n-te Wurzel von 1 (n=Größe(L)).',p:'Vect or (Vect(L),Intg(a),Intg(p)'},
    'filled':{d:'Option des Befehls display um Zeichnungen auszufüllen.',p:'Opt'},
    'filled_1':{d:'',p:'Opt'},
    'filled_2':{d:'',p:'Opt'},
    'filled_3':{d:'',p:'Opt'},
    'filled_4':{d:'',p:'Opt'},
    'filled_5':{d:'',p:'Opt'},
    'fin_enregistrement':{d:'Markiert das Ende der Aufzeichnung der Befehle und speichert diese Befehle in einer Datei. Der Name der Datei wird im Argument festgelegt.',p:'Str(nom_de_fichier)'},
    'find':{d:'',p:'Expr,Vect'},
    'find_cliques':{d:'',p:'Graph(G),[Intg(k)||Intrv(m..n)]'},
    'find_cycles':{d:'',p:'Graph(G,[length=k||l..u])'},
    'find_minimum':{d:'',p:'(Expr||Func)(f),Real(a),Real(b),[Real(eps),Intg(maxiter)]'},
    'find_vertex_cover':{d:'',p:'Graph(G),[Intg(k)]'},
    'findhelp':{d:'Zeigt die Hilfe des Befehls an (wenn ? eingefügt ist siehe when).',p:'Cmd',a:['?']},
    'fisher':{d:'Gibt die Wahrscheinlichkeitsdichte der F-Verteilung zurück. (n und m sind Anzahlen von Freiheitsgraden).',p:'Intg(n),Intg(m),Real(x0)',a:['snedecor','fisherd','snedecord']},
    'fisher_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Chi^2 verteilte Zufallsvariable kleiner als x0 ist (n und m sind Anzahlen von Freiheitsgraden).',p:'Intg(n),Intg(m),Real(x0)',a:['snedecor_cdf','fisherd_cdf','snedecord_cdf']},
    'fisher_icdf':{d:'Gibt h so zurück, dass die Wahrscheinlichkeit, dass eine Chi^2 verteilte Zufallsvariable kleiner als h ist, p ist. (n und m sind Anzahlen von Freiheitsgraden und 0<=p<=1).',p:'Intg(n),Intg(m),Real(p)',a:['snedecor_icdf','fisherd_icdf','snedecord_icdf']},
    'fitdistr':{d:'',p:'Lst(L),Fnc(D)'},
    'fitpoly':{d:'',p:'Expr||Mtrx||Seq(Lst(x),Lst(y)),[Var[=Real(a)..Real(b)]],[Options]'},
    'fitspline':{d:'',p:'Mtrx(data),(Var||Lst)(x),[opts]'},
    'flatten':{d:'Flache rekusiv eine Liste aus Listen ab.',p:'Lst||Image'},
    'float2rational':{d:'Wandelt den Ausdruck in einen rationalen oder reellen Ausdruck um.',p:'Expr',a:['exact']},
    'floor':{d:'Gibt die größte ganze Zahl <= dem Argument zurück.',p:'Real or Cplx'},
    'flow_polynomial':{d:'',p:'Graph(G),[Var(x)]'},
    'flower_snark':{d:'',p:'Intg(n)'},
    'fmod':{d:'',p:'Real(a),Real(b)'},
    'foldl':{d:'',p:'op,id,Seq(r1,r2,...)'},
    'foldr':{d:'',p:'op,id,Seq(r1,r2,...)'},
    'fopen':{d:'Öffnet die Datei mit Namen s und gibt eine Variable des Typs Datei zurück.',p:'Str(s)'},
    'for':{d:'Schleife:  for (Initialisierung;do_if_true;Hochzählen) {Aktion;}'},
    'fork_timeout':{d:'',p:'Expr(f),Real(dt)'},
    'format':{d:'Transformiert eine reelle Zahl in einen String, mit dem angegeben Format (f=float, s=wissenschaftlich, e=Ingenieur).',p:'Real,Str("f4"||"s5"||"e6")'},
    'fourier':{d:'',p:'Expr(f(x)),[Var(x),[Var(s)]]'},
    'fourier_an':{d:'Gibt den n-ten Fourrier-Koeffizienten zurück an=2/T*integrate(f(x)*cos(2*pi*n*x/T),a,a+T).',p:'Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)'},
    'fourier_bn':{d:'Gibt den n-ten Fourrier-Koeffizienten zurück bn=2/T*integrate(f(x)*sin(2*pi*n*x/T),a,a+T).',p:'Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)'},
    'fourier_cn':{d:'Gibt den n-ten Fourrier-Koeffizienten cn=1/T*integrate(f(x)*exp(-2*i*pi*n*x/T),a,a+T) zurück.',p:'Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)'},
    'fprint':{d:'Schreibt Daten in Datei f.',p:'File(f),Var,[Var,Var...]'},
    'fracmod':{d:'Gibt den Bruch a/b so zurück, dass b*Xpr=a mod n, -sqrt(n)/2<a<=sqrt(n)/2 und 0<=b<sqrt(n)/2.',p:'Expr(Xpr),Intg(n)',a:['iratrecon']},
    'frame_2d':{d:'frame_2d() zeichnet die Achsen des 2-d Grafikbildschirms.',p:'NULL'},
    'frame_3d':{d:'frame_3d() zeichnet die Achsen des 3-d Grafikbildschirms.',p:'NULL'},
    'frames':{d:'Option vom "animate" und "animate3d" Befehl, um die Nummer der Bilder anzuzeigen.',p:'Opt',a:['trames']},
    'frank_wolfe':{d:'',p:'Expr(f),Mtrx(A),[opts]'},
    'frenet':{d:'',p:'[X(t),Y(t)],t,[t0]'},
    'frequencies':{d:'Gibt die Häufigkeit eines Wertes in einer Liste zurück',p:'Lst'},
    'frobenius_norm':{d:'Frobeniusnorm einer Matrix A (=sqrt(sum |aij|^2)).',p:'Mtrx'},
    'froot':{d:'Gibt die Liste der Nullstellen und Pole von F mit ihrer Multiplizität zurück.',p:'RatPoly(F)'},
    'fsolve':{d:'Numerische Lösung einer Gleichung oder eines Systems von Gleichungen.',p:'Expr,Var,[Guess or Interval],[Method]'},
    'function':{d:'Instruktion die eine benutzerspezifische Funktion definiert.',p:'Fnc(f)',a:['fonction']},
    'function_diff':{d:'Gibt die Ableitung von der Funktion f zurück.',p:'Fnc(f)',a:['fonction_derivee']},
    'fundamental_cycle':{d:'',p:'Graph(G)'},
    'gammad':{d:'Gibt die Gamma-Wahrscheinlichkeitsdichte zurück  (=x^(a-1)*exp(-b*x)*b^a/Gamma(a))',p:'Real(a>0),Real(b>0),Real(x>=0)'},
    'gammad_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine gammaverteilte Zufallsvariable (mit a und b als Parameter) kleiner als x0 (bzw. zwischen x0 und y0) ist.',p:'Real(a>0),Real(b>0),Real(x0>=0),[Real(y0>=0)]'},
    'gammad_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine gammaverteilte Zufallsvariable kleiner als h ist, p ist (0<=p<=1).',p:'Real(a>0),Real(b>0),Real(0<=p<=1)'},
    'gauss':{d:'Spaltet eine quadratische Form in Summen und Differenzen von Quadraten auf.',p:'Expr,VectVar'},
    'gauss_seidel_linsolve':{d:'Loesung eines linearen Gleichungssystems A*X=b mit dem Gauss-Seidel-Verfahren (ohne Spezifikition omega=1) oder dem Relaxationsverfahren, wobei die Groesse des Fehlers mit eps und die die maximale Anzahl der Iterationen mit maxiter festgelegt wird',p:'[Real(omega)],Mtrx(A),Vect(b),Real(eps),[Int(maxiter)]'},
    'gaussian_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'gaussquad':{d:'Gibt den ungefähren Wert von integrate(f(x),x,a,b) durch adaptive Gauß-Quadratur mit 15 Punkten zurück.',p:'Expr(f(x)),Var(x),Real(a),Real(b)'},
    'gbasis':{d:'Gröbnerbasis des Ideals aufgespannt durch die Liste von Polynome.',p:'LstPoly,LstVar,[order]'},
    'gbasis_max_pairs':{d:'',p:'Intg'},
    'gbasis_reinject':{d:'',p:'Real(a),[Real(b)]'},
    'gbasis_simult_primes':{d:'',p:'Intg'},
    'gbasis_vars':{d:'',p:'List'},
    'gcd':{d:'Gibt den größten gemeinsamen Teiler von 2 Polynomen mit vielen Variablen zurück oder von 2 ganzen Zahlen oder von 2 rationalen Zahlen.',p:'(Intg(a) or Poly),(Intg(b) or Poly)',a:['igcd']},
    'genpoly':{d:'Gibt das Polynom mit n Variablen Q zurück (-b/2<=coef<=b/2). Dieses wurde rekonstruiert von einem Polynom mit (n-1) Variablen P und einer Basis b (subst(Q,var=b)=P).',p:'Poly(P),Intg(b),Var'},
    'geodetic2ecef':{d:'',p:'Real(latitude),Real(longitude),Real(height)'},
    'geometric':{d:'Gibt den Wert bei k der geometrischen Verteilung mit Parameter p (0<p<1) zurück.',p:'Real(p),Intg(k)'},
    'geometric_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine geometrisch verteilte Variable mit Parameter p (0<p<1) kleiner als k ist (oder zwischen k und m).',p:'Real(p),Intg(k),[Intg(m)]'},
    'geometric_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit einer geometrisch verteilten Zufallsvariable mit dem Parameter p (0<p<1) kleiner als h zu sein, x ist (0<=x<=1).',p:'Real(p),Real(x)'},
    'getDenom':{d:'Gibt den Nenner des nicht vereinfachten Ausdruck zurück (außer für rationale Zahlen)',p:'Expr'},
    'getKey':{d:'Instruktion in einem Programm, die 0 zurückgibt, wenn keine Taste gedrückt ist und sonst den ASCII Code der gedrückten Taste zurückgibt.',p:'NULL'},
    'getNum':{d:'Gibt den Zähler des nicht vereinfachten Ausdruck zurück (außer für rationale Zahlen)',p:'Expr'},
    'getType':{d:'Gibt den Typ des Argumentes zurück(STR,EXPR,FUNC,NUM,LIST,MAT,VAR,NONE,PIC…).',p:'Expr'},
    'get_edge_attribute':{d:'',p:'Graph(G),Edge(e),Seq(tag1=value1,tag2=value2,..)'},
    'get_edge_weight':{d:'',p:'Graph(G),Edge(e)'},
    'get_graph_attribute':{d:'',p:'Graph(G),Seq(tag1=value1,tag2=value2,..)'},
    'get_vertex_attribute':{d:'',p:'Graph(G),Vrtx(v),Seq(tag1=value1,tag2=value2,..)'},
    'girth':{d:'',p:'Graph(G)'},
    'gl_ortho':{d:'Option, die erlaubt eine orthonormale Grafik-Konfiguration zu definieren.',p:'Opt=Interval'},
    'gl_quaternion':{d:'Option, die die Quaternionen für eine Visualisieren in 3-D Szenen definiert (nicht in interaktiven Szenen verwenden!)',p:'Opt=Lst'},
    'gl_rotation':{d:'Globale Option, die erlaubt eine Rotationsachse für die Animation von 3-D Szenen zu definieren.',p:'Opt=NameFich'},
    'gl_showaxes':{d:'',p:'Opt=Boolean'},
    'gl_shownames':{d:'Option die Objektnamen anzeigt oder versteckt.',p:'Opt=Boolean'},
    'gl_texture':{d:'Option die ein Bild in einem Rechteck mit Seiten Parallel zu den Achsen (2d) einfügt. Es kann auch auf einer 3-D Oberfläche eingefügt werden oder den Hintergrund auffüllen (2-d).',p:'Opt=NameFich'},
    'gl_x':{d:'Globale Option, die es erlaubt die Grafik-Konfiguration zu definieren.',p:'Opt=Interval',a:['gl_y','gl_z']},
    'gl_x_axis_color':{d:'Globale Option, die erlaubt individuell die Farbe der x, (y,z) Achse zu definieren.',p:'Opt=Intg',a:['gl_y_axis_color','gl_z_axis_color']},
    'gl_x_axis_name':{d:'Globale Option, die erlaubt individuell die Namen der x, (y,z) Achse zu definieren.',p:'Opt=Str',a:['gl_y_axis_name','gl_z_axis_name']},
    'gl_x_axis_unit':{d:'Globale Option, die erlaubt individuell die Einheiten der x, (y,z) Achse zu definieren.',p:'Opt=Str',a:['gl_y_axis_unit','gl_z_axis_unit']},
    'gl_xtick':{d:'Globale Option, die das Intervall zwischen Strichen auf der x- (bzw. y,z-) Achse definiert.',p:'Opt=Real',a:['gl_ytick','gl_ztick']},
    'gnuplot':{d:'Prozessiert einen gnuplot Befehl (im 3D Bildschirm).',p:'Str'},
    'goldberg_snark':{d:'',p:'Intg(n)'},
    'goto':{d:'Wird in einem Programm genutzt, um zu einer Instruktion mit der Bezeichnung nom zu springen.',p:'Var(nom)'},
    'grad':{d:'Gibt den Gradient des Ausdrucks Xpr zurück.',p:'Expr(Xpr),LstVar'},
    'gramschmidt':{d:'Gibt eine orthonormale Basis von E mit der Basis B für das Skalarprodukt Sp zurück.',p:'Basis(B),ScalarProd(Sp)'},
    'graph':{d:'',p:'[Lst(V)],[Set(E)],[Mtrx(A)],[options]'},
    'graph2tex':{d:'Wandelt den Grafikbildschirm in eine LaTeX-Datei um.',p:'[Str("filename")]'},
    'graph3d2tex':{d:'Wandelt den 3D Grafik-Bildschirm in eine LaTeX-Datei um.',p:'[Str"filename")]'},
    'graph_automorphisms':{d:'',p:'Graph(G)'},
    'graph_charpoly':{d:'',p:'Graph(G),[Var(x)]'},
    'graph_complement':{d:'',p:'Graph(G)'},
    'graph_diameter':{d:'',p:'Graph(G)'},
    'graph_equal':{d:'',p:'Graph(G1),Graph(G2)'},
    'graph_join':{d:'',p:'Graph(G),Graph(H)'},
    'graph_power':{d:'',p:'Graph(G),Intg(k)'},
    'graph_rank':{d:'',p:'Graph(G),[Lst(E)]'},
    'graph_spectrum':{d:'',p:'Graph(G)'},
    'graph_union':{d:'',p:'Seq(G1,G2,...)'},
    'graph_vertices':{d:'',p:'Graph(G)'},
    'greduce':{d:'Gibt den Rest der Division eines Polynoms durch eine Gröbnerbasis zurück.',p:'Poly,LstPoly,LstVar,[order]'},
    'greedy_clique':{d:'',p:'Graph(G),[Intg(n)]'},
    'greedy_color':{d:'',p:'Graph(G),[Permu(p)]'},
    'greedy_independent_set':{d:'',p:'Graph(G),[Intg(n)]'},
    'grid_graph':{d:'',p:'Intg(m),Intg(n),[triangle]'},
    'grid_paper':{d:'Zeichnet in das Rechteck [xmin..xmax]*[ymin..ymax], die Linien eines Netzwerks, konstruiert durch die Linien y=n*uy und in der Achse OxY des Winkels t!=0 mit den Linien x=n*ux',p:'Real(ux),Real(t),Real(uy),[x=xmin..xmax,y=ymin..ymax]'},
    'groupermu':{d:'Gibt die Gruppe der Permutationen, generiert von a und b zuück.',p:'Permut(a),Permut(b)'},
    'haar_graph':{d:'',p:'Intg(n)'},
    'hadamard':{d:'Obere Schranke nach der Hadamard-Ungleichung einer Matrix oder elementweise Multiplikation von 2 Matrizen.',p:'Mtrx,Mtrx'},
    'half_cone':{d:'Zeichnet einen Halb-Kegel mit Vertex a, Richtung v und dem Öffnungswinkel t[und mit Höhe h und -h]',p:'Pnt(A),Vect(v),Real(t),[Real(h)]'},
    'half_line':{d:'half_line(A,B) zeichnet die Halbgerade AB mit A als Ursprung.',p:'(Pnt or Cplx),(Pnt or Cplx)'},
    'halftan':{d:'Wandelt sin(x),cos(x) und tan(x) in Funktionen von tan(x/2) um.',p:'Expr'},
    'halftan_hyp2exp':{d:'Wandelt die trigonometrische Funktion in tan(x/2) und hyperbolische Funktionen in Exponentialfunktionen um.',p:'ExprTrig'},
    'halt':{d:'Schaltet ein Programm in einen Schritt-für-Schritt debug-Modus um.',p:'NULL'},
    'hamdist':{d:'Bit Hamming-Abstand.',p:'Intg,Intg'},
    'hamming':{d:'',p:'Str(s1)||Lst(s1),Str(s2)||Lst(s2)'},
    'hamming_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'hann_poisson_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'hann_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'harmonic_centrality':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'harmonic_conjugate':{d:'Gibt die harmonische Konjugierte C bezüglich A und B von 3 Punkten oder von 3 Parallelen bzw. 3 kopunktualen Geraden zurück. Alternativ kann auch die harmonische Konjugierte C bezüglich der Polaren eines Punktes bezüglich zweier Geraden erhalten werden.',p:'Line or Pnt(A),Line or Pnt(B),Line or Pnt(C)'},
    'harmonic_division':{d:'Gibt die 4 Punkte (respektive Geraden) zurück und beeinflusst das letzte Argument so, dass die 4 Punkte eine harmonische Teilung formen.',p:'Pnt or Line,Pnt or Line,Pnt or Line,Var'},
    'has':{d:'Testet ob die Variable im Ausdruck vorkommt.',p:'Expr,Var'},
    'has_arc':{d:'',p:'Graph(G),Edge(e)'},
    'has_edge':{d:'',p:'Graph(G),Edge(e)'},
    'hasard':{d:'hasard(n)=eine zufällige ganze Zahl (bzw. hasard(p,n)= eine reelle Zahl oder hasard(p..n)=eine reelle Funktion) mit uniformer Verteilung in 0...n-1 (bzw. in [p;n])(hasard()=hasard(0,1)= eine reelle Zahl in [0,1[). Alternativ hasard(n,b1,b2)=n ganze Zahlen zwischen b1 und b2 oder rand(n,L)=n Elemente von L. Wenn hasard nur ein Argument hat sind die () nicht notwendig. (Kompatibel mit Schildkröte)',p:'Intg(n) or Interval(p..n) or NULL,[Intg(b1) or Lst(L)],[Intg(b2)]'},
    'head':{d:'Zeigt das erste Element eines Vektors, einer Folge oder eines Strings.',p:'Vect or Seq or Str'},
    'heapify':{d:'',p:'List'},
    'heappop':{d:'',p:'List'},
    'heappush':{d:'',p:'List,Object'},
    'hermite':{d:'Gibt das Hermite-Polynom von Grad n zurück oder die hermitesche Normalform für die Koeffizientenmatrix einer Matrix. (I,U sodass I*A=U).',p:'Intg(n)||Matr(A)'},
    'hessenberg':{d:'Matrixreduktion auf Hessenberg-Form. Gibt [P,B] wieder, sodass B = inv(P)*A*P, ohne Spezifikation n=0 und das Resultat ist exakt. Sonst ist das Resultat numerisch. Für n=-1 ist B eine oberer Dreiecksmatrix, n=-2 P ist Orthogonal und wenn n eine Primzahl ist, wird das Resultat mod n angegeben.',p:'Mtrx(A),[Intg(n)]'},
    'hessian':{d:'Gibt die Hesse-Matrix des Ausdrucks Xpr zurück.',p:'Expr(Xpr),LstVar'},
    'heugcd':{d:'Größter gemeinsamer Nenner von 2 Polynomen, mit dem sogenannten „heuristische pgcd“-Algorithmus.',p:'Poly,Poly'},
    'hexagon':{d:'Zeichnet und gibt zurück das Hexagon der Seite AB (ABCDEF ist direkt) (in der Ebene ABP)',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,[Pnt(P)],[Var(C)],[Var(D)],[Var(E)],[Var(F)]'},
    'hht':{d:'',p:'Lst(data)||Mtrx(imf),[opts]'},
    'hidden_name':{d:'Option des Befehls display um Namen zu verbergen.',p:'Opt'},
    'highlight_edges':{d:'',p:'Graph(G),Edge(e)||Lst(E),[Color(c)||Lst(C)]'},
    'highlight_subgraph':{d:'',p:'Graph(G),Graph(S)||Lst(S1,S2,..),Seq(c1,c2)'},
    'highlight_trail':{d:'',p:'Graph(G),Trail(t)||Lst(T),[Color(c)||Lst(C)]'},
    'highlight_vertex':{d:'',p:'Graph(G),Vrtx(v)||Lst(V),[Color(c)||Lst(C)]'},
    'highpass':{d:'',p:'Lst(s),Real(c),[Intg(samplerate)]'},
    'hilbert':{d:'Gibt die Hilbert-Matrix der Ordnung n zurück: Hjk=1/(j+k+1) j,k=1..n',p:'Intg(n)||(Expr(f),[Var(x)])||Lst(u)'},
    'histogram':{d:'Zeichnet das Histogramm von Daten. Optionale Argumente sind eff (Zahl der Daten für jedes Datenelement) oder nc (Anzahl der Klassen) oder classmin (Minimum der Klassen) oder classsize (Größe der Klasse).',p:'Lst(data),[Lst(eff) || Intg(nc) || Real(classmin)],[Real(classsize)]'},
    'homogeneize':{d:'',p:'Expr(P),[Var(t)]'},
    'homothety':{d:'homothety(C,k,A)=Punkt A1 sodass vect(C,A1)=k*vect(C,A) in 2D ist es also das Ähnlichkeitszentrum C, abs(k) ist das Verhältnis und arg(k) ist der Winkel.',p:'Pnt(C),Real(k),Pnt(A)'},
    'horner':{d:'Gibt den Wert von P(a) berechnet durch das Horner-Schema zurück. horner(liste_alpha_i,liste_x_i,x) erlaubt es die Auswertung mit Hilfe der geteilten Differenzen durchzuführen, die ein Interpolationspolynom bei x berechnen.',p:'Poly(P),Real(a)'},
    'hsv':{d:'',p:'Lst(h,s,v)||Color(c)'},
    'hsv2rgb':{d:'',p:'Lst(h,s,v)'},
    'hyp2exp':{d:'Transformiert hyperbolische Funktionen in Exponentialfunktionen.',p:'ExprHyperb'},
    'hyperbola':{d:'hyperbola(F1,F2,M)=Hyperbel mit Brennpunkt F1,F2 durch M oder (|MF1-MF2|=2*a geo2d). hyperbola(p(x,y)) zeichnet den Kegelschnitt, wenn deg(p)=2.',p:'Focus(F1),Focus(F2),(Pnt(M) or Real(a))'},
    'hypercube_graph':{d:'',p:'Intg(n)'},
    'i':{d:'Wurzel aus -1'},
    'iPart':{d:'Gibt das Argument ohne seinen Bruchzahl-Teil zurück. (type=DOM_FLOAT).',p:'Real||LstReal'},
    'i[]':{d:'i[] wird benutzt um ein reelles Intervall zu definieren.',p:'Seq(a,b)',a:['[..]']},
    'iabcuv':{d:'Gibt [u,v] zurück, sodass au+bv=c für drei ganze Zahlen a,b,c.',p:'Intg(a),Intg(b),Intg(c)'},
    'ibasis':{d:'Basis der Schnittmenge aus zwei Vektorräumen.',p:'Lst(Vect,..,Vect),Lst(Vect,..,Vect)'},
    'ibpdv':{d:'Partielle Integration von f(x)=u(x)*v‘(x) mit f(x) als erstem Argument und v(x) (oder 0 um direkt zu integrieren) als zweites Argument. Die Integrationsvariable kann spezifiziert werden, genauso wie die Berechnung des Integrals (Grenzen a und b).',p:'Expr(f(x)),Expr(v(x)),[Var(x)],[Real(a)],[Real(b)]'},
    'ibpu':{d:'Partielle Integration von f(x)=u(x)*v‘(x) mit f(x) als erstem Argument und v(x) (oder 0 um direkt zu integrieren) als zweites Argument. Die Integrationsvariable kann spezifiziert werden, genauso wie die Berechnung des Integrals (Grenzen a und b).',p:'Expr(f(x)),Expr(u(x)),[Var(x)],[Real(a)],[Real(b)]'},
    'icdf':{d:'Inverse kumulierte Verteilungsfunktion eines Wahrscheinlichkeitsgesetzes.',p:'Func,FuncParams'},
    'ichinrem':{d:'Chinesischer Rest (Ganzzahlen)',p:'LstIntg(a,p),LstIntg(b,q)',a:['ichrem']},
    'icomp':{d:'',p:'Intg(n),Intg(k),[zeros=true||false]'},
    'icontent':{d:'Größter gemeinsamer Nenner der ganzzahligen Koeffizienten eines Polynoms.',p:'Poly,[Var]'},
    'icosahedron':{d:'Zeichnet einen Ikosaeder mit Zentrum A,Vertex B und so, dass die Ebene ABC einen der 5 Vertices enthält, die am nächsten an B sind.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'id':{d:'Name der Identitätsabbildung.',p:'Seq'},
    'identify_graph':{d:'',p:'Graph(G)'},
    'identity':{d:'Gibt die Einheitsmatrix der Dimension n zurück.',p:'Intg(n)',a:['idn']},
    'idivis':{d:'Gibt die Liste der Teiler einer ganzen Zahl zurück.',p:'Intg(a) or LstIntg',a:['divisors']},
    'idwt':{d:'',p:'(Lst||Mtrx)(T),[opts]'},
    'iegcd':{d:'Erweitertet größter gemeinsamer Teiler zweier ganzer Zahlen.',p:'Intg,Intg',a:['igcdex','bezout_entiers']},
    'if':{d:'Test: if(Bedingung) true_action; else false_action; (=wahr_Handlung; sonst falsch_Handlung;)'},
    'ifactor':{d:'Faktorisierung einer ganzen Zahl im Primfaktoren',p:'Intg(a)',a:['factoriser_entier']},
    'ifactors':{d:'Gibt die Liste der Primfaktoren einer ganzen Zahl zurück (jedem Faktor folgt seine Multiplizität).',p:'Intg(a) or LstIntg',a:['facteurs_premiers']},
    'ifft':{d:'Inverse Schnelle Fouriertransformation (Fast Fourier Transform).',p:'Vect'},
    'ifourier':{d:'',p:'Expr(F(s)),[Var(s),[Var(x)]]'},
    'ifte':{d:'If condition returns Expr1 else returns Expr2 (=Wenn Bedingung gebe Expr1 zurück sonst gebe Expr2 zurück).',p:'Cond,Expr1,Expr2',a:['IFTE']},
    'igamma':{d:'Berechnet den Wert der unvollständigen Gamma Funktion am Punkt (a,x). Wenn a und x>0 igamma(a,x)=int(e^{-t}*t^{a-1},t=0..x)(igamma(a,x,1)=igamma(a,x)/Gamma(a))',p:'Real(a),Real(x),[1]'},
    'ihermite':{d:'Hermite-Normalform einer Matrix mit ganzzahligen Koeffizienten: Gibt L,U zurück, sodass L invertierbar und ganzzahlig, U obere Dreiecksmatrix und U=L*A.',p:'Mtrx(A)'},
    'ilaplace':{d:'Inverse Laplace-Transformation einer rationalen Funktion.',p:'Expr,[Var],[IlapVar]',a:['invlaplace']},
    'im':{d:'Gibt den Imaginärteil einer komplexen Zahl zurück.',p:'Cplx',a:['imag']},
    'image':{d:'Bild der linearen Abbildung mit Matrix M.',p:'Mtrx(M)||Strng(imgfname)'},
    'imfplot':{d:'',p:'Lst(imf),[opts]',a:['plotimf']},
    'implicitdiff':{d:'',p:'constr,[depvars],y,diffvars'},
    'import_graph':{d:'',p:'Str("filename"),[opts]'},
    'in':{d:'Iteration for...end_for in einer Menge oder einer Liste oder einem Wertebereich.'},
    'inString':{d:'Testet, ob e im String l ist (Gibt -1 zurück oder k, wenn l[k]=e).',p:'Str(l),Elem(e)'},
    'in_ideal':{d:'Prüft ob ein Polynom oder eine Liste aus Polynomen zu einem Ideal gehört, dass durch seine Gröbnerbasis gegebenen wurde (zweites Argument), bezüglich einer Liste aus Variablen.',p:'Poly,Lst,LstVar,[order]'},
    'incenter':{d:'',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'incidence_matrix':{d:'',p:'Graph(G)'},
    'incident_edges':{d:'',p:'Graph(G),Vrtx(v)'},
    'incircle':{d:'incircle(A,B,C) zeichnet den Innenkreis des Dreiecks ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'increasing_power':{d:'',p:':=Intg(0 or 1)'},
    'independence_number':{d:'',p:'Graph(G)'},
    'index':{d:'',p:'Vect,Expr'},
    'induced_subgraph':{d:'',p:'Graph(G),Lst(V)'},
    'inertia':{d:'',p:'Mtrx(A),[B,[p0]]'},
    'infinity':{d:'Unendlich'},
    'information_centrality':{d:'',p:'Graph(G),[Vrtx(v)],[approx]'},
    'input':{d:'Instruktion in einem Programm, die erlaubt einen Ausdruck in var zu speichern.',p:'[Str],Var(Var)',a:['Input','lis']},
    'inputform':{d:'Wird in einem Programm benutzt, um Einträge zu machen.',p:'[Str],Var,[Str],[Var],[Str],[Var]'},
    'insert':{d:'Gibt l zurück, wobei das Element b am Index n eingefügt wurde.',p:'Vect(l)||Str(l),Intg(n),Val(b)'},
    'insmod':{d:'Installiert ein dynamisches Modul, indem es die Befehle, die zum Beispiel aus dem Ordnerlibprogfr.so sind, kreiert. Der Pfad zu dem Ordner wird angegeben.',p:'Str(pwd)'},
    'instfreq':{d:'',p:'Vect(u)||Expr(u),[Var(x)]'},
    'instphase':{d:'',p:'Vect(u)||Expr(u),[Var(x)]'},
    'int':{d:'Indefinites Integral, Integrationsvariable ist im zweiten Argument. Integral kann auch berechnet werden (Grenzen a und b müssen übergeben werden.',p:'Expr,[Var(x)],[Real(a)],[Real(b)]',a:['integrate','integrer']},
    'inter':{d:'Mit zwei Argument (respektive 3 Argumenten). Gibt die Schnittmenge zweier Kurven oder Oberflächen in der Form eines Vektors (respektive in Form eines Punktes, nah am Punkt im dritten Argument) zurückgegeben.',p:'Curve,Curve,[Pnt|Lst]'},
    'interactive_plotode':{d:'Zeichnet (in DispG) eine Lösung für jeden Punkt t0+i*y0, der durch Mausklick ausgewählt wurde (Esc=Stopp).',p:'Expr,VectVar',a:['interactive_odeplot']},
    'interp':{d:'',p:'Lst(colors)||Seq(Image(A),Image(B)||Color(c))||Seq(Lst(x0),Lst(y0),Lst(x))||Seq(Lst(x),Lst(y))'},
    'intersect':{d:'intersect ist der infix-Operator um die Schnittmenge zweier Mengen zu erhalten.',p:'(Vect or Set),(Vect or Set)'},
    'interval':{d:'Option des convert oder convertir Befehls.',p:'Opt'},
    'interval2center':{d:'Gibt das Zentrum eines Intervalls oder eines Objektes zurück.',p:'Interval or Real'},
    'interval_graph':{d:'',p:'Seq||Lst(a..b,c..d,...)'},
    'inv':{d:'Gibt das Inverse eines Ausdrucks oder einer Matrix zurück.',p:'Expr||Mtrx||Image||Audio',a:['inverse']},
    'inversion':{d:'inversion(C,k,A)=Punkt A1 sodass A1 auf der Linie line(C,A) ist und mes_alg(CA1*CA)=k.',p:'Pnt(C),Real(k),Pnt(A)'},
    'invztrans':{d:'Inverse z-Transformation einer rationalen Funktion.',p:'Expr,[Var],[InvZtransVar]'},
    'iquo':{d:'Euklidischer Quotient aus 2 Ganzzahlen.',p:'Intg(a),Intg(b)',a:['intDiv']},
    'iquorem':{d:'Euklidischer Quotient und Rest zweier Ganzzahlen.',p:'Intg(a),Intg(b)',a:['divmod']},
    'irem':{d:'Euklidische Rest zweier Ganzzahlen.',p:'Intg(a),Intg(b)',a:['remain']},
    'is_acyclic':{d:'',p:'Graph(G)'},
    'is_arborescence':{d:'',p:'Graph(G)'},
    'is_biconnected':{d:'',p:'Graph(G)'},
    'is_bipartite':{d:'',p:'Graph(G),[Var(P)]'},
    'is_clique':{d:'',p:'Graph(G)'},
    'is_collinear':{d:'Gibt 1 zurück, wenn die Punkte in einer Linie sind, 2 wenn die Punkte dieselbe sind. Sonst wird 0 zurückgegeben.',p:'LstPnt'},
    'is_concyclic':{d:'Gibt 1 zurück, wenn die Punkte einen Kreis bilden. Sonst wird 0 zurückgegeben.',p:'LstPnt'},
    'is_conjugate':{d:'Gibt 1 zurück, wenn die 3 (bzw. 4) Argumente bezüglich eines Kreises (respektive 2 Geraden) konjugiert sind. Sonst wird 0 zurückgegeben.',p:'Crcle||Line,Pnt||Line,Pnt||Line,[Pnt||Line]'},
    'is_connected':{d:'',p:'Graph(G)'},
    'is_coplanar':{d:'Testet ob 4 Punkte in derselben Ebene sind.',p:'Pnt,Pnt,Pnt,Pnt'},
    'is_cospherical':{d:'',p:'Pnt,Pnt,Pnt,Pnt'},
    'is_cut_set':{d:'',p:'Graph(G),Lst(E)'},
    'is_cycle':{d:'Gibt 1 zurück, wenn das Argument ein Zykel ist. Sonst wird 0 zurückgegeben.',p:'Lst'},
    'is_directed':{d:'',p:'Graph(G)'},
    'is_element':{d:'Gibt 1 zurück, wenn der Punkt auf einem geometrischen Objekt ist. Sonst wird 0 zurückgegeben.',p:'Pnt,GeoObj'},
    'is_equilateral':{d:'Gibt 1 zurück, wenn die drei Punkte (oder das Objekt) ein gleichseitiges Dreieck bilden, sonst wird 0 zurückgegeben.',p:'Pnt||Cplx,Pnt||Cplx,Pnt||Cplx'},
    'is_eulerian':{d:'',p:'Graph(G),[Var(T)]'},
    'is_forest':{d:'',p:'Graph(G)'},
    'is_graphic_sequence':{d:'',p:'Lst(L)'},
    'is_hamiltonian':{d:'',p:'Graph(G),[Var(hc)]'},
    'is_harmonic':{d:'Gibt 1 zurück, wenn die 4 Punkte eine harmonische Teilung formen. Sonst wird 0 zurückgegeben.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_harmonic_circle_bundle':{d:'Gibt 1 zurück, wenn die Kreise einen Strahl bilden, 2 wenn sie das gleiche Zentrum haben, 3 wenn sie gleich sind. Sonst wird 0 zurückgegeben.',p:'Lst(Crcle)'},
    'is_harmonic_line_bundle':{d:'Gibt 1 zurück, wenn die Geraden einen gemeinsamen Punkt bilden,2 wenn sie parallel sind, 3 wenn sie gleich sind. Sonst wird 0 zurückgegeben.',p:'Lst(Line)'},
    'is_included':{d:'Testet ob eine Menge oder eine Liste in einer anderen Menge oder Liste enthalten ist.',p:'Lst||Ens,Lst||Ens'},
    'is_inside':{d:'Prüft ob ein Punkt in einem Polygon oder Kreis ist.',p:'Pnt,Polygon or Circle'},
    'is_integer_graph':{d:'',p:'Graph(G)'},
    'is_irreducible':{d:'',p:'Polynomial'},
    'is_isomorphic':{d:'',p:'Graph(G1),Graph(G2),[Var(I)]'},
    'is_isosceles':{d:'Gibt 1,2 oder 3 zurück, wenn die freien Punkte (oder das Objekt) ein gleichschenkliges Dreieck, mit den Vertices 1,2 oder 3 bilden. Gibt 4 zurück, wenn die 3 Punkte (oder das Objekt) ein gleichseitiges Dreieck bilden, sonst 0.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_network':{d:'',p:'Graph(G),[Vrtx(s),Vrtx(t)]'},
    'is_orthogonal':{d:'Gibt 1 zurück, wenn die zwei Kreise orthogonal sind (orthogonale Tangenten am Schnittpunkt) oder 2 wenn die zwei Gerade orthogonal sind. Sonst wird 0 zurückgegeben.',p:'Line||Crcle,Line||Crcle'},
    'is_parallel':{d:'Gibt 1 zurück, wenn 2 Linien Parallel sind. Sonst wird 0 zurückgegeben.',p:'Line or Plan ,Line or Plan'},
    'is_parallelogram':{d:'Gibt 1,2,3 oder 4 zurück, wenn die 4 Punkte (oder das Objekt) ein Parallelogramm bilden, (2 für eine Raute, 3 für ein Rechteck und 4 für ein Quadrat). Sonst wird 0 zurückgegeben.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_permu':{d:'Gibt 1 zurück, wenn das Argument eine Permutation ist. Sonst wird 0 zurückgegeben.',p:'Lst',a:['est_permu']},
    'is_perpendicular':{d:'Gibt 1 zurück, wenn 2 Geraden senkrecht zueinander sind.',p:'Line or Plan,Line or Plan'},
    'is_planar':{d:'',p:'Graph(G)'},
    'is_prime':{d:'Gemischter Test: „p-1“ von Pocklington [1] oder APRCL [2] (gibt die Koeffizienten eines Beweises der Primzahleigenschaft zurück, 1 oder 0).',p:'Intg,[1 || 2]'},
    'is_pseudoprime':{d:'Pseudoprimzahl-Test (0 keine Primzahl, 1 wahrscheinlich Primzahl, 2Primzahl).',p:'Intg'},
    'is_reachable':{d:'',p:'Graph(G),Vrtx(u),Vrtx(v)'},
    'is_rectangle':{d:'Gibt 1 oder 2 wenn die drei Punkte (oder das Objekt) ein rechtwinkliges Dreieck mit den Vertices 1,2 oder 3 bilden. Sonst 0. [oder 1, wenn die 4 Punkte (oder das Objekt) ein Rechteck bilden, 2 wenn die 4 Punkte (oder das Objekt) ein Quadrat bilden und 0 sonst.]',p:'Pnt||Cplx,Pnt||Cplx,Pnt||Cplx,[Pnt||Cplx]'},
    'is_regular':{d:'',p:'Graph(G)'},
    'is_rhombus':{d:'Gibt 1 oder 2 zurück, wenn die 4 Punkte (oder das Objekt) eine Raute bilden (2 für ein Quadrat). Sonst wird 0 zurückgegeben.',p:'Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx'},
    'is_split_graph':{d:'',p:'Graph(G),[part]'},
    'is_square':{d:'Gibt 1 zurück, wenn die 4 Punkte ein Quadrat bilden. Sonst wird 0 zurückgegeben.',p:'Pnt,Pnt,Pnt,Pnt'},
    'is_strongly_connected':{d:'',p:'Graph(G)'},
    'is_strongly_regular':{d:'',p:'Graph(G),[Var(srg)]'},
    'is_subgraph_isomorphic':{d:'',p:'Graph(G1),Graph(G2),[opts]'},
    'is_tournament':{d:'',p:'Graph(G)'},
    'is_tree':{d:'',p:'Graph(G)'},
    'is_triconnected':{d:'',p:'Graph(G)'},
    'is_two_edge_connected':{d:'',p:'Graph(G)'},
    'is_vertex_colorable':{d:'',p:'Graph(G),Intg(k),[Var(col)]'},
    'is_weighted':{d:'',p:'Graph(G)'},
    'isinf':{d:'',p:'Expr'},
    'ismith':{d:'Smith-Normalform einer Matrix mit ganzzahligen Koeffizienten: Gibt U,B,V zurück, sodass U und V invertierbar und ganzzahlig, B diagonal, B[j,j] teilt B[j+1,j+1] und B=U*A*V.',p:'Mtrx(A)'},
    'isnan':{d:'',p:'Expr'},
    'isobarycenter':{d:'isobarycenter(A,B,C,…) zeichnet das Iso-Baryzentrum (Baryzentrum bei dem jeder Punkt gleich gewichtet wird) der n Punkte A,B,C,...',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'isolve':{d:'',p:'Eqn||List(Eqn),[Intg(n)||(Idnt(Z1),Idnt(Z2),...)]'},
    'isom':{d:'Findet Elemente einer 2-d oder 3-d Isometrie.',p:'Mtrx'},
    'isomorphic_copy':{d:'',p:'Graph(G),Permu(sigma)'},
    'isopolygon':{d:'Zeichnet ein reguläres Vieleck mit abs(n) Vertices, gegeben durch 2 Vertices (oder 2 und einem Punkt in der Ebene), wenn n>0 oder gegeben durch einen Vertex (oder sein Zentrum + einen Punkt in der Ebene), wenn n<0.',p:'Pnt,Pnt,[Pnt],Intg(n)'},
    'isosceles_triangle':{d:'Zeichnet das gleichseitige Dreieck ABC AB=AC und Winkel (AB,AB)=t (oder in der Ebene ABP angle(AB,AC)=angle(AB,AP) oder angle(AB,AC)=t).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Angle(t) or Pnt(P) or Lst(P,t)),[Var(C)]'},
    'isposdef':{d:'',p:'Mtrx(A)'},
    'isprime':{d:'Testet Primzahleigenschaft. (=true oder false   = wahr oder falsch).',p:'Intg(a)',a:['isPrime']},
    'istft':{d:'',p:'Mtrx(data)'},
    'ithprime':{d:'Gibt die n-te Primzahl kleiner als 2.10^8 zurück.',p:'Intg(n)'},
    'jacobi_equation':{d:'',p:'Expr(f),Var(x),Var(y),Expr(y0),Var(h),Real(a)'},
    'jacobi_linsolve':{d:'Loesung eines linearen Gleichungssystems A*X=b mit dem Jacobi-Verfahren. Die Groesse des Fehlers wird mit eps festgelegt und die die maximale Anzahl der Iterationen mit maxiter',p:'Mtrx(A),Vect(b),Real(eps),[Int(maxiter)]'},
    'jacobi_symbol':{d:'Jacobi-Symbol',p:'Intg,Intg'},
    'johnson_graph':{d:'',p:'Intg(n),Intg(k)'},
    'join':{d:'',p:'Str(sep),Lst(strlst)'},
    'jordan':{d:'Gibt die Liste zurück, die die Basiswechselmatrix und die Jordannormalform einer Matrix zurück.',p:'Mtrx'},
    'jusque':{d:'Benutzt in For-Schleife (pour...de…...jusque/to... [pas...] faire...fpour;) übersetzt:(Für...von ...bis...[Schritt...]mache...Ende für;).',a:['to']},
    'katz_centrality':{d:'',p:'Graph(G),Real(alpha),[Vrtx(v)]'},
    'keep_algext':{d:'Pseudevariable, die benutzt werden kann um algebraische Erweiterungen zu behalten (keep_algext:=1) oder um sie zu überschreiben (keep_algext:=0)',p:':=Intg(0 or 1)'},
    'keep_pivot':{d:'Option des rref Befehls.',p:'Opt'},
    'ker':{d:'Kern der linearen Abbildung der Matrix M.',p:'Mtrx',a:['kernel','nullspace']},
    'kernel_density':{d:'',p:'Lst(L),[options]',a:['kde']},
    'kill':{d:'Stoppt die Schritt-für-Schritt Ausführung eines Programms (mit Debug).',p:'NULL',a:['tuer']},
    'kmeans':{d:'',p:'Mtrx||Lst(data),[opts]'},
    'kneser_graph':{d:'',p:'Intg(n),Intg(k)'},
    'kolmogorovd':{d:'Kolmogorov-Smirnov Verteilung, 1-2*sum((-1)^(k-1)*exp(-k^2*x^2),k,1,inf)',p:'Real(x)'},
    'kolmogorovt':{d:'Test der Übereinstimmung zwischen der Kolmogorov-Smirnov-Verteilung mit einer stetigen Wahrscheinlichkeitsverteilung oder zwischen zwei Datenmengen l1 l2 (unbekannte Verteilungsregel) oder zwischen einer Datenmenge l1 und einer Wahrscheinlichkeitsverteilung s.',p:'Lst(l1),Lst(l2) || DistribLaw(s)'},
    'kovacicsols':{d:'',p:'Expr||Lst(eq),[Var(x),[Var(y)]]'},
    'kspaths':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t),Intg(k)'},
    'l1norm':{d:'Gibt die l1-Norm eines Vektors zurück=Summe der Beträge der Einträge. Alternativ die l1 Norm einer Matrix, die genauso funktioniert.',p:'Vect'},
    'label':{d:'Wird benutzt, um in einem Programm eine Instruktion mit der Bezeichnung nom zu versehen.',p:'Var(nom)'},
    'labels':{d:'labels=["u","v"] benennt die Achsen mit "u" und "v" neu.',p:'Cplx or Lst,Str'},
    'lagrange':{d:'Gibt das Polynom vom Grad n-1 zurück sodass P(xk)=yk=f(x_k) k=0..n-1 oder die Liste der dividierten Differenzen, wenn das letzte Argument lagrange ist.',p:'(Lst_xk,Lst_yk)||Mtrx_2*n||(Lst_xk,Fnc(f)),[Var||[]||lagrange]'},
    'laguerre':{d:'Gibt das n-te Laguerre Polynom zurück.',p:'Intg(n)'},
    'laplace':{d:'Laplace-Transformation',p:'Expr,[Var],[LapVar]'},
    'laplacian':{d:'Gibt den Laplace-Operator angewendet auf einen Ausdruck Xpr zurück. Der Laplace-Operator bezüglich der Liste von Variablen. Laplacian (n) für n ganzzahlig oder einen ganzzahligen Float gibt die Matrix des diskreten Laplace-Operators in einer Dimension der Größe n zurück.',p:'Expr(Xpr),LstVar'},
    'laplacian_matrix':{d:'',p:'Graph(G),[normal]'},
    'latex':{d:'Gibt den ausgewerteten Ausdruck in Latex geschrieben zurück.',p:'Expr',a:['TeX']},
    'lcf_graph':{d:'',p:'Lst(J),[Intg(k)]'},
    'lcm':{d:'Gibt das kleinste gemeinsame Vielfache von 2 Polynomen mit mehreren Variablen oder 2 ganzen Zahlen oder 2 rationalen Zahlen zurück.',p:'(Intg or Poly),(Intg or Poly)'},
    'lcoeff':{d:'Gibt die Koeffizienten des Terms mit der höchsten Ordnung in einem Polynom zurück. (l=leading=führend).',p:'Poly||Lst'},
    'ldl':{d:'',p:'Mtrx(A),[opts]'},
    'left':{d:'Gibt den linken Teil einer Gleichung, eines Intervalls, einer Liste oder eines Strings zurück.',p:'Equal(a=b) or Interval(a..b) or Str,Intg',a:['lhs','gauche']},
    'legend':{d:'legend(za,"hier") (oder legend([20,60],"hier")) "hier" wird an den Punkt des Affixes za geschrieben (oder an die Pixelposition [20,60]). legend=["m","s"] schreibt "m","s" als Einheiten der Achsen.',p:'Cplx or Lst,Str'},
    'legendre':{d:'Gibt das n-te Legendrepolynom zurück.',p:'Intg(n)'},
    'legendre_symbol':{d:'Legendre Symbol.',p:'Intg,Intg'},
    'leve_crayon':{d:'Nimmt den Stift nach oben, sodass sich die Schildkröte ohne Spuren bewegt.',p:'NULL',a:['penup']},
    'levenshtein':{d:'',p:'Str(s1)||Lst(s1),Str(s2)||Lst(s2)'},
    'lgcd':{d:'Gibt den größten gemeinsamen Teiler einer Liste von Polynomen oder ganzen Zahlen zurück.',p:'Seq or Lst'},
    'limit':{d:'Limes eines Ausdrucks an einem Punkt (a oder +/- unendlich) (d=-1 für lim inf und +1 für lim sup).',p:'Expr,Var,Val,[Dir(d)]',a:['limite']},
    'lin':{d:'',p:'Expr',a:['lineariser']},
    'linabs':{d:'',p:'Expr,[Var]'},
    'line':{d:'line(A,B) oder line (A,slope=m) oder line(A,[1,m]) oder line (a*x+b*y+c=0) oder line(a*x+b*y+c*z+d=0,aa*x+bb*y+cc*z+dd=0) oder line(A,u)) zeichnet die Linie AB bzw. Line durch A mit Steigung m oder mit dem Richtungsvektor u oder die Lösung der Gleichung im 3D-Raum.',p:'Pnt||Cplx||Eq,[Pnt||slope||Var]'},
    'line_graph':{d:'',p:'Graph(G)'},
    'line_paper':{d:'Zeichnet das Rechteck [xmin..xmax]*[ymin..ymax] mit den Linien x=n*ux in Richtung der Achse Oxy mit dem Winkel t!=0',p:'Real(ux),Real(t),[x=xmin..xmax,y=ymin..ymax]'},
    'line_segments':{d:'Gibt die Liste der Kanten (1 Kante =Segment) des Polyeders P.',p:'Polygon or Polyedr(P)'},
    'line_width_1':{d:'Option des Befehls display für eine Linie.',p:'Opt',a:['line_width_2','line_width_3','line_width_4','line_width_5','line_width_6','line_width_7','epaisseur_ligne_1','epaisseur_ligne_2','epaisseur_ligne_3','epaisseur_ligne_4','epaisseur_ligne_5','epaisseur_ligne_6','epaisseur_ligne_7']},
    'linear_interpolate':{d:'Macht eine reguläre Stichprobe einer polygonalen Linie, die durch zwei Zeilen einer Matrix definiert wurde.',p:'Mtrx,xmin,xmax,xstep'},
    'linear_regression':{d:'Gibt die Koeffizienten a und b von y=a*x+b zurpck; Dies ist die beste Gerade, die die Punkte approximiert, deren Koordinaten durch die Zeilen von A (oder zwei Listen) gegeben wurden.',p:'Lst||Mtrx(A),[Lst]'},
    'linear_regression_plot':{d:'Gibt den Plot von y=a*x+b zurück: Die beste Gerade, die die Punkte approximiert, die durch die Zeilen von A (oder zwei Listen) gegeben wurden.',p:'Lst||Mtrx(A),[Lst]'},
    'linfnorm':{d:'',p:'Mtrx'},
    'linsolve':{d:'Löst lineare Gleichungssysteme.',p:'LstLinEq,LstVar',a:['resoudre_systeme_lineaire']},
    'linspace':{d:'linspace(a,b,n) generiert eine Liste aus n aequidistanten Elementen zwischen a und b, ohne Spezifikation n=100 (kompatibel mit scilab)',p:'Real(a),Real(b),[Int(n)]'},
    'linstep':{d:'',p:'Expr,[Var]'},
    'list':{d:'Option des convert oder convertir Befehls (n-poly=>list).',p:'Opt'},
    'list2exp':{d:'Inverse exp2list',p:'List'},
    'list2mat':{d:'Gibt die Matrix mit n Spalten zurück, deren Terme durch l gegeben wurden, eventuell durch 0 aufgefüllt.',p:'Lst(l),Intg(n)'},
    'list_edge_attributes':{d:'',p:'Graph(G),Edge(e)'},
    'list_graph_attributes':{d:'',p:'Graph(G)'},
    'list_vertex_attributes':{d:'',p:'Graph(G),Vrtx(v)'},
    'listplot':{d:'Zeichnet eine polygonale Linie durch die Punkte der Abszisse 0,…,n und Ordinate l=[y0,…,yn] oder eine Linie durch die Punkte die in M angegeben werden. Die erste Spalte gibt die Abszisse und die zweite Spalte die Ordinate an.',p:'Lst(l)||Mtrx(M)',a:['plotlist']},
    'lll':{d:'(S,A,L,O):=lll(M), Kurzbasis eines Gitters (L*O=A*M=S).',p:'Mtrx'},
    'ln':{d:'Natürlicher Logarithmus oder Option des convert bzw. convertir Befehls (id trig2exp).',p:'Expr or Opt',a:['log','LN']},
    'lname':{d:'Liste der Variablen in einem Ausdruck.',p:'Expr',a:['indets']},
    'lncollect':{d:'Fasst Logarithmen zusammen. Wendet ln(a)+n*ln(b)->ln(a*b^n) für ganze Zahlen n an.',p:'Expr'},
    'lnexpand':{d:'',p:'Expr'},
    'local':{d:'Lokale Definition einer Variable: f(x):={local (var1:=x),var2; instruction;};',a:['var']},
    'locus':{d:'locus(M,A) zeichnet den geometrischen Ort von M ( oder locus(d,A) zeichnet die Einhüllende von d), wenn A:=element(C) (C ist eine Kurve). Die Beispiele unten müssen auf einem geometrischen Niveau in verschiedene Zeilen geschrieben werden.',p:'Pnt,Elem'},
    'log10':{d:'Logarithmus mit Basis 10',p:'Expr'},
    'log2':{d:'',p:'Expr'},
    'logarithmic_regression':{d:'Gibt die Koeffizienten a und b von y=a*ln(x)+b zurück: Das ist die beste logarithmische Funktion, die die Punkte approximiert, die durch die Zeilen von A (oder zwei Listen) gegeben wurden.',p:'Lst||Mtrx(A),[Lst]'},
    'logarithmic_regression_plot':{d:'Gibt den Plot y=a*ln(x)+b zurück: Das ist die beste logarithmische Funktion, die die Punkte approximiert, die durch die Zeilen von A (oder zwei Listen) gegeben wurden.',p:'Lst||Mtrx(A),[Lst]'},
    'logb':{d:'Logarithmus mit Basis b.',p:'Real,Real'},
    'logistic':{d:'',p:'Real(x),[Real(x0),[Real(L),[Real(k)]]]'},
    'logistic_regression':{d:'Gibt y,y\',C,y\'max,xmax,R : y ist eine logistische Funktion (Lösung von y‘/y=a*y+b), sodass y(x0)=y0 und [y‘(x0),y‘(x0+1)..] die beste Approximation von L ist.',p:'Lst(L),Real(x0),Real(y0)'},
    'logistic_regression_plot':{d:'Gibt den Plot einer logistischen Funktion y wieder, sodass y(x0)=(y0) und [y‘(x0),y‘(x0+1)…] die beste Approximant von L ist.',p:'Lst(L),Real(x0),Real(y0)'},
    'lower':{d:'',p:'Mtrx||Strng'},
    'lowest_common_ancestor':{d:'',p:'Graph(T),Vrtx(r),Seq(u,v)||Lst([u1,v1],[u2,v2],...)'},
    'lowpass':{d:'',p:'Lst(s),Real(c),[Intg(samplerate)]'},
    'lp_assume':{d:'',p:'Opt',a:['lp_binary','lp_binaryvariables','lp_depthlimit','lp_integer','lp_integervariables','lp_maximize','lp_nonnegative','lp_nonnegint','lp_nodelimit','lp_method','lp_simplex','lp_interiorpoint','lp_maxcuts','lp_gaptolerance','lp_nodeselect','lp_varselect','lp_firstfractional','lp_lastfractional','lp_mostfractional','lp_pseudocost','lp_depthfirst','lp_breadthfirst','lp_bestlocalbound','lp_bestprojection','lp_hybrid','lp_iterationlimit','lp_timelimit','lp_verbose','lp_presolve','lp_heuristic','lp_nonnegint','nonnegint']},
    'lpsolve':{d:'',p:'Expr(o),[List(c)],[bounds],[options]'},
    'lsmod':{d:'Zeigt die Liste installierter dynamischen Bibliotheken an (Dynamik Libraries).',p:'NULL'},
    'lu':{d:'Für eine numerische Matrix A werden die Matrizen P Permutation, L und U zurückgegeben sodass PA=LU (P=permu2mat(p)).',p:'Mtrx'},
    'lvar':{d:'Liste der Variablen eines Objektes (mit rationaler Abhängigkeit).',p:'Expr'},
    'mRow':{d:'Multipliziert die Zeile n1 der Matrix A mit Xpr.',p:'Expr(Xpr),Mtrx(A),Intg(n1)'},
    'mRowAdd':{d:'Multipliziert die Zeile n1 der Matrix A mit Xpr und addiert sie dann auf Zeile n2.',p:'Expr(Xpr),Mtrx(A),Intg(n1),Intg(n2)'},
    'make_directed':{d:'',p:'Graph(G),[Mrtx(A)]'},
    'make_weighted':{d:'',p:'Graph(G),[Mrtx(M)]'},
    'makelist':{d:'Gibt eine Liste, erstellt durch eine Funktion oder eine Konstante, zurück.',p:'Fnc,InitVal,FinalVal,StepVal'},
    'makemat':{d:'Macht eine Matrix.',p:'Fnct(f),RowsNumb,ColsNumb'},
    'makesuite':{d:'Gibt eine Folge, die mit einem Vektor gemacht wurde, zurück.',p:'Vect||Lst'},
    'makevector':{d:'Gibt einen Vektor zurück, der mit einer Folge gemacht wurde.',p:'Seq'},
    'map':{d:'Wendet die Funktion f auf die Elemente der Liste l oder ein Polynom im internen Format an.',p:'Lst(l),Fnc(f)'},
    'maple2mupad':{d:'maple2mupad("file1","file2") übersetzt file1(Maple) nach file2(MuPAD).',p:'Str("Name_Maplefile"),Str("Name_Mupadfile")'},
    'maple2xcas':{d:'maple2mupad("file1","file2") übersetzt file1(Maple) nach file2(Xcas).',p:'Str("NameMapleFile"),Str("NameXcasFile")'},
    'maple_ifactors':{d:'Gibt 1 oder -1 für das Vorzeichen und die Primfaktoren der Zahl n zurück (mit ihren Multiplizitäten), in Form einer Matrix. So wie ifactors in Maple.',p:'Intg(n)'},
    'markov':{d:'Berechnung der Eigenvektoren und Eigenwerte einer Markov-Ketten Übergangsmartrix M, die Liste der korrespondierenden invarianten Wahrscheinlichkeiten, die Liste anderer stark verbundener Komponenten, die Liste der Wahrscheinlichkeiten, die in der Folge positiver Rekurrenz enden.',p:'Mtrx(M),[Real(eps)]'},
    'mat2list':{d:'Gibt die Liste der Terme einer Matrix zurück.',p:'Mtrx'},
    'mathml':{d:'Wandelt den Ausdruck in einen String um, sodass die Mathematik im Netz angezeigt werden kann.',p:'Expr'},
    'matpow':{d:'Berechnet die n-te Potenz einer Matrix, indem die Jordannormalform verwendet wird.',p:'Mtrx,Intg(n)'},
    'matrix':{d:'Macht eine Matrix m(j,k) mit p Zeilen und q Spalten, m(j,k)=f(j,k) oder m(j,k)=a: Der Index beginnt mit 0 oder 1 abhängig vom Modus (Xcas oder Maple) (oder Option von apply). Alternativ kann eine Matrix von einer Tabelle aus gemacht werden.',p:'Intg(p),Intg(q),(Fnc(f) or Val(a))'},
    'matrix_norm':{d:'Matrixnorm induziert von der Norm von l1, l2 oder l\'unendlich',p:'Mtrx,[2]||[inf]'},
    'max':{d:'Maximum der Elemente einer Liste oder Folge von reellen Zahlen.',p:'Seq||Lst'},
    'maxflow':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)'},
    'maximal_independent_set':{d:'',p:'Graph(G)'},
    'maximize':{d:'',p:'Expr,[Constr],Vars,[Options]'},
    'maximum_clique':{d:'',p:'Graph(G)'},
    'maximum_degree':{d:'',p:'Graph(G)'},
    'maximum_independent_set':{d:'',p:'Graph(G)'},
    'maximum_matching':{d:'',p:'Graph(G)'},
    'maxnorm':{d:'Maximumsnorm eines Vektors oder einer Matrix: maxnorm([x1,x2,..,xn])=max(|x1|,..,|xn|).',p:'Vect or Mtrx'},
    'mean':{d:'',p:'Lst||Mtrx,[Lst]',a:['moyenne']},
    'median':{d:'Median einer Liste. Das zweite Argument ist die Gewichtung. Alternativ kann auch der Median der Spalten einer Matrix berechnet werden.',p:'Lst||Mtrx,[Lst]'},
    'median_line':{d:'median_line(A,B,C) zeichnet die Seitenhalbierende durch A des Dreiecks ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'member':{d:'Testet ob e in der Liste oder in der Menge l ist (=0 oder k+1 mit l[k]=e).',p:'Elem(e),(Lst(l) or Set(l))'},
    'mgf':{d:'Gibt die momenterzeugende Funktion einer Wahrscheinlichkeitsverteilung einer Normal-, Binomial-, Poisson-, Beta- oder Gammaverteilung zurück.',p:'Func,[Real(Param_1),Real(Param_2)]'},
    'mid':{d:'Gibt die Liste zurück, die sich ergibt, wenn man aus l n Elemente nimmt (standardmäßig n=size(l)-d) und am Index d beginnt).',p:'Lst(l) or Str(l),Intg(d),Intg(n)'},
    'midpoint':{d:'midpoint(A,B) zeichnet den Mittelpunk des Abschnitts AB.',p:'(Pnt or Cplx),(Pnt or Cplx)'},
    'min':{d:'Minimum der Elemente einer Folge oder einer Liste von reellen Zahlen.',p:'Seq||Lst'},
    'minimal_edge_coloring':{d:'',p:'Graph(G),[sto]'},
    'minimal_spanning_tree':{d:'',p:'Graph(G)'},
    'minimal_vertex_coloring':{d:'',p:'Graph(G),[sto]'},
    'minimax':{d:'',p:'Expr,Var=Real(a)..Real(b),Intg(n)||Lst(Intg(n),Intg(m)),[opts]'},
    'minimize':{d:'',p:'Expr,[Constr],Vars,[Options]'},
    'minimum_cut':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)'},
    'minimum_degree':{d:'',p:'Graph(G)'},
    'minimum_vertex_cover':{d:'',p:'Graph(G),[approx]'},
    'minus':{d:'Infix-Operator, der benutzt wird, um die Differenz zwischen zwei Mengen zu erhalten.',p:'(Vect or Set),(Vect or Set)'},
    'mixdown':{d:'',p:'Audio(clip1),(Real||Lst)(parm1),Audio(clip2),(Real||Lst)(parm2),...'},
    'mkisom':{d:'Matrix einer Isometrie gegeben durch seine Eigenelemente (Eigenvektoren und Eigenwerte)',p:'Vect,(Sign(1) or -1)'},
    'mksa':{d:'Wandelt Einheiten in die Einheiten des Internationalen MKSA-Systems um',p:'Unit'},
    'mod':{d:'Infix-Operator, der n mod p zurückgibt eine Nummer aus N/pN',p:'Intg(n),Intg(p)',a:['%']},
    'modf':{d:'',p:'Real(a)'},
    'modgcd':{d:'Größter gemeinsamer Nenner von 2 Polynomen mit dem modularen Algorithmus.',p:'Poly,Poly'},
    'monotonic':{d:''},
    'montre_tortue':{d:'Zeigt die Schildkröte.',p:'NULL'},
    'moving_average':{d:'',p:'Lst(A),Intg(n)'},
    'moyal':{d:'Moyal-Produkt zweier Symbole.',p:'Expr,Expr,VectVar'},
    'mult_c_conjugate':{d:'Gibt den Ausdruck zurück, nachdem sie mit dem komplex konjugierten des Nenners multipliziert wurde. (oder des Zählers, wenn es keinen Nenner gibt)',p:'Expr',a:['multiplier_conjugue_complexe']},
    'mult_conjugate':{d:'5 Gibt den Ausdruck zurück, nachdem sie mit dem konjugierten des Nenners multipliziert wurde. (oder des Zählers, wenn es keinen Nenner gibt)',p:'Expr',a:['multiplier_conjugue']},
    'multinomial':{d:'Gibt n!/(k0!*k1!*..;kj!)*(p0^k0*p1^k1..*pj^kj) zurück (sum(p)=1 und sum(k)=n).',p:'Intg(n),Vect(p),Vect(k)'},
    'multiply':{d:'Gibt das Produkt von 2 Argumenten zurück.',p:'Intg or Lst, Intg or Lst'},
    'mupad2maple':{d:'maple2mupad("file1","file2") übersetzt file1(Mupad) nach file2(Maple).',p:'Str("NameMupadFile"),Str("NameMapleFile")'},
    'mupad2xcas':{d:'',p:'Str("NameMupadFile"),Str("NameXcasFile")'},
    'mycielski':{d:'',p:'Graph(G)'},
    'nDeriv':{d:'Gibt eine Näherung für den Wert der Ableitung an einem Punkt:(Xpr(var+h)-Xpr(var-h))/(2*h) (ohne Spezifikation h=0.001).',p:'Expr(Xpr),Var(Var),[Real(h)]'},
    'nSolve':{d:'Numerische Lösung einer Gleichung oder eines Systems von Gleichungen.',p:'Expr,Var,[Guess or Interval],[Method]'},
    'negbinomial':{d:'Gibt comb(n+k-1,k)*p^k*(1-p)^n zurück.',p:'Intg(n),Intg(k),Real(p in 0..1)'},
    'negbinomial_cdf':{d:'',p:'Intg(n),Real(p),Real(x),[Real(y)]'},
    'negbinomial_icdf':{d:'Gibt h zurück, sodass Proba(X<=h)=t, wenn X der negbinomial(n,p)-Verteilung (negative Binomialverteilung) folgt.',p:'Intg(n),Real(p),Real(t)'},
    'neighbors':{d:'',p:'Graph(G),[Vrtx(v)]'},
    'network_transitivity':{d:'',p:'Graph(G)'},
    'neural_network':{d:'',p:'Vect(topology)||NeuralNet(net),[opts]'},
    'newList':{d:'Gibt eine Liste mit n Nullen zurück.',p:'Intg(n)'},
    'newMat':{d:'Gibt die Liste mit n Zeilen und p Spalten zurück, voll mit Nullen.',p:'Intg(n),Intg(p)'},
    'newton':{d:'newton(f(x),x,a,p)= eine Nullstelle von f(x) mit dem Newton-Verfahren beginnend mit a und p Iterationen (standardmäßig p=20).',p:'Expr(f(x)),Var(x),[ApproxVal(a),NumIter(p)]'},
    'nextperm':{d:'Gibt die nächste Permutation in lexikographischer Reihenfolge zurück.',p:'Intg(n)'},
    'nextprime':{d:'Nächste Primzahl oder Pseudo-Primzahl nach einer gegeben ganzen Zahl.',p:'Intg(a)'},
    'nlp_initialpoint':{d:'',p:'Opt',a:['nlp_iterationlimit','nlp_nonnegative','nlp_precision','nlp_maximize','nlp_presolve','nlp_method','nlp_integervariables','nlp_integer','nlp_binaryvariables','nlp_binary','nlp_tolerance','nlp_verbose','nlp_nonnegint']},
    'nlpsolve':{d:'',p:'Expr(objective),[Lst(constr)],[Seq(bd)],[Seq(opts)]'},
    'nodisp':{d:'Zeigt Done anstatt eines Wertes an.',p:'Expr'},
    'non_recursive_normal':{d:'Vereinfacht die Ausdrücke, aber ohne dabei im Ergebnis nicht-rationale Ausdrücke zu verwenden.',p:'Expr'},
    'nop':{d:'Befehl nichts zu tun.',p:'NULL'},
    'norm':{d:'Gibt die l2-Norm eines Vektors zurück = sqrt(x1^2+x2^2+...xn^2) oder die Matrix-Norm, die durch die l2 Norm induziert wird.',p:'Vect or Mtrx',a:['l2norm']},
    'normal':{d:'Vereinfacht den Ausdruck',p:'Expr',a:['evala']},
    'normal_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Normalverteilte Zufallsvariable kleiner als x0 oder zwischen x0 und y0 ist. (my ist das Mittel und sigma ist die Standardabweichung).',p:'Real(mu),Real(sigma),Real(x0),[Real(y0)]',a:['normald_cdf']},
    'normal_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine normalverteilte Zufallsvariable kleiner als h ist, p ist (my ist das Mittel und sigma die Standardabweichung und 0<=p<=1).',p:'Real(mu),Real(sigma),Real(p)',a:['normald_icdf']},
    'normald':{d:'Gibt die Wahrscheinlichkeitsdichte der Normalverteilung zurück (my ist das Mittel und sigma die Standardabweichung).',p:'Real(mu),Real(sigma),Real(x0)',a:['NORMALD']},
    'normalize':{d:'Gbt den Vektor geteilt durch seine l2-Norm zurück. Es ist zudem eine Option für plotfield.',p:'Lst||Cplx||Audio',a:['unitV']},
    'normalt':{d:'Z-Test/Normalverteilung: arg1=[Treffe,Versuch] oder [Mittel, Stichprobengröße] oder Daten. Arg2=Proportion oder Mittel der Vorkommnisse oder Daten, arg 3 optional, wenn Daten=sigma sind, arg4 alternativ \'!=\' oder \'>\' oder \'<\', arg5 optional Konfidenzniveau (statistische Sicherheit).',p:'Lst,Real,[Real],Fnc,[Real]'},
    'not':{d:'Gibt die logische Inverse des Arguments zurück.',p:'Boolean',a:['non']},
    'nprimes':{d:'Zählt die Anzahl von Primzahlen kleiner als n.',p:'Intg(n)'},
    'number_of_edges':{d:'',p:'Graph(G)'},
    'number_of_spanning_trees':{d:'',p:'Graph(G)'},
    'number_of_triangles':{d:'',p:'Graph(G)'},
    'number_of_vertices':{d:'',p:'Graph(G)'},
    'numdiff':{d:'',p:'Lst(X),Lst(Y),Real(x0),[Intg(n)]'},
    'numer':{d:'Gibt den Zähler des vereinfachten Bruches zurück.',p:'Frac(a/b) or RatFrac'},
    'octahedron':{d:'Zeichnet einen Oktaeder mit Zentrum A, Vertex B und so, dass die Ebene ABC 4 Vertices enthält.',p:'Pnt(A),Pnt(B),Pnt(C)'},
    'odd':{d:'Gibt für ungerade Zahlen 1 und für gerade Zahlen 0 zurück.',p:'Intg(n)'},
    'odd_girth':{d:'',p:'Graph(G)'},
    'odd_graph':{d:'',p:'Intg(n)'},
    'odesolve':{d:'odesolve(f(t,y),[t,y],[t0,y0],t1)=odesolve(t0..t1,f,y0)=y(t1) für y approximiert die Lösung von y\'=f(t,y) und y(t0)=y0 mit y=Vektor des Systems.',p:'Expr,VectVar,VectInitCond,FinalVal,[tstep=Val,curve]'},
    'of':{d:'Gibt den Wert: f(a) zurück.',p:'Fnc(f),Real(a)'},
    'open':{d:'Öffnet eine Datei mit dem Namen s, gibt den Dateihandle zurück.',p:'Str(s)'},
    'open_polygon':{d:'Zeichnet und gibt zurück den Polygonzug, dessen Vertices die Elemente von l sind.',p:'LstPnt||LstCplx'},
    'option':{d:'Reserviertes Wort für Kompatibilität.'},
    'or':{d:'boolescher infix-Operator (oder).',p:'Expr, Expr',a:['||','ou']},
    'ord':{d:'Gibt den ACII-Code eines Zeichens oder des ersten Zeichens eines Strings zurück.',p:'Char||LstChar'},
    'order':{d:'',p:'g'},
    'order_size':{d:'Rest (Term im Landau-Symbol) einer Reihenentwicklung limit(x^a*order_size(x),x=0)=0, wenn a>0.',p:'Expr'},
    'ordinate':{d:'Gibt die Ordinate eines Punktes oder Vektors zurück.',p:'Pnt or Vect'},
    'orthocenter':{d:'Zeigt den Höhenschnittpunkt (Orthozentrum) eines Dreiecks oder eines Dreiecks, gemacht mit 3 Punkten.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'orthogonal':{d:'orthogonal(A,line(B,C)) zeichnet die orthogonale Ebene von BC durch den Punkt A und orthogonal(A,plane(B,C,D)) zeichnet die Orthogonale Linie von plan(B,C,D) durch A.',p:'(Pnt),(Line or Plan)'},
    'osculating_circle':{d:'Krümmungskreis am Punkt M der Kurve C.',p:'Curve,Point'},
    'output':{d:'Instruktion in einem Programm, sodass man einen in var gespeicherten Ausdruck ausgeben kann.',p:'[Str],Var(Var)',a:['Output']},
    'p1oc2':{d:'Gibt das Produkt der Permutationen von p1 und c2 zurück.',p:'Permut,Cycle'},
    'p1op2':{d:'Gibt die Permutation Produkt aus p1 und p2 zurück.',p:'Permut,Permut'},
    'pa2b2':{d:'Gibt [a,b] zurück, sodass a^2+b^2=n (für n Primzahl und n=1 (mod4)).',p:'Intg(n)'},
    'pade':{d:'Pade-Approximation P/Q=Xpr mod x^(n+1) oder mod N mit Grad von (P)<p.',p:'Expr(Xpr), Var(x), (Intg(n) || Poly(N)), Intg(p)'},
    'paley_graph':{d:'',p:'Intg(p),[Intg(k)]'},
    'parabola':{d:'parabola(F,A)=Brennpunkt F, Scheitelpunkt A (in der Ebene ABP) oder (parabola(A,c) für die Gleichung y=yA+c*(x-xA)^2 c=1/(2*p) und FA=p/2 geo2d) und parabola(P(x,y)) zeichnet den Kegelschnitt, wenn deg(P)=2.',p:'Pnt(F)||Pnt(xA+i*yA),Pnt(A)||Real(c),[Pnt(P)]'},
    'parallel':{d:'parallel(A,D) (bzw. parallel(A,P) oder parallel(A,D,DD)) zeichnet die Gerade (bzw Ebene) durch a parallel zur Gerade D (bzw parallel zur Ebene P oder den Geraden D,DD). parallel(d,D) zeichnet die Ebene durch d parallel zur Gerade D.',p:'Pnt or Line,Line or Plan,[Line]'},
    'parallelepiped':{d:'Zeichnet ein Parallelepiped mit den Seiten AB,AC,AD (die Seiten sind Parallelogramme).',p:'Pnt(A),Pnt(B),Pnt(C),Pnt(D)'},
    'parallelogram':{d:'Zeichnet und gibt das Parallelogramm ABCD wieder, sowie Vektor(AB)+Vektor(AD)=Vektor(AC).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Pnt(C)||Cplx,[Var(D)]'},
    'parameq':{d:'parameq(C) gibt die komplexe Zahl= Parametergleichung der Kurve C zurück.',p:'GeoObj'},
    'parameter':{d:'Reserviertes Wort.'},
    'parfrac':{d:'Option des convert oder convertir Befehls (id bei der Option partfrac).',p:'Opt',a:['fullparfrac']},
    'pari':{d:'Führt einen PARI/GP Befehl aus oder exportiert alle PARI/GP Befehle.',p:'Str,arguments'},
    'part':{d:'Gibt den n-ten Sub-Ausdruck des Ausdrucks an.',p:'Expr, Intg(n)'},
    'partfrac':{d:'Führt Partialbruchzerlegung eines Bruches durch. Kann als Option des convert bzw convertir Befehls genutzt werden (id bei der Option parfrac).',p:'RatFrac or Opt'},
    'parzen_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'pas_de_cote':{d:'Die Schildkröte mache n Schritte nach links (-n Schritte nach rechts, wenn n negativ) ohne Spur (ohne Spezifikation n=10).',p:'NULL or Real(n)'},
    'path_graph':{d:'',p:'Intg(n)||Lst(V)'},
    'pcar':{d:'Liste der Koeffizienten des charakteristischen Polynoms einer Matrix oder des charakteristischen Polynoms einer Matrix mit dem Argument als zweiter Variable.',p:'Mtrx,[Var]',a:['charpoly']},
    'pcar_hessenberg':{d:'Charakteristisches Polynom einer Matrix mit dem Hessenberg-Verfahren (wenn die Koeffizienten in einem endlichen Körper sind.',p:'Mtrx,[Var]'},
    'pcoeff':{d:'Gibt die Koeffizienten des Polynoms zurück, dessen Nullstellen im Argument spezifiziert wurden.',p:'Vect',a:['pcoef']},
    'perimeter':{d:'Umfang eines Polygons (z.B. Dreieck, Quadrat,..)',p:'Polygone'},
    'perimeterat':{d:'Zeigt am Punkt (z0) mit einer Legende den Umfang eines Kreises oder eines Polygons (z.B. Dreieck, Quadrat,..) an.',p:'Polygone, Pnt||Cplx(z0)'},
    'perimeteratraw':{d:'Zeigt am Punkt (z0) den Umfang eines Kreises oder eines Polygons (z.B. Dreieck, Quadrat,..) an.',p:'Polygone, Pnt||Cplx(z0)'},
    'period':{d:'',p:'Expr,[Var]'},
    'periodic':{d:'',p:'Expr,Var,Real(a),Real(b)||Expr,Var=a..b'},
    'perm':{d:'perm(n,p)= Anzahl der Anordnungen von p Objekten aus n : n!/(n-p)!',p:'Intg(n),Intg(p)',a:['nPr']},
    'perminv':{d:'Gibt die inverse Permutation der Permutation a zurück.',p:'Permut(a)'},
    'permu2cycles':{d:'Wandelt eine Permutation in ein Produkt disjunkter Zirkel um.',p:'Permut'},
    'permu2mat':{d:'Gibt die Matrix zurück, bei der die die Zeilen der Einheitsmatrix mit der Permutation p permutiert wurden.',p:'Permut(p)'},
    'permuorder':{d:'Gibt die Ordnung der Permutation a zurück.',p:'Permut(a)'},
    'permute_vertices':{d:'',p:'Graph(G),Lst(V)'},
    'perpen_bisector':{d:'perpen_bisector(A,B) zeichnet die Bisektion (Gerade oder Ebene) des Abschnitts AB.',p:'(Pnt or Cplx),(Pnt or Cplx)'},
    'perpendicular':{d:'perpendicular(A,line(B,C)) oder perpendicular(A,B,C) zeichnet das Lot von A auf Gerade BC und perpendicular(d,plane(B,C,D)) zeichnet die orthogonale Ebene von der Ebene (B,C,D) durch die Gerade d.',p:'(Pnt or Line),(Line or Plan)'},
    'petersen_graph':{d:'',p:'Intg(n),[Intg(k)]'},
    'peval':{d:'Wertet ein Polynom, dass durch seine Koeffizienten gegeben wurde am Punkt x0 aus.',p:'Vect,Real(x0)',a:['polyEval']},
    'pi':{d:'Die Zahl Pi',a:['Pi']},
    'piecewise':{d:'Wenn Cond1 gebe Expr1 zurück sonst.. wenn Cond2p gebe Expr2p zurück sonst gebe Expr2p+1 zurück.',p:'Cond1,Expr1,..,Cond2p,Expr2p,[Expr2p+1]'},
    'pivot':{d:'Gibt die Matrix zurück, die man von A erhält, wenn Nullen in der Spalte nc sind, die man mit der Gauß-Jordan Methode kreiert (mit dem Element A[nl,nc] als Pivotelement).',p:'Mtrx(A),Intg(nl),Intg(nc)'},
    'pixoff':{d:'Pixel off',p:'Real(x),Real(y)'},
    'pixon':{d:'Pixel an',p:'Real(x),Real(y)'},
    'planar':{d:'',p:'Opt'},
    'plane':{d:'plane(A,B,C) oder plane (A,line(B,C)) (respektive plane(a*x+b*y+c*z+d=0)) zeichnet die Ebene ABC (respektive die Lösung von a*x+b*y+c*z+d=0) im 3D-Raum.',p:'Pnt or Eq, [Pnt or Line],[Pnt]'},
    'plane_dual':{d:'',p:'Graph(G)||Lst(F)'},
    'playsnd':{d:'Spielt Sound-Daten ab.',p:'Vect'},
    'plex':{d:'Option des "gbasis" oder "greduce" Befehls, um die Ordnung für Monome zu spezifizieren (Voreingestellt ist eine lexikographische Sortierung).',p:'Opt'},
    'plot':{d:'Plottet einen Ausdruck mit einer Variablen (oder einer Liste von Ausdrücken).',p:'(Expr or LstExpr),Var[=VarMin..VarMax],[color=LstColor]',a:['graphe']},
    'plot3d':{d:'Lösche und plotte einen Ausdruck mit zwei Variablen oder eine Oberfläche, definiert mit einer Liste von drei Funktionen oder von drei Ausdrücken mit zwei Variablen.',p:'Expr||Lst(3*Expr),Var,Var',a:['graphe3d']},
    'plotarea':{d:'Zeige die Fläche unter einer Kurve an, optional mit einer Quadraturmethode (trapezoid, left_rectangle (=linksbündiges Rechteck), right_rectangle (=rechtbündiges Rechteck), middle_point (=Mittelpinkt)).',p:'Expr,x=a..b,[n],[Method]',a:['areaplot']},
    'plotcdf':{d:'Graphische Repräsentation einer kumulierten Verteilungsfunktion.',p:'Func,FuncParams'},
    'plotcontour':{d:'Zeichnet entweder 11 gleich verteilte Konturlinien z=z_min,…,z=z_max der Oberfläche z=Ausdruck oder die Konturlinien definiert durch das dritte Argument.',p:'Expr(Xpr),[LstVar],[LstVal]',a:['contourplot','DrwCtour']},
    'plotdensity':{d:'Zeigt in der Ebene mit Farben den Graphen eines Ausdrucks mit zwei Variablen an.',p:'Expr,[x=xrange,y=yrange],[z],[xstep],[ystep]',a:['densityplot']},
    'plotfield':{d:'fieldplot(f(t,y),[t,y]) zeichnet das Feld der Tangenten (normalisiert oder nicht kann mit der Option entschieden werden) der Differentialgleichung y\'=f(t,y).',p:'Expr,VectVar,[Opt]',a:['fieldplot']},
    'plotfunc':{d:'Plottet einen Ausdruck mit einer oder zwei Variablen mit Superposition.',p:'Expr,[Var(x) or VectVar] ,[Intg(color)]',a:['funcplot','DrawFunc','Graph']},
    'plotimplicit':{d:'plotimplicit(f(x,y),x,y) oder plotimplicit(f(x,y),[x,y]) Graph von f(x,y)=0.',p:'Expr,Var1,Var2',a:['implicitplot']},
    'plotinequation':{d:'Zeigt den Graphen der Lösung von Ungleichungen mit 2 Variablen an.',p:'Expr,[x=xrange,y=yrange],[xstep],[ystep]',a:['inequationplot']},
    'plotode':{d:'odeplot(f(t,y),[t,y],[t0,y0]) zeichnet die Lösung von y\'=f(t,y) und y(t0)=y0 oder des Systems [x\'=g(t,x,y),y\'=h(t,x,y)] mit x(t0)=x0 und y(t0)=y0.',p:'Expr,VectVar,VectInitCond',a:['odeplot']},
    'plotparam':{d:'plotparam(a(x)+i*b(x),x=x0..x1) zeichnet die Kurve X=a(x), Y=b(x) x=x0..x1 oder plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) zeichnet die Oberfläche X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 und v=v0..v1.',p:'Cplx||Lst,Var||Lst(Var)',a:['paramplot','DrawParm','courbe_parametrique']},
    'plotpolar':{d:'plotpolar(f(x),x,a,b) zeichnet die Polarkurve r=f(x) für x in [a,b].',p:'Expr,Var,VarMin,VarMax',a:['polarplot','DrawPol','courbe_polaire']},
    'plotproba':{d:'Graph der Übergangsmatrix mit 7 mal 7 Einträgen (optional mit Liste der Vertex-Positionen).',p:'Matrix,[Vector]'},
    'plotseq':{d:'Erlaubt die ersten p Terme der Folge u(0)=a, u(n))=f(u(n-1)) anzuzeigen.',p:'Expr(f(Var)),Var=[a,xm,xM],Intg(p)',a:['seqplot','graphe_suite']},
    'plotspectrum':{d:'',p:'Audio(clip),[range=a..b]'},
    'plotwav':{d:'',p:'Audio(clip),[range=a..b]'},
    'pmin':{d:'Gibt das Minimal Polynom der Matrix A oder das Minimalpolynom der algebraischen Zahl zurück.',p:'Mtrx(A)||Real(a),[Var]'},
    'point':{d:'A:=point(za) oder A:=point(a,b) (respektive A:=point([a,b,c])) zeichnet einen Punkt oder den Affix-Punkt za=a+ib (respektive mit den Koordinaten (a,b,c)) mit Bezeichnung A.',p:'Cplx(za)||Vect'},
    'point2d':{d:'Definiert zufällig die Koordinaten (zwischen -5 und 5) der als Argument gegebenen 2dPunkte.',p:'SeqVar(A,B,C...)'},
    'point3d':{d:'Definiert zufällig die Koordinaten (zwischen -5 und 5) der als Argument gegebenen 3dPunkte.',p:'SeqVar(A,B,C...)'},
    'point_width_1':{d:'Option des Befehls display für einen Punkt.',p:'Opt',a:['point_width_2','point_width_3','point_width_4','point_width_5','point_width_6','point_width_7','epaisseur_point_1','epaisseur_point_2','epaisseur_point_3','epaisseur_point_4','epaisseur_point_5','epaisseur_point_6','epaisseur_point_7']},
    'poisson':{d:'Gibt exp(-mu)*mu^k/k! Zurück.',p:'Real(mu),Intg(k)'},
    'poisson_cdf':{d:'Gibt Proba(X<=x) zurück, wenn X der Poissonverteilung folgt, mit myals Median.',p:'Real(mu),Real(x)'},
    'poisson_icdf':{d:'',p:'Real(mu),Real(p)'},
    'poisson_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'polar':{d:'Gibt die Gerade der konjugierten Punkte von A bezüglich des Kreises zurück',p:'Crcle,Pnt or Cplxe(A)'},
    'polar_coordinates':{d:'Gibt die Liste der Beträge und Polarwinkel eines Punktes in „D oder einer komplexen Zahl zurück, wobei der Punkt als Liste kartesischen Koordinaten angegeben wird.',p:'Pnt or Cplx or LstRectCoord'},
    'polar_point':{d:'Gibt den Punkt (in 2D) mit den Argumenten r und t als Polarkoordinaten zurück (z.B. als r*exp(i*t))',p:'Real(r),Real(t)'},
    'pole':{d:'Gibt den Punkt zurück, der die Gerade als Polare bezüglich des Kreises hat.',p:'Crcle,Line'},
    'poly2symb':{d:'Gibt das Polynom (oder seinen Wert): Das erste Argument ist ein Vektor aus Koeffizienten und das zweite Argument ist die Variable (Standardmäßig x).',p:'Lst,Var',a:['r2e']},
    'polygon':{d:'Zeichnet und gibt zurück das Polygon (Vieleck) dessen Vertices die Elemente von l sind.',p:'LstPnt||LstCplx'},
    'polygone_rempli':{d:'Das Argument ist eine ganze Zahl ?1, die die Anzahl der letzten Positionen der Schildkröte angibt, mit denen ein Polygon gezeichnet werden soll. Dieses Polygon wir dann ausgefüllt.',p:'Intg(n)'},
    'polygonplot':{d:'Zeichnet das Polygon, dass für j fixiert und für k=0..nrows die Punkte (xk,yk) zusammenführt, wobei xk = Element Zeile k, Spalte 0 und yk= Element Zeile k Spalte j, wenn die xk sortiert sind. (Wir erhalten ncols-1 Polygone)',p:'Mtrx',a:['ligne_polygonale']},
    'polygonscatterplot':{d:'Zeichnet die Punkte (xk,yk) und zeichnet das Polygon, dass für j fixiert und für k=0..nrows die Punkte (xk,yk) zusammenführt, wobei xk = Element Zeile k, Spalte 0 und yk= Element Zeile k Spalte j, wenn die xk sortiert sind. (Wir erhalten ncols-1 Polygone)',p:'Mtrx',a:['ligne_polygonale_pointee']},
    'polyhedron':{d:'Zeichnet einen konvexen Polyeder, wobei die Argumente unter den Vertices sind.',p:'SeqPnt(A,B,C...)'},
    'polynom':{d:'Option des convert oder convertir Befehls und der Befehle taylor und series (list=>n-poly oder series=>poly).',p:'Opt'},
    'polynomial_regression':{d:'Gibt die Koeffizienten (an,…,a1,a0) von y=an*x^n+..a1x+a0) zurück: Das ist die beste polynomiale Funktion, die die Punkte approximiert, die durch die Zeilen von A (oder zwei Listen) gegeben wurden (n ist das zweite Argument).',p:'Lst||Mtrx(A),[Lst],Intg(n)'},
    'polynomial_regression_plot':{d:'Gibt den Plot von y=an*x^n+..a1x+a0) zurück: Das ist die beste polynomiale Funktion, die die Punkte approximiert, die durch die Zeilen von A (oder zwei Listen) gegeben wurden (n ist das zweite Argument).',p:'Lst||Mtrx(A),[Lst],Intg(n)'},
    'position':{d:'Gibt die Position der Schildkröte in Pixel an oder setzt die Schildkröte an die Position der Argumente und behält dabei die Orientierung bei.',p:'NULL or LstCoord'},
    'poslbdLMQ':{d:'Gibt eine untere Schranke für die Werte der positiven Wurzeln von P zurück. Die Akritas-Strzebonski-Vigklas\' Local Max Quadratic (LMQ) Methode wird verwendet.',p:'Poly(P)'},
    'posubLMQ':{d:'Gibt eine obere Schranke für die Werte der positiven Wurzeln von P zurück. Die Akritas-Strzebonski-Vigklas\' Local Max Quadratic (LMQ) Methode wird verwendet.',p:'Poly(P)'},
    'potential':{d:'Gibt U zurück sodass gradient(U)=derive(U,Vector_of_variable)=V.',p:'Vect(V),VectVar'},
    'pour':{d:'For-Schleife (pour...de...jusque...[pas…] faire...fpour;) Übersetzt:(Für...von ...bis...[Schritt...]mache...Ende für;)'},
    'pow':{d:'Berechnet a^n(schneller Algorithmus)',p:'Intg(a),Intg(n)'},
    'pow2exp':{d:'Schreibt einen Exponenten in eine Exponentialfunktion um.',p:'Expr'},
    'power_regression':{d:'Gibt die Koeffizienten (m,b) von y=b*x^m zurück: Es ist das beste Monom, welche die Punkte approximiert, die durch die Zeilen von A gegeben wurden (oder zwei Listen).',p:'Lst|Mtrx(A),[Lst]'},
    'power_regression_plot':{d:'Gibt den Plot von y=b*x^m zurück: Es ist das beste Monom, welche die Punkte approximiert, die durch die Zeilen von A gegeben wurden (oder zwei Listen).',p:'Lst||Mtrx(A),[Lst]'},
    'powerpc':{d:'Gibt die reelle Zahl d^2-R^2 (d=Abstand zwischen Punkt und Mittelpunk, R=Radius) wieder.',p:'Cercle,Pnt or Cplx'},
    'powexpand':{d:'Entwickelt den Ausdruck als Funktion des Exponenten.',p:'Expr'},
    'powmod':{d:'Berechnet a^n modulo p, modulo p,P(x) (schneller Algorithmus).',p:'Intg(a),Intg(n),Intg(p),[Expr(P(x))],[Var]',a:['powermod']},
    'prepend':{d:'Setzt das Element an den Anfang einer Liste.',p:'Lst||Set||Str(L),Elem(n)'},
    'preval':{d:'Gibt F(b)-F(a) zurück.',p:'Expr(F(Var)),Real(a),Real(b),[Var]'},
    'prevperm':{d:'Gibt die vorherige Permutation in lexikographischer Reihenfolge zurück.',p:'Intg(n)'},
    'prevprime':{d:'Vorherige Primzahl oder Pseudo-Primzahl vor einer gegebenen ganzen Zahl a.',p:'Intg(a)'},
    'primpart':{d:'Gibt das Polynom P dividiert durch den größten gemeinsamen Teiler seine Koeffizienten zurück.',p:'Poly(P),[Var]'},
    'print':{d:'Zeigt an(Print) ein Ergebnis in einem Programm',p:'Expr|| Str',a:['Disp']},
    'printf':{d:'',p:'Expr'},
    'prism':{d:'Zeichnet ein Prisma mit der Basisebene ABCD...und mit Kanten parallel zu AA1 (die Seiten sind Parallelogramme).',p:'LstPnt([A,B,C,D]),Pnt(A1)'},
    'prism_graph':{d:'',p:'Intg(n)'},
    'proc':{d:'Beginnt eine Prozedur (wie mit MuPAD).'},
    'product':{d:'Multipliziert den Wert des Ausdrucks, wenn die Variable von a zu b, mit dem Schritt p geht(product(expression,var,begin,end,step). Ohne Spezifikation p=1 Alternativ Produkte der Elemente einer Liste oder Produkte von Term zu Term der Elemente von zwei Listen oder Matrizen.',p:'Expr||Lst,[Var||Lst],[Intg(a)],[Intg(b)],[Intg(p)]',a:['mul']},
    'program':{d:'reserviertes Wort.'},
    'projection':{d:'projection(C,A) ist die orthogonale Projektion von A auf der Kurve C.',p:'Curve,Pnt'},
    'proot':{d:'Gibt alle berechneten Nullstellen eines Polynoms, dass durch seine Koeffizienten gegeben wurde, zurück (funktioniert nicht, wenn Nullstellen nicht einfach sind).',p:'Vect||Poly,[Intg(n)]'},
    'propfrac':{d:'Vereinfacht und schreibt den Bruch (oder den rationalen Bruch) A/B als Q+R/B mit R<B (oder deg(R)<deg(B)).',p:'Frac or RatFrac',a:['propFrac']},
    'pruefer_code':{d:'',p:'Vect(S)|Graph(T)'},
    'psrgcd':{d:'Größter gemeinsamer Nenner von 2 Polynomen mit dem Unterresultat-Algorithmus.',p:'Poly,Poly'},
    'ptayl':{d:'Gibt das Taylor-Polynom des Ausdrucks an einem gegebenen Punkt und Ordnung oder das Polynom Q sodass P(x)=Q(x-a).',p:'Expr||Poly(P(Var)),Var=Real || Real(a),[Order || Var]'},
    'purge':{d:'purge(varname) Stellt die Variable mit Namen varname frei.',p:'Var',a:['DelVar','del']},
    'pwd':{d:'Aktuelle Richtung der Arbeit.',p:'NULL'},
    'pyramid':{d:'Zeichnet eine reguläre Pyramide ABCD mit Vertices A,B in der Fläche (A,B,C), wenn es drei Argumente gibt und die Pyramide ABCD bei 4 Argumenten.',p:'Pnt(A),Pnt(B),Pnt(C),[Pnt(D)]',a:['tetrahedron']},
    'python_compat':{d:'',p:'Intg(0) or 1'},
    'q2a':{d:'q2a(q(x,y),[x,y])=symmetrische Matrix assoziiert mit der quadratischen Form q.',p:'QuadraForm, VectVar'},
    'qr':{d:'Für eine numerische Matrix A, wird R(right (rechts)) und Q(orthogonal) zurückgegeben, sodass A=QR.',p:'Mtrx'},
    'quadrant1':{d:'Option des Befehls Display um Legenden zu schreiben.',p:'Opt',a:['quadrant2','quadrant3','quadrant4']},
    'quadric':{d:'Definiert eine Quadrik durch seine kartesische Gleichung mit x,y,z als Standardvariablen und zeichnet sie.',p:'Expr,[Lst(Var)]'},
    'quadrilateral':{d:'Gibt das Viereck ABCD zurück und zeichnet es.',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Pnt(C)||Cplx,Pnt(D)||Cplx'},
    'quantile':{d:'Gibt die Quantile der Elemente aus l, korrespondierend zu p (0<p<1), zurück.',p:'Lst(l),Real(p)'},
    'quartile1':{d:'Gibt das erste Quartil der Elemente (oder der Spalten) des Arguments zurück.',p:'Lst||Mtrx,[Lst]'},
    'quartile3':{d:'Gibt das dritte Quartil der Elemente (oder der Spalten) des Arguments zurück.',p:'Lst||Mtrx,[Lst]'},
    'quartiles':{d:'Min, erste Quartile, Median, dritte Quartile, max der Elemente (oder der Spalten) des Arguments.',p:'Lst||Mtrx,[Lst]'},
    'quest':{d:'Gibt die n+1 te Frage des Befehlsverlaufs zurück, wenn n>=0 oder die (-n)te vorherige Antwort, wenn n<0 (ohne Spezifizierung ist n=-1 für die vorherige Frage)',p:'Intg(n)',a:['entry']},
    'quo':{d:'Euklidischer Quotient von 2 Polynomen.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'quorem':{d:'Euklidischer Quotient und Rest von 2 Polynomen.',p:'(Vect or Poly),(Vect or Poly),[Var]',a:['divide']},
    'quote':{d:'Gibt das Argument nicht ausgewertet zurück (und auch a:=quote(a) was a freistellt).',p:'Expr',a:['hold']},
    'radians':{d:'',p:'Real(deg)'},
    'radical_axis':{d:'Gibt die Gerade der Punkte zurück, die dieselbe Potenz haben bezüglich der zwei Kreise.',p:'Crcle,Crcle'},
    'radius':{d:'radius(C) gibt den Radius des Kreises C zurück.',p:'Crcle'},
    'radius2':{d:'',p:'Crcle'},
    'rand':{d:'rand(n)=eine zufällige ganze Zahl (bzw. rand(p,n)= eine reelle Zahl oder rand(p..n)=eine reelle Funktion) mit uniformer Verteilung in 0...n-1 (bzw. in [p;n])(rand()=rand(0,1)= eine reelle Zahl in [0,1[). Alternativ rand(n,b1,b2)=n ganze Zahlen zwischen b1 und b2 oder rand(n,L)=n Elemente von L.',p:'Intg(n) or Interval(p..n) or NULL,[Intg(b1) or Lst(L)],[Intg(b2)]',a:['random']},
    'randbetad':{d:'',p:'Real(a),Real(b)',a:['betavariate']},
    'randbinomial':{d:'Gibt ein zufällige ganze Zahl zurück, der eine binomial-Verteilung B(n,p) zugrunde liegt d.h. die Anzahl der Erfolge für n unabhängige Tests, wobei jeder Test die Wahrscheinlichkeit p hat positiv auszufallen.',p:'Intg(n),Real(p)'},
    'randchisquare':{d:'Gibt eine zufällige ganze Zahl zurück, der die chi^2-Verteilung chi^2(n) zugrunde liegt (n Anzahl der Freiheitsgrade).',p:'Intg(n)'},
    'randexp':{d:'Gibt die zufällige reelle Zahl mit Exponential-Verteilung mit Parameter a>0 zurück.',p:'Real(a)',a:['expovariate']},
    'randfisher':{d:'Gibt die zufällige ganze Zahl mit Fisher-Snedecor-Verteilung F(n,m) zurück.',p:'Intg(n),Intg(m)'},
    'randgammad':{d:'',p:'Real(a),Real(b)',a:['gammavariate']},
    'randgeometric':{d:'',p:'Real(p)'},
    'randmarkov':{d:'Gibt eine zufällige Folge von n Zuständen (Markov-Kette) zurück, beginnend von i0 mit der Übergangsmatrix M oder gibt eine stochastische Matrix mit p rekurrenten Schleifen v=[n1,..,np] und i0 transienten Zuständen wieder.',p:'Mtrx(M) || Vctr(v),Intg(i0),[Intg(n)]'},
    'randmultinomial':{d:'Gibt den zufälligen Index oder das zufällige Listenelement zurück. Diese sind multinomial verteilt. Die Verteilung wird durch die Liste P übergeben.',p:'List(P),[List(K)]'},
    'randnorm':{d:'Gibt die zufällige reelle Zahl mit Normal-Verteilung N(mu,sigma) zurück.',p:'Real(mu),Real(sigma)',a:['randNorm','normalvariate']},
    'random_bipartite_graph':{d:'',p:'Intg(n)||Lst(a,b),Real(p)||Intg(m)'},
    'random_digraph':{d:'',p:'Intg(n)||Lst(V),Real(p)||Intg(m)'},
    'random_graph':{d:'',p:'Intg(n)||Lst(V),Real(p)||Intg(m)'},
    'random_network':{d:'',p:'Intg(a),Intg(b),[Real(p)],[opts]'},
    'random_planar_graph':{d:'',p:'Intg(n)||Lst(V),Real(p),[Intg(c)]'},
    'random_regular_graph':{d:'',p:'Intg(n)||Lst(V),Intg(d),[connected]'},
    'random_sequence_graph':{d:'',p:'Lst(L)'},
    'random_tournament':{d:'',p:'Intg(n)||Lst(V)'},
    'random_tree':{d:'',p:'Intg(n)||Lst(V),[Intg(d)||root[=Vrtx(v)]]'},
    'random_variable':{d:'',p:'Lst(W)||Mtrx(M)||Fnc(f),[params]',a:['randvar']},
    'randperm':{d:'Gibt eine zufällige Permutation von [0,1,2,..,n-1] zurück.',p:'Intg(n)||Lst(L)',a:['shuffle']},
    'randpoisson':{d:'Gibt eine zufällige ganze Zahl zurück, der die Poissonverteilung P(lambda) zugrunde liegt.',p:'Real(λ)'},
    'randpoly':{d:'Gibt das Polynom der Variable var (oder x) des Grades n zurück. Die Koeffzienten sind zufällige ganze Zahlen im Bereich -95 bis 95 mit uniformer Verteilung oder mit einem Verteilungsgesetzes.',p:'[Var(Var)],Intg(n),[law]',a:['randPoly']},
    'randstudent':{d:'Gibt eine zufällige ganze Zahl mit Student-Verteilung S(n) zurück.',p:'Intg(n)'},
    'randvector':{d:'Gibt die Liste der Größe n zurück, die zufällige ganze Zahlen zwischen -95 und 95  (oder aus 0...m-1) mit uniformer Verteilung enthält. Die Liste kann auch mit zufälligen Zahlen gefüllt werden, die einem Verteilungsgesetz folgen, dass in Anführungszeichen übergeben werden kann.',p:'Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]',a:['ranv']},
    'randweibulld':{d:'',p:'Real(a),Real(b)',a:['weibullvariate']},
    'range':{d:'',p:'Intg(n)||Intg(a),Intg(b),[Intg(p)]'},
    'rank':{d:'Gibt den Rang einer Matrix zurück.',p:'Mtrx'},
    'ranm':{d:'Gibt die Liste der größe n oder eine n*m Matrix zurück, deren Einträge zufällige ganze Zahlen zwischen -95 und 95 sind oder zufällige Zahlen mit einer Verteilungsregel, die in Anführungszeichen übergeben werden kann.',p:'Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]',a:['randMat','randmatrix']},
    'rat_jordan':{d:'Gibt die Liste zurück, die die Basiswechselmatrix und die rationale Jordannormalform einer Matrix zurück.',p:'Mtrx'},
    'ratinterp':{d:'',p:'[Mtrx(P) || List(X)],[List(Y)],[Var(x)],[Intg(d)])'},
    'rationalroot':{d:'Gibt die Liste der rationalen Wurzeln von P zurück, ohne die Multiplizität mitanzugeben.',p:'Poly(P)'},
    'ratnormal':{d:'Schreibe als irreduzibler rationaler Bruch um.',p:'Expr'},
    'rdiv':{d:'Teilung von a durch b (vorangestellte Lösung von /)',p:'Expr(a),Expr(b)'},
    're':{d:'Gibt den Realteil einer komplexen Zahl zurück.',p:'Cplx or LstCplx',a:['real']},
    'reachable':{d:'',p:'Graph(G),Vrtx(u)'},
    'read':{d:'Liest aus der Datei fich_name die Variablen und deren Werte.',p:'Str(fich_name)',a:['ramene']},
    'readrgb':{d:'Liest eine Bilddatei, dabei wird seine originale Größe verwendet. Im Argument kann die Größe auch spezifiziert werden.',p:'Str(s),[Intg(w)],[Intg(h)]'},
    'readwav':{d:'Liest eine WAV-Sounddatei.',p:'Str(s)'},
    'realroot':{d:'Gibt die Liste der Intervalle zwischen a und b zurück, die eine Länge <=l haben und die reellen Wurzeln von P enthalten. Die Multiplizität wird mitangegeben. Ohne nähere Angabe wird die Vincent-Akritas-Strzebonski (VAS) Methode verwendet. realroot(sturm,P) verwendet Sturms Methode.',p:'[sturm],Poly(P),[Real(l)],[Cplx(a)],[Cplx(b)]'},
    'reciprocation':{d:'Gibt die Liste zurück, in der Punkte (respektive Geraden) mit ihren Polaren (respektive Polen) bezüglich des Kreises C ersetzt werden.',p:'Crcle,Lst(Pnt,Line)'},
    'rect':{d:'',p:'Expr(x)'},
    'rectangle':{d:'Zeichnet und gibt zurück das Rechteck ABCD, AD=k*AB wenn k>0 ist ABCD direkt ansonsten ist es indirekt (in der Ebene ABP AD=AP oder AD=k*AB).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Real(k)||Pnt(P)||Lst(P,k),[Var(D)],[Var(C)]'},
    'rectangle_plein':{d:'Zeichnet ein Rechteck (respektive ein Quadrat) mit den Seiten a,b (respektive a) von der Position der Schildkröte und links davon (ohne Spezifikation b=a)',p:'Real(a),[Real(b)]'},
    'rectangular_coordinates':{d:'Gibt die Liste der Abszissen und Ordinaten eines Punktes zurück, der als Liste von Polarkoordinaten angegeben wird.',p:'LstPolCoord'},
    'recule':{d:'Die Schildkröte macht n Schritte rückwärts (Ohne Spezifikation n=10).',p:'NULL or Real(n)',a:['backward']},
    'reduced_conic':{d:'Gibt den Ursprung und die Matrix einer Basis zurück, in der der Kegelschnitt, gegeben durch seine Gleichung, reduziert ist. Zudem wird zurückgegeben: 0 oder 1 (0 wenn der Kegelschnitt entartet ist), sowie die Gleichung des Kegelschnittes in dieser Basis und seine parametrische Gleichung.',p:'Expr,[LstVar]'},
    'reduced_quadric':{d:'Gibt den Ursprung und die Matrix einer Basis zurück, in der die Quadrik (gegeben durch seine Gleichung) reduziert ist. Zudem wird angegeben: Die Liste der Eigenwerte, die Gleichung der Quadrik in dieser Basis und die parametrische Gleichung.',p:'Expr, [LstVar]'},
    'ref':{d:'Gaußsche Reduktion von AX=b (M=A|(-b)).',p:'Mtrx(M)'},
    'reflection':{d:'reflection(D,C) (oder reflection(A,C))=Spiegelung von C mit der Symmetrieachse D (oder dem Symmetriezentrum A).',p:'(Pnt(A) or Line(D)),(Pnt(C) or Curve(C))'},
    'regroup':{d:'Fasst Terme in einem Ausdruck zusammen.',p:'Expr'},
    'relabel_vertices':{d:'',p:'Graph(G),Lst(L)'},
    'reliability_polynomial':{d:'',p:'Graph(G),[Var(p)]'},
    'rem':{d:'Euklidischer Rest von 2 Polynome.',p:'(Vect or Poly),(Vect or Poly),[Var]'},
    'remove':{d:'Löscht die Vorkommnisse e aus l oder die Elemente e sodass f(e)=wahr.',p:'FncBool(f)||a,Lst(l)'},
    'reorder':{d:'Ordnet die Variablen in E bezüglich der Reihenfolge des zweiten Arguments neu.',p:'Expr, LstVar'},
    'repeat':{d:'repeat-Loop (Wiederholt die Instruktion bis cond==true also die Bedingung erfüllt ist): repeat i1;i2; until cond;',a:['until','repeter','jusqua','jusqu_a']},
    'repete':{d:'Befehl führt k mal dasselbe Kommando aus.',p:'Intg,SeqCmds'},
    'resample':{d:'',p:'Audio(clip),[Intg(s),[Intg(q)]]'},
    'residue':{d:'Gibt das Residuum eines Ausdrucks zurück, mit v als Variable.',p:'Expr,Var(v),Cplx(a)'},
    'restart':{d:'Gibt alle Variablen frei.',p:'NULL'},
    'resultant':{d:'Resultante von zwei Polynomen.',p:'Poly,Poly,Var'},
    'return':{d:'Befehl, der eine Funktion unterbricht und dessen Wert zurückgibt.',p:'Expr'},
    'reverse_graph':{d:'',p:'Graph(G)'},
    'reverse_rsolve':{d:'Wenn v=[v_0 ... v_(2n-1)], gebe [b_n,...,b_0] so zurück, dass b_n*v_{n+k}+...+b_0*v_k=0 mit k=0..n-1.',p:'Vect(v)',a:['berlekamp_massey']},
    'revert':{d:'Gibt die reziproke Entwicklung einer Serienentwicklung um 0 zurück.',p:'Expr'},
    'revlex':{d:'Option des "gbasis" oder "greduce" Befehls, um die Ordnung für Monome zu spezifizieren (Totaler Grad, danach invers lexikographisch)',p:'Opt'},
    'revlist':{d:'Gibt die Liste l in umgekehrter Reihenfolge zurück.',p:'Lst(L)||Audio',a:['reverse']},
    'rgb':{d:'',p:'Lst(r,g,b)||Intg(rrggbb)||Str(rrggbb)||Color(c)'},
    'rgb2hsv':{d:'',p:'Lst(r,g,b)'},
    'rgb2xyz':{d:'',p:'Lst(r,g,b)||Color(c)'},
    'rhombus':{d:'Zeichnet und gibt zurück die Raute ABCD, sodass der Winkel (AB,AD)=a (oder in der Ebene ABP Winkel(AB,AD)=(AB,AP) ).',p:'Pnt(A)||Cplx,Pnt(B)||Cplx,Angle(a)||Pnt(P)||Lst(P,a)),[Var(C)],[Var(D)]'},
    'rhombus_point':{d:'Option des Befehls display für einen Punkt.',p:'Opt',a:['point_losange','plus_point','point_plus','square_point','point_carre','cross_point','point_croix','triangle_point','point_triangle','star_point','point_etoile','point_point','invisible_point','point_invisible']},
    'riemann_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'right':{d:'Gibt den rechten Teil einer Gleichung, eines Intervalls, einer Liste oder eines Strings zurück.',p:'Equal(a=b) or Interval(a..b) or Str,Intg',a:['rhs','droit']},
    'right_triangle':{d:'Zeichnet das rechtwinklige Dreieck ABC mit AC=k*AB (oder in der Ebene ABP AC=AP ,wobei AC=k*AB).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Real(k) or Pnt(P) or Lst(P,k)),[Var(C)]'},
    'risch':{d:'Gibt die Stammfunktion eines Ausdrucks zurück, die mit dem Risch-Algorithmus berechnet wurde.',p:'Expr,[Var]'},
    'rm_a_z':{d:'Löscht alle Variablennamen, die nur einen Kleinbuchstaben a..z haben.',p:'NULL'},
    'rm_all_vars':{d:'Löscht alle Variablennamen.',p:'NULL'},
    'rmbreakpoint':{d:'Entfernt einen Stopp-Punkt(breakpoint).',p:'Intg'},
    'rmmod':{d:'Entfernt die installierten dynamischen Bibliotheken.',p:'Str(pwd)'},
    'rms':{d:'',p:'Lst(X)'},
    'rmwatch':{d:'Löscht die Variable von der Tabelle der angezeigten Variablen in Schritt-für-Schritt.',p:'Var'},
    'romberg':{d:'Gibt den ungefähren Wert von integrate(f(x),x,a,b) durch Romberg-Integration zurück.',p:'Expr(f(x)),Var(x),Real(a),Real(b)',a:['nInt']},
    'rond':{d:'Zeichnet einen Kreis (oder einen Bogen) mit Radius r (respektive mit dem Winkel (0,a) oder (a,b)), anliegend an die Position der Schildkröte.',p:'Real(r),[Real(a)],[Real(b)]'},
    'root':{d:'Gibt b^(1/a) (root(2,3)=sqrt(3)) zurück.',p:'Expr(a),Expr(b)'},
    'rootof':{d:'Polynom in Form einer Nullstelle eines irreduziblen Polynoms auf Q. Gibt P(a) mit der größten Nullstelle von Q zurück.',p:'LstPoly(P),LstPoly(Q)'},
    'roots':{d:'Gibt eine Matrix mit zwei Spalten zurück, bei der die Zeilen die Nullstellen des Polynoms mit ihrer Multiplizität sind (für eine Variable)',p:'Poly,[Var]'},
    'rotate':{d:'Gibt die Liste zurück, bei der das letzte Element [oder der Schwanz beginnend mit dem n-ten Element] das erste Element wird (ohne Spezifikation n=-1).',p:'Lst||Str(L),[Intg(n)]'},
    'rotation':{d:'rotation(B,a1,A)(bzw. rotation(d,a1,A)) ist die Transformierte von A mit der Rotation um das Zentrum B(bzw. Um die Axe d) mit dem Winkel a1.',p:'(Pnt(B) or Cplx or Dr3),Angle(a1),(Pnt(A) or Curve)'},
    'round':{d:'Rundet die reelle oder komplexe Zahl zur nächsten ganzen Zahl (bzw. zum nächsten Dezimal) oder zum nächsten Element von  â„¤[i] (bzw. mit n Dezimalen).',p:'Real or Cplx,[Intg(n)]'},
    'row':{d:'Gibt die Reihe n oder die Folge der Reihen n1..n2 der Matrix A zurück, oder mit den optionalen Argumenten: count,count_eq,count_inf,count_sup.',p:'Mtrx(A),Intg(n)||Interval(n1..n2)'},
    'rowAdd':{d:'Gibt die Matrix zurück, die man erhält, wenn man in A die n2-te Zeile mit der Summe aus n1-ten und n2-ten Zeile ersetzt.',p:'Mtrx(A),Intg(n1),Intg(n2)'},
    'rowNorm':{d:'Gibt das Maximum der l1_Norm der Zeilen einer Matrix zurück:rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).',p:'Vect or Mtrx',a:['rownorm']},
    'rowSwap':{d:'Gibt die Matrix zurück, die man erhält, wenn man die n1-ste und die n2-te Zeile vertauscht.',p:'Mtrx(A),Intg(n1),Intg(n2)',a:['swaprow','rowswap','SWAPROW']},
    'rowdim':{d:'Anzahl der Zeilen einer Matrix.',p:'Mtrx',a:['nrows','rowDim']},
    'rowspace':{d:'Gibt eine Matrix zurück, deren Zeilen die Basis eines Vektorraums sind, der von den Zeilen der Matrix A generiert wurde.',p:'Mtrx(A), [Var(d)]'},
    'rref':{d:'Zeilenreduktion auf Echelon-Form (Treppenform) von AX=b (M=A|(-b)) [Reduktion auf den Spalten 0..k-1]',p:'Mtrx(M),[Intg(k)]||Opt',a:['gaussjord']},
    'rsolve':{d:'Gibt den Wert einer rekursiven Folge oder eines Systems rekursiver Folgen an.',p:'(Expr or LstExpr),(Var or LstVar),(InitVal or LstInitVal)'},
    'rur':{d:'',p:'Intg(n)'},
    'rur_certify':{d:'',p:'Intg(n)'},
    'same':{d:'Gleichheitstest.',p:'Expr,Expr'},
    'sample':{d:'',p:'Intg(n1),Intg(n2)'},
    'samplerate':{d:'',p:'Audio(clip)'},
    'saute':{d:'Die Schildkröte geht n Schritte vorwärts, ohne Spur (ohne Spezifikation n=10).',p:'NULL or Real(n)'},
    'save_history':{d:'Speichert den Verlauf der Befehle in einem Dokument mit dem Namen "str".',p:'Str(str)'},
    'scale':{d:'Multipliziert die Zeile n1 der Matrix A mit Xpr.',p:'Mtrx(A),Expr(Xpr),Intg(n1)',a:['SCALE']},
    'scaleadd':{d:'Multipliziert die Zeile n1 der Matrix A mit Xpr und addiert sie danach auf Zeile n2.',p:'Mtrx(A),Expr(Xpr),Intg(n1),Intg(n2)',a:['SCALEADD']},
    'scatterplot':{d:'Zeichnet für k=0..nrows, die Punkte (xk,yk), wobei xk=Element Zeile k, Spalte 0 und yk=Element Zeile k Spalte j (j=1..ncols).',p:'Mtrx',a:['nuage_points']},
    'sec':{d:'Sekansfunktion:sec(x)=1/cos(x).',p:'Expr'},
    'segment':{d:'segment(A,B) zeichnet das Intervall AB und segment([xM,yM],[xN,yN]) zeichnet den Vektor mit Ursprung [xM,yM] und den Koordinaten [xN,yN] (d.h. zeichnet das Intervall (M,point(M+n)).',p:'(Pnt or Cplx or Lst([xM,yM])),(Pnt or Cplx or Lst([xN,yN]),[Var],[Var] or Opt'},
    'seidel_spectrum':{d:'',p:'Graph(G)'},
    'seidel_switch':{d:'',p:'Graph(G),Lst(V)'},
    'select':{d:'Wählt die Elemente e aus l, sodass f(e)=wahr ist.',p:'FncBool(f),Lst(l)'},
    'semi_augment':{d:'Gibt eine Matrix zurück, die aus A und B gemacht wurde. Diese hat n1+n2 Zeilen und p Spalten, wenn dim(A)=[n1,p] und dim(B)=[n2,p].',p:'Mtrx(A),Mtrx(B)'},
    'seq':{d:'Gibt die Folge (2 oder 3 arg) oder die Liste (4 oder 5 arg), die man erhält, wenn var von a zu b läuft (Schritt p) in Xpr (oder die Xpr wird n mal wiederholt oder die Folge reeller Zahlen von a zu b (Schritt p)). Auch ist seq(expression,variable,liste) equivalent zu map(liste,unapply(expression,variable))',p:'Expr(Xpr),Var(Var)=Int(a..b),[Real(p)]||Expr(Xpr),Var(Var),Real(a),Real(b),[Real(p)]'},
    'seqsolve':{d:'Gibt den Wert einer rekursiven Folge zurück (u_{n+1}=f(u_n) oder u_{n+k}=f(u_n,u_{n+1}...u_{n+k-1})) oder den eines Systems rekursiver Folgen.',p:'(Expr or LstExpr),(Var or LstVar),(InitVal or LstInitVal)'},
    'sequence_graph':{d:'',p:'Lst(L)'},
    'series':{d:'Serienentwicklung bei endlichen oder unendlichen Punkten.',p:'Expr,Equal(var=limit_point),[Order],[Dir(1,0,-1)]'},
    'set[]':{d:'set[] oder %{%} wird benutzt um eine Menge zu definieren.',p:'Seq',a:['%{%}']},
    'set_channel_data':{d:'',p:'Audio(clip),Lst||Mtrx(data),[Intg(offset),Intg(chn)]||Image(img),Intg(chn),Intg(x),Intg(y),Mtrx(data)'},
    'set_edge_attribute':{d:'',p:'Graph(G),Edge(e),Seq(tag1=value1,tag2=value2,..)'},
    'set_edge_weight':{d:'',p:'Graph(G),Edge(e),Real(w)'},
    'set_graph_attribute':{d:'',p:'Graph(G),Seq(tag1=value1,tag2=value2,..)'},
    'set_pixel':{d:'',p:'Intg(x),Intg(y),Intg(col)',a:['draw_pixel']},
    'set_screen':{d:'',p:'Intg(x),Intg(y)'},
    'set_vertex_attribute':{d:'',p:'Graph(G),Vrtx(v),Seq(tag1=value1,tag2=value2,..)'},
    'set_vertex_positions':{d:'',p:'Graph(G),Lst(vp)'},
    'shift':{d:'Gibt eine Liste zurück, dessen letztes Element (oder der Schwanz beginnend mit dem n-ten Element) das erste Element wird und dann mit undef aufgefüllt wird (ohne Spezifikation n=-1).',p:'Lst,[Intg(n)]'},
    'shift_phase':{d:'Gibt den Ausdruck zurück, bei dem die Phase des ausgewerteten trigonometrischen Ausdrucks um pi/2 erhöht wurde.',p:'Expr'},
    'shortest_path':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)||Lst(T)'},
    'show_pixels':{d:'',p:'NULL'},
    'si':{d:'Befehle mit Bedingung : (si (=if,wenn) … (=then, dann)...sinon(=else,sonst)...fsi(finish if,Ende wenn))',a:['alors','sinon','fsi']},
    'sierpinski_graph':{d:'',p:'Intg(n),Intg(k),[triangle]'},
    'sign':{d:'Gibt das Vorzeichen (-1,0,+1) des Argumentes zurück.',p:'Expr'},
    'sign2Heaviside':{d:'',p:'Expr'},
    'signature':{d:'Gibt das Vorzeichen einer Permutation zurück.',p:'Permut'},
    'signe':{d:'Schreibe den String s in Schriftart 20 am Punkt [10,10].',p:'Str(s)'},
    'similarity':{d:'similarity(B,k,a1,A)=ähnlichkeitstransformierte von A (Zentrum B oder Achse d, Koeffizient k, Winkel a1) (oder auch homothety(B,k*exp(i*a1),A)).',p:'Pnt or Dr3,Real,Angle,Pnt'},
    'simp2':{d:'Gibt die Liste [A/gcd(A,B),B/gcd(A,B)] zurück.',p:'Intg(A) or Poly(A),Intg(B) or Poly(B)'},
    'simplex_reduce':{d:'Reduktion mit dem simplex-Algorithmus, um max(c.x) zu finden unter der Bedingung A.x<=b und x>=0, b>=0. Gibt das Maximum, die verbesserte Lösung "x" und die reduzierte Matrix zurück. Akzeptiert auch[[A|I|b],[-c|*|0]] als Argument.',p:'Mtrx(A), Vect(b), Vect(c)'},
    'simplicial_vertices':{d:'',p:'Graph(G)'},
    'simplify':{d:'Vereinfacht einen Ausdruck.',p:'Expr',a:['simplifier']},
    'simplifyDirac':{d:'',p:'Expr,[Seq(vars)]'},
    'simpson':{d:'Option des "area" Befehls.',p:'Opt',a:['rombergt','rombergm','gauss15']},
    'simulated_annealing':{d:'',p:'x0,Func(cost),Func(dist),Func(step),Lst(csparam),[Lst(iterparam),[Real(maxstep)]]'},
    'simult':{d:'Gibt die Matrix zurück, bei der die k-te Spalte die Lösung von A*X= k-te Spalte von B(=B[0..nl-1,k..k] ist.',p:'Mtrx(A),Mtrx(B)'},
    'sin':{d:'Sinus oder Option des convert bzw. convertir Befehls (id trigsin).',p:'Expr or Opt',a:['SIN']},
    'sin2costan':{d:'Ersetzt sin(x) durch cos(x)*tan(x) im Argument.',p:'Expr'},
    'sinc':{d:'',p:'Expr(x)'},
    'sincos':{d:'Wandelt die komplexe Exponentialfunktion in Sinus und Kosinus um (id exp2trig) oder Option des convert bzw. convertir Befehls (id sincos).',p:'Expr or Opt'},
    'single_inter':{d:'Gibt einer der Schnittpunkte zweier Kurven oder Oberflächen an (oder die Schnittmenge nah an A, nicht in L).',p:'Curve,Curve,[Pnt(A)||LstPnt(L)]',a:['line_inter']},
    'sinh':{d:'',p:'Expr'},
    'size':{d:'Gibt die Größe einer Liste, eines Strings oder einer Folge zurück.',p:'Lst||Str||Seq||Image||Audio',a:['nops','length','len']},
    'sizes':{d:'Gibt die Größe einer Liste aus Listen zurück.',p:'Lst or Str or Seq'},
    'slope':{d:'Gibt die Steigung einer Geraden zurück, die im Argument definiert wurde oder kann als Attribut von droite verwendet werden.',p:'Line||Pnt||Cplx,[Pnt||Cplx]'},
    'slopeat':{d:'slopeat(d,z0) zeigt am Punkt(z0) mit einer Legende den Wert der Steigung der Geraden oder des Segments d an.',p:'Line, Pnt||Cplx(z0)'},
    'slopeatraw':{d:'slopeat(d,z0) zeigt am Punkt(z0)  den Wert der Steigung der Geraden oder des Segments d an.',p:'Line, Pnt||Cplx(z0)'},
    'smith':{d:'Gibt die Smith-Normalform der Koeffizientenmatrix eines Polynoms zurück (U,D,V sodass U*A*V=D).',p:'Matr(A)'},
    'smod':{d:'Gibt den euklidischen symmetrischen Rest von zwei ganzen Zahle zurück.',p:'Intg,Intg',a:['mods']},
    'solve':{d:'Löst eine (oder eine Menge von) Polynomialen Gleichungen.',p:'Expr,[Var]',a:['resoudre']},
    'sommet':{d:'Gibt den Gipfel eines Operators zurück.',p:'Op or Fnct'},
    'sort':{d:'Gibt die geordnete Liste (oder Folge) mit aufsteigender Reihenfolge oder bezüglich der Funktion des zweiten Argument, die eine schwache strikte Ordnung definiert oder sammelt alle gleichen Terme in Summen oder Produkten.',p:'LstReal or Seq [Fnc]',a:['sorted']},
    'sorta':{d:'Sortiert eine Liste mit aufsteigender Reihenfolge oder die erste Matrixzeile mit aufsteigender Reihenfolge und mit gleichbleibenden Spalten.',p:'LstReal||Seq×||Mtrx'},
    'sortd':{d:'Sortiert die Liste mit absteigender Reihenfolge (wie TI). Alternativ die erste Zeile einer Matrix in absteigender Reihenfolge, wobei die Spalten beibehalten werden.',p:'LstReal||Seq||Mtrx'},
    'sortperm':{d:'',p:'Lst(V),[Permu(P)]'},
    'soundsec':{d:'Erstellt eine Vektor, der n Sekunden Zeit /N entspricht (standardmäßig N=44100).',p:'Intg(n),[Intg(N)]'},
    'spanning_tree':{d:'',p:'Graph(G),[Vrtx(r)]'},
    'sphere':{d:'Sphäre (A,B) (respektive Sphäre (A,r)) zeichnet die Sphäre mit Durchmesser AB (respektive Zentrum A und Radius r) im 3D Raum.',p:'(Pnt or Vect),(Pnt or Real)'},
    'splice':{d:'',p:'Audio(clip1),Audio(clip2),[Intg(len),Real(p)]'},
    'spline':{d:'Spline (Polynomzug) durch die Punkte gegeben durch die Listen lx und ly, Variable x, Grad d.',p:'Lst(lx),Lst(ly),Var(x),Intg(d)'},
    'split':{d:'Spaltet die beiden Variablen var1, var2 des Ausdrucks Xpr (ohne Zähler) oder gibt [0] zurück.',p:'(Expr(Xpr),Lst(var1,var2))||(Str(s),Str(sep))'},
    'spring':{d:'',p:'Opt'},
    'sq':{d:'Ist der Name der Funktion (R^n?R)=Summe der Quadrate der Argumente.',p:'Seq'},
    'sqrfree':{d:'Faktorisiert das Argument indem die Terme mit demselben Exponenten zusammen gruppiert werden.',p:'Expr'},
    'sqrt':{d:'Quadratwurzel',p:'Expr'},
    'square':{d:'Zeichnet und gibt zurück das Quadrat der Seite AB (ABCD ist direkt) (in der Ebene ABP).',p:'(Pnt(A) or Cplx),(Pnt(B) or Cplx),[Pnt(P),Var(C),Var(D)]'},
    'srand':{d:'srand gibt eine ganze Zahl zurück und initialisiert eine Folge von zufälligen Zahlen.',a:['randseed']},
    'sst':{d:'Führt eine Anweisung in Schritt-für-Schritt aus.',p:'NULL'},
    'sst_in':{d:'Gehe in eine Funktion in Schritt-für-Schritt-Modus hinein.',p:'NULL'},
    'st_ordering':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)'},
    'stack':{d:'Reserviertes Wort.'},
    'star_graph':{d:'',p:'Intg(n)'},
    'stddev':{d:'Gibt die Standardabweichung der Elemente im Argument zurück, die mit dem optionalen zweiten Argument gewichtet werden können. Sonst kann auch die Liste der Standardabweichungen der Spalten einer Matrix berechnet werden.',p:'Lst||Mtrx,[Lst]',a:['ecart_type']},
    'stddevp':{d:'Gibt eine erwartungstreue Schätzung der Standardabweichung der Population der Stichprobe (erstes Argument). Im optionalen zweiten Argument kann eine Liste von Gewichtungen angegeben werden.',p:'Lst||Mtrx,[Lst]',a:['stdDev','ecart_type_population']},
    'step':{d:'Schrittgröße in einer Iteration',a:['by','pas']},
    'stereo2mono':{d:'',p:'Audio(clip)'},
    'stft':{d:'',p:'Lst(data)'},
    'sto':{d:'Speichert das erste Argument in der Variable, die im zweiten Argument gegeben wurde.',p:'(Real or Str),Var',a:['Store']},
    'str':{d:'Gibt den ausgewerteten Ausdruck als String zurück. Kann auch als Option des convert/convertir Befehls genutzt werden (id string)',p:'Expr or Opt',a:['string']},
    'strip':{d:'',p:'Str(s)'},
    'strongly_connected_components':{d:'',p:'Graph(G)'},
    'student':{d:'Gibt Wahrscheinlichkeitsdichte der Student-Verteilung zurück (n ist die Anzahl der Freiheitsgrade).',p:'Intg(n),Real(x0)',a:['studentd']},
    'student_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Student-verteilte Zufallsvariable kleiner als x0 ist (n ist der Anzahl der Freiheitsgrade).',p:'Intg(n),Real(x0)'},
    'student_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine Student-verteilte Zufallsvariable kleiner als h ist, p ist (n ist die Anzahl der Freiheitsgrade und 0<=p<=1).',p:'Intg(n),Real(p)'},
    'studentt':{d:'T-Test/Student-Verteilung: arg1=[Treffe,Versuch] oder [Mittel, Stichprobengröße] oder Daten. Arg2=Proportion oder Mittel der Vorkommnisse oder Daten, arg 3 optional wenn Daten=sigma, arg4 alternativ \'!=\' oder \'>\' oder \'<\', arg5 optional Konfidenzniveau (statistische Sicherheit).',p:'Lst,Real,[Real],Fnc,[Real]'},
    'sturm':{d:'Sturm-Kette korrespondierend zu einem Polynom oder einer Zahl von Vorzeichenwechsel dieses Polynoms in ]a;b].',p:'Poly,[Var],[Cplx(a)],[Cplx(b)]'},
    'sturmab':{d:'Zahl der Vorzeichenwechsel des Polynoms in ]a;b] oder der komplexen Nullstellen in a..b, wenn a oder b nicht reell sind.',p:'Poly,Var,Cplx(a),Cplx(b)'},
    'sturmseq':{d:'Sturm-Kette korrespondierend zu einem Polynom oder einem rationalen Bruch.',p:'Poly,[Var]'},
    'style':{d:'Lokale Option (kompatibel mit Maple) eines Grafik-Befehls um eine gepunktete Linie zu zeichnen mit style=point.',p:'Opt'},
    'subMat':{d:'Extrahiere eine Unter-Matrix mit dem ersten Element=A[n1,n2] und dem letzten Element A[n3,n4].',p:'Mtrx(A),Intg(n1),Intg(n2),Intg(n3),Intg(n4).'},
    'subdivide_edges':{d:'',p:'Graph(G),Lst(E),[Intg(r)]'},
    'subgraph':{d:'',p:'Graph(G),Lst(E)'},
    'subs':{d:'Equivalent zu subst, außer das in maple_mode, indem die Argumente vertauscht sind. Im maple_mode wähle man Beispiel 2',p:'Expr or Var=value,Var=value or Expr'},
    'subsop':{d:'Ersetzt in der Liste (oder der Matrix) das Element an Stelle n mit dem Ausdruck (bei Maple werden die Argumente vertauscht) (NULL entfernt das Element)',p:'Lst||Mtrx,Intg(n)=Expr'},
    'subst':{d:'Substituiert einen Wert für eine Variable in einem Ausdruck.',p:'Expr,Var(v)=value(a)',a:['substituer']},
    'subtype':{d:'Gibt 1 für eine Folge, 2 für eine Menge, 10 für ein Polynom und 0 sonst zurück.',p:'Expr'},
    'sum':{d:'Diskrete Summe (mit 2 oder 4 Argumenten. Gibt die Summe von a zu b wenn a<=b oder das Gegenteil der Summe von b+1 bis a-1, wenn a>b+1 oder 0, wenn a=b+1). Alternativ die diskrete Stammfunktion oder die Summe der Elemente einer Liste oder Folge.',p:'Expr,Var,VarMin(a),VarMax(b),[VarStep(p)]',a:['somme','add']},
    'sum_riemann':{d:'Gibt ein äquivalent in der Umgebung von var1=+infini der Summe von Xpr(var1,var2) zurück, wobei var2 von 1 zu var2 läuft, wenn die Summe Riemannsch ist.',p:'Expr(Xpr),Lst(var1,var2)'},
    'suppress':{d:'Gibt l ohne das Element mit Index n zurück.',p:'Vect(L)||Str(l),Intg(n)'},
    'surd':{d:'Potenz 1/n.',p:'Expr,Intg(n)'},
    'svd':{d:'Für eine quadratische numerische reelle Matrix A wird U orthogonal, S Vektor der Singulärwerte, Q orthogonal zurückgegeben, sodass A=U*diag(S)*tran(Q).',p:'Mtrx(A)'},
    'switch':{d:'Test(multiple choice (verschieden Auswahl)): switch(Variable){Fall 1: {bloc1;} standard: {bloc2}};'},
    'switch_axes':{d:'switch_axes() löscht oder fügt die Achsen des Grafik-Bildschirms hinzu.',p:'[Intg(0 or 1)]'},
    'sylvester':{d:'Sylvester-Matrix von zwei Polynomen.',p:'Poly,Poly,Var'},
    'symb2poly':{d:'Gibt die Koeffizienten eines Polynoms bezüglich des zweiten Arguments zurück oder, wenn das zweite Argument eine Liste ist, die interne Form des Polynoms.',p:'Expr, LstVar or [Var]',a:['e2r']},
    'symbol_array':{d:'',p:'Strng(str),Seq(dim)'},
    'syst2mat':{d:'Gibt die Matrix M=A|(-b) assoziiert mit dem System Y=AX+b.',p:'LstLinEq,LstVar'},
    'syzygy':{d:'',p:'List'},
    'table':{d:'Definiert ein arrey, bei dem der Index aus Strings oder reellen Zahlen besteht, alternativ eine Tabelle mit einer Matrix.',p:'SeqEqual(index=value)'},
    'tablefunc':{d:'Tabelle der Werte einer Funktion: Man muss den Tabellenmodus benutzen.',p:'Expr,Var'},
    'tableseq':{d:'Tabelle der Werte einer Folge (im Tabellenmodus).',p:'Expr,(Var or LstVar),(InitVal or LstInitVal)'},
    'tabsign':{d:'',p:'Expr,Var'},
    'tabvar':{d:'Tabelle der Variationen und der Graph einer Funktion auf DispG.',p:'Expr,Var'},
    'tail':{d:'Gibt die Liste (oder Folge oder String) ohne erstes Element zurück.',p:'Lst or Seq or Str'},
    'tan':{d:'Tangens oder Option des convert bzw. convertir Befehls (id halftan).',p:'Expr',a:['TAN']},
    'tan2cossin2':{d:'Ersetzt tan(x) durch (1-cos(2*x))/sin(2*x) im Argument.',p:'Expr'},
    'tan2sincos':{d:'Ersetzt tan(x) durch sin(x)/cos(x) im Argument.',p:'Expr'},
    'tan2sincos2':{d:'Ersetzt tan(x) durch sin(2*x)/(1+cos(2*x)) im Argument.',p:'Expr'},
    'tangent':{d:'tangent(C,A) zeichnet die Tangente (Gerade oder Ebene) durch C an A.',p:'Curve(C),Pnt(A)',a:['tangente']},
    'tanh':{d:'Tangens hyperbolikus.',p:'Expr'},
    'tantque':{d:'While-Schleife (tantque...faire...ftantque;) Übersetzt: (Während...mache...Ende Während).'},
    'tar':{d:'',p:'String || Buffer || Buffer,String || Buffer,Int,String'},
    'taux_accroissement':{d:'Gibt die Wachstumsrate eines Ausdrucks zurück, wobei die Variable von Val1 zu Val2 geht (Standardeinstellung Var = x).',p:'Expr,Var,Val1,(Val1+Var or Val2)'},
    'taylor':{d:'Reihenentwicklung bei endlichen oder unendlichen Punkten (Standard x=0 und die relative Ordnung=5)',p:'Expr,[Var=limit_point],[Order]'},
    'tchebyshev1':{d:'Gibt das n-te Tchebyshev-Polynom der erste Art zurück.',p:'Intg(n)'},
    'tchebyshev2':{d:'Gibt das n-te Tchebyshev-Polynom der zweiten Art zurück.',p:'Intg(n)'},
    'tcoeff':{d:'Gibt die Koeffizienten des Terms mit der niedrigsten Ordnung in einem Polynom zurück. (t=trailing).',p:'Poly||Lst'},
    'tcollect':{d:'Fasst trigonometrische Audrücke zusammen.',p:'Expr',a:['tCollect','rassembler_trigo']},
    'tdeg':{d:'Option des "gbasis" oder "greduce" Befehls, um die Ordnung der Monome zu spezifizieren (Totaler Grad, danach lexikographisch).',p:'Opt'},
    'tensor_product':{d:'',p:'Seq(G1,G2,[G3])'},
    'test':{d:'Testfunktion für Entwickler.',p:'Var'},
    'texpand':{d:'Entwickelt transzendente Funktionen.',p:'Expr',a:['tExpand','developper_transcendant']},
    'then':{d:'Wird in einer Wenn..Dann Konstruktion verwendet: if (Bedingung) then Befehl; end_if;'},
    'thickness':{d:'Option (kompatibel mit Maple) eines Grafik-Befehls, um Liniendicke zu definieren.',p:'Opt',a:['epaisseur']},
    'thiele':{d:'',p:'[Mtrx(P) || List(X)],[List(Y)],[Var(x)]'},
    'threshold':{d:'',p:'Lst,Real(bound)[=Expr(repl)] or Lst[Real(lower)[=Expr(rl)],Real(upper)[=Expr(ru)]],[Fnc(compare)],[abs[=true or false]]'},
    'time':{d:'Gibt die Zeit zurück, die nötig ist, um einen Befehl zu berechnen oder die Zeit seit Beginn der Sitzung.',p:'NULL'},
    'title':{d:'Globale Option eines Grafik-Befehls, um einen Titel in die Grafik einzufügen.',p:'Opt',a:['titre']},
    'tlin':{d:'Trigonometrische Linearisierung.',p:'ExprTrig',a:['lineariser_trigo']},
    'tonnetz':{d:'',p:'Intg(a),Intg(b),Intg(c),[Intg(d)]'},
    'topologic_sort':{d:'',p:'Graph(G)',a:['topological_sort']},
    'torus_grid_graph':{d:'',p:'Intg(m),Intg(n)'},
    'total_degree':{d:'',p:'Poly(P),Lst(Vars)'},
    'tourne_droite':{d:'Die Schildkröte dreht sich n Grad nach rechts (ohne Spezifikation',p:'NULL or Real(n)'},
    'tourne_gauche':{d:'Die Schildkröte dreht sich n Grad nach links (ohne Spezifikation',p:'NULL or Real(n)'},
    'tpsolve':{d:'',p:'List(supply),List(demand),Mtrx(cost_matrix)'},
    'trace':{d:'Gibt die Spur einer quadratischen Matrix zurück oder zeichnet die Spur eines geometrischen Objektes, wenn sich der Parameter verändert.(siehe Trace im Menü, Knopf auf geometrischen Niveau und schreibe nur einen Befehl pro Zeile).',p:'Mtrx or GeoObj'},
    'trail':{d:'',p:'Seq(V)'},
    'trail2edges':{d:'',p:'Trail(T)'},
    'train':{d:'',p:'NeuralNet(net),Mtrx(input),Mtrx||Vect(expected_output),[Intg(batchsize)])'},
    'tran':{d:'Transponiere eine Matrix (ohne Konjugation).',p:'Mtrx',a:['transpose']},
    'transitive_closure':{d:'',p:'Graph(G),[weighted[=true||false]]'},
    'translation':{d:'translation(B-A,C) (bzw. translation([a,b,c],C)) ist C verschoben in Richtung des Translationsvektors AB (bzw. [a,b,c]).',p:'Vect, Pnt(C)'},
    'trapezoid':{d:'Option des "plotarea" und des "area" Befehls.',p:'Opt',a:['middle_point','left_rectangle','right_rectangle','trapeze','point_milieu','rectangle_droit','rectangle_gauche']},
    'traveling_salesman':{d:'',p:'Graph(G),[Mtrx(M)],[opts]'},
    'tree':{d:'',p:'Opt'},
    'tree_height':{d:'',p:'Graph(T),[Vrtx(r)]'},
    'tri':{d:'',p:'Expr(x)'},
    'triangle':{d:'triangle(A,B,C) zeichnet das Dreieck ABC.',p:'(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)'},
    'triangle_paper':{d:'Zeichnet ein Rechteck [xmin..xmax]*[ymin..ymax] mit den Linien eines Netzwerks konstruiert durch y=n*uy und in Richtung der Achse OxY mit dem Winkel t!=0 mit den Linien x=n*ux und ux*y+uy*x=n*ux*uy.',p:'Real(ux),Real(t),Real(uy),[x=xmin..xmax,y=ymin..ymax]'},
    'triangle_plein':{d:'Zeichnet ein ausgefülltes Dreieck mit den Seiten a,b und dem Winkel von der Position der Schildkröte (ohne Spezifikation t=90 oder (b=a und t=90)).',p:'Real(a),[Real(b)],[Real(t)]'},
    'triangle_window':{d:'',p:'Lst,[Intg(d)],[Interval(n1..n2)]'},
    'trig2exp':{d:'Ersetzt die trigonometrischen Funktionen im Argument durch komplexe Exponentialfunktionen ohne Linearisierung.',p:'Expr'},
    'trigcos':{d:'Vereinfacht das Argument mit den Formeln sin(x)^2+cos(x)^2=1 und tan(x)=sin(x)/cos(x) wobei Kosinus bevorzugt wird.',p:'Expr'},
    'trigexpand':{d:'Entwickelt eine trigonometrische Funktion.',p:'Expr'},
    'triginterp':{d:'',p:'List,Var=xmin..xmax'},
    'trigsimplify':{d:'',p:'Expr'},
    'trigsin':{d:'Vereinfacht das Argument mit den Formeln sin(x)^2+cos(x)^2=1 und tan(x)=sin(x)/cos(x) wobei Sinus bevorzugt wird.',p:'Expr'},
    'trigtan':{d:'Vereinfacht das Argument mit den Formeln sin(x)^2+cos(x)^2=1 und tan(x)=sin(x)/cos(x) wobei Tangens bevorzugt wird.',p:'Expr'},
    'trim':{d:'',p:'(Str||Vect||Audio||Image)(s),[opts],[left|right],[index]'},
    'trn':{d:'Gibt das adjungierte der Matrix A zurück =tran(conj(A)).',p:'Mtrx'},
    'true':{d:'boolean gleich wahr (1)',a:['TRUE','True']},
    'trunc':{d:'Kürzt das Argument auf n Dezimale Stellen (ohne Spezifikation n=0). Komplexe Zahlen werden akzeptiert. (type=DOM_COMPLEX oder DOM_FLOAT).',p:'Real||LstReal,Int(n)'},
    'truncate':{d:'Schneidet das Polynom P bei Ordnung n ab.',p:'Poly(P),Intg(n)'},
    'truncate_graph':{d:'',p:'Graph(G)'},
    'try':{d:'Schutz gegen Fehler: try {instructions;} catch(variable) {error_instructions;} (in einem Programm).'},
    'tsimplify':{d:'Verringert die Anzahl der nicht rationalen Variablen.',p:'Expr'},
    'tukey_window':{d:'',p:'Lst,[Real(a)],[Interval(n1..n2)]'},
    'tutte_polynomial':{d:'',p:'Graph(G),[Var(x),Var(y)]'},
    'two_edge_connected_components':{d:'',p:'Graph(G)'},
    'type':{d:'Gibt n in [1..12] zurück, dass den Typ des Arguments definiert.',p:'Expr'},
    'ufactor':{d:'Faktorisiert eine Einheit in einem Objekt, dass eine Einheit hat',p:'Unit,Unit'},
    'ugamma':{d:'Berechnet den Wert der uGamma-Funktion am Punkt (a,x): Wenn a und x>=0 ugamma(a,x)=int(e^{-t}*t^{a-1},t=x..inf),(ugamma(a,x)+igamma(a,x)=Gamma(a)).',p:'Real(a),Real(x),[1]'},
    'unapply':{d:'Gibt eine Funktion zurück, die von einem Ausdruck definiert wird.',p:'Expr,Var'},
    'unarchive':{d:'Liest den Wert einer Variable oder einer Liste von Variablen, welche in einer Datei, die im Argument übergeben wird, sind (Datei mit archive erstellt).',p:'Str(namefich),Seq(Var)'},
    'undef':{d:''},
    'underlying_graph':{d:'',p:'Graph(G)'},
    'unfactored':{d:'Option für den "plotimplicit" Befehl.',p:'Opt.',a:['sans_factoriser']},
    'uniform':{d:'Gibt die Wahrscheinlichkeitsdichte am Punkt x der Standardverteilung auf dem Intervall [a,b] zurück.',p:'Real(a),Real(b),Real(x)',a:['uniformd']},
    'uniform_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine standardverteilte Zufallsvariable auf [a,b] kleiner als x0 (bzw. zwischen x0 und y0 ist).',p:'Real(a),Real(b),Real(x0),[Real(y0)]',a:['uniformd_cdf']},
    'uniform_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit, dass eine standardverteilte Zufallsvariable auf [a,b] kleiner als h ist, p ist (0<=p<=1).',p:'Real(a),Real(b),Real(p)',a:['uniformd_icdf']},
    'union':{d:'union ist ein Infix-Operator um die Vereinigung von zwei Mengen zu erhalten.',p:'(Vect or Set),(Vect or Set)'},
    'unquote':{d:'Wertet einen zitierten Ausdruck aus (Zum Beispiel purge(c);a:=c;unquote(a):=3; setzt 3 in die Variablen a und c ein).',p:'Expr'},
    'upper':{d:'',p:'Mtrx||Strng'},
    'user_operator':{d:'Definition eines binären Operators, der 0 (Fehlschlag) oder 1 (Erfolg) zurückgibt.',p:'Str(R),Fnc(f),Opt(Binary||Unary||Delete)'},
    'usimplify':{d:'Vereinfacht eine Einheit in einem Objekt mit Einheit',p:'Unit'},
    'valuation':{d:'Gibt den Grad des Terms mit dem kleinsten Grad eines Polynoms zurück.',p:'Poly(P)',a:['ldegree']},
    'vandermonde':{d:'Gibt die Vandermonde-Matrix =[V^0,V^1,..] zurück.',p:'Vect(V)'},
    'variables_are_files':{d:'Pseudo-Variable um zu spezifizieren, ob man die Variable als Datei speichern möchte. „nameofthevariable.cas“.',p:':=Intg(0 or 1)'},
    'variance':{d:'Gibt die Varianz einer Liste zurück. Im zweiten Argument wird die Gewichtung festgelegt. Auch kann die Liste der Varianzen der Spalten einer Matrix zurückgegeben werden.',p:'Lst||Mtrx,[Lst]'},
    'vector':{d:'Definiert einen Vektor (Ursprung 0, wenn 1 Argument) mit zwei Punkten oder zwei Komponenten oder zwei Affixen (für 2D) oder mit einem Punkt und Vektor oder mit einem Punkt (Seiner Extremität und sein Ursprung ist [0,0,0]). Man muss Listen verwenden, wenn man die Komponenten eines R^n Vektors haben möchte.',p:'Pnt,Pnt || Pnt,Vect'},
    'vers':{d:'Dreht die Schildkröte in die Richtung des Punktes, der im Argument gegeben wurde.',p:'Real,Real'},
    'version':{d:'Gibt die Nummer der giac Version zurück, die Sie benutzen: giac 0.4.0',p:'NULL'},
    'vertex_connectivity':{d:'',p:'Graph(G)'},
    'vertex_cover_number':{d:'',p:'Graph(G)'},
    'vertex_degree':{d:'',p:'Graph(G),Vrtx(v)'},
    'vertex_distance':{d:'',p:'Graph(G),Vrtx(s),Vrtx(t)||Lst(T)'},
    'vertex_in_degree':{d:'',p:'Graph(G),Vrtx(v)'},
    'vertex_out_degree':{d:'',p:'Graph(G),Vrtx(v)'},
    'vertices':{d:'Gibt die Liste der Ecken des Vieleckes oder Polyeders P zurück.',p:'Polygon or Polyedr(P)',a:['vertices_abc']},
    'vertices_abca':{d:'Gibt die geschlossene Loste [A,B,..,A] der Ecken eines Polygons oder Polyeders zurück.',p:'Polygon or Polyedr(P)'},
    'vpotential':{d:'Gibt U zurück sodass curl(U)=V (curl ist rot).',p:'Vect(V),LstVar'},
    'watch':{d:'Fügt eine Variable zu der Liste der angezeigten Variablen in Schritt-für-Schritt hinzu.',p:'Var'},
    'web_graph':{d:'',p:'Intg(a),Intg(b)'},
    'weibull':{d:'Gibt die Wahrscheinlichkeitsdichte am Punkt x der Weibull-Verteilung mit den Parametern k, lambda, theta (Standardeinstellung theta=0).',p:'Real(k),Real(lambda),Real(theta),Real(x)',a:['weibulld']},
    'weibull_cdf':{d:'Gibt die Wahrscheinlichkeit zurück, dass eine Weibull verteilte Zufallsvariable mit den Parametern k,lambda,theta kleiner als x0 ist.',p:'Real(k),Real(lambda),Real(theta),Real(x0)',a:['weibulld_cdf']},
    'weibull_icdf':{d:'Gibt h zurück, sodass die Wahrscheinlichkeit einer Weibull verteilten Zufallsvariable mit den Parametern k,lambda, theta kleiner als h zu sein, p ist (p<=0<=1).',p:'Real(k),Real(lambda),Real(theta),Real(p)',a:['weibulld_icdf']},
    'weight_matrix':{d:'',p:'Graph(G)'},
    'weighted':{d:'',p:'Opt'},
    'weights':{d:'',p:'Opt'},
    'welch_window':{d:'',p:'Lst,[Interval(n1..n2)]'},
    'wheel_graph':{d:'',p:'Intg(n)'},
    'when':{d:'Wenn Bedingung (sogar symbolisch) gebe Expr1 zurück sonst gebe Expr2 zurück (? ist die Infix-Version von when.)',p:'Cond,Expr1,Expr2'},
    'while':{d:'While-Schleife (führe die Instruktionen aus, während cond==true also die Bedingung erfüllt ist): while (cond) {i1;i2;};'},
    'white':{d:'Option des Befehls display um mit Farbe anzuzeigen.',p:'Opt',a:['black','red','green','blue','yellow','magenta','cyan','orange','purple','pink','grey','brown','olive','teal','navy','gold','violet']},
    'widget_size':{d:'Ändert die Größe der Zeichen auf dem Bildschirm von Xcas (Größe=n) und mit mehr Parametern kann man auch allgemeine Einstellungen vornehmen.',p:'Intg(n)'},
    'wilcoxonp':{d:'Verteilung des Wilcoxon- oder Mann-Whitney-Tests für eine oder zwei Stichproben.',p:'Intg,[Intg]'},
    'wilcoxons':{d:'Statistik von Wilcoxon oder von Mann-Whitney für eine Stichprobe und einen Median oder für zwei Stichproben.',p:'List,List || Real'},
    'wilcoxont':{d:'Wilcoxon- oder Mann-Whitney-Test einer Stichprobe und einem Median oder zweier Sticproben.',p:'List,List || Real,[Func],[Real]'},
    'with_sqrt':{d:'',p:':=Intg(0 or 1)'},
    'write':{d:'Schreibt in die Datei fich_name die Variablen und deren Werte.',p:'Str(fich_name),SeqVar',a:['sauve']},
    'writergb':{d:'Schreibt eine PNG Bilddatei mit dem Namen s entweder von einer Liste [[anzahl-kanaäele,breite,höhe],rot,grün,alpha,blau], wobei rot, grün, alpha, blau Matrizen mit Farbpixeln sind, oder von einer Matrix von grauen Pixeln oder drei Matrizen die die Farben RGB enthalten.',p:'Str(s),Lst'},
    'writewav':{d:'Schreibt in eine WAV-Sounddatei.',p:'Str(s),Lst(l)'},
    'wz_certificate':{d:'Wilf-Zeilberger Zertifikat',p:'Expr(U),[Expr(res)],[Var(n),Var(k)]'},
    'xcas_mode':{d:'Wechselt zum Modus Xcas (0), Maple (1), Mupad (2), TI89 (3).',p:'Intg(0) or 1 or 2 or 3',a:['maple_mode']},
    'xml_print':{d:'',p:'Str'},
    'xor':{d:'Exklusives "Oder" (infix Operator).',p:'Expr, Expr'},
    'xstep':{d:'',p:'Opt',a:['ystep','zstep','nstep','tstep','ustep','vstep']},
    'xyz2rgb':{d:'',p:'Lst(x,y,z)'},
    'xyztrange':{d:'xyztrange öscht oder fügt die Achsen des Grafik-Bildschirms hinzu (cf Knopf Cfg).',p:'SeqReal'},
    'zeros':{d:'Gibt Nullen (reell oder komplex hängt vom Modus ab) der Ausdrücke zurück (oder die Matrix deren Zeilen die Lösungen des Systems: Ausdruck1=0,Ausdruck2=0...).',p:'Expr,[Var]'},
    'zip':{d:'Gibt die Liste zurück, bei der der j-te Eintrag f(l1[j],l2[j]) ist: Wenn kein Wert angegeben wird, ist die Länge das Minimum der beiden Listen in den Argumenten. Sonst wird die kürzere Liste mit dem angegeben Wert aufgefüllt.',p:'Fnc2d(f),Lst(l1),Lst(l2),[Val(default)]'},
    'znorder':{d:'',p:'Intg'},
    'znprimroot':{d:'',p:'Intg'},
    'ztrans':{d:'Z-Transformation einer Folge',p:'Expr,[Var],[ZtransVar]'},
    '{}':{d:'Block mit Instruktionen.'},
    '|':{d:'Infix-Operator. Substituiert den Wert einer Variablen in einem Ausdruck.',p:'Expr, Var(v1)=value(a1)[,v2=a2,...]'}
  },
  aliases: {
    '%':'mod',
    '%{%}':'set[]',
    '&&':'and',
    'ACOSH':'acosh',
    'ACOT':'acot',
    'ACSC':'acsc',
    'ASEC':'asec',
    'ASIN':'asin',
    'ASINH':'asinh',
    'ATAN':'atan',
    'ATANH':'atanh',
    'COS':'cos',
    'COSH':'cosh',
    'COT':'cot',
    'CSC':'csc',
    'ClrDraw':'ClrGraph',
    'DIGITS':'Digits',
    'DOM_int':'DOM_INT',
    'DelVar':'purge',
    'Disp':'print',
    'DrawFunc':'plotfunc',
    'DrawParm':'plotparam',
    'DrawPol':'plotpolar',
    'DrwCtour':'plotcontour',
    'ERROR':'error',
    'EXP':'exp',
    'EndDlog':'Dialog',
    'FALSE':'false',
    'False':'false',
    'Graph':'plotfunc',
    'IFTE':'ifte',
    'Input':'input',
    'LN':'ln',
    'NORMALD':'normald',
    'Output':'output',
    'Phi':'euler',
    'Pi':'pi',
    'PopUp':'choosebox',
    'ReLU':'MSE',
    'SCALE':'scale',
    'SCALEADD':'scaleadd',
    'SIN':'sin',
    'SWAPCOL':'colSwap',
    'SWAPROW':'rowSwap',
    'Store':'sto',
    'TAN':'tan',
    'TRUE':'true',
    'TeX':'latex',
    'True':'true',
    '[..]':'i[]',
    'adaptive':'MSE',
    'add':'sum',
    'alors':'si',
    'approx':'evalf',
    'arccos':'acos',
    'arccosh':'acosh',
    'arclen':'arcLen',
    'arcsin':'asin',
    'arcsinh':'asinh',
    'arctan':'atan',
    'arctanh':'atanh',
    'areaplot':'plotarea',
    'augment':'concat',
    'backward':'recule',
    'barplot':'bar_plot',
    'berlekamp_massey':'reverse_rsolve',
    'betavariate':'randbetad',
    'bezout_entiers':'iegcd',
    'black':'white',
    'block_size':'MSE',
    'blue':'white',
    'brent_solver':'bisection_solver',
    'brown':'white',
    'by':'step',
    'cSolve':'csolve',
    'cap_flat_line':'dash_line',
    'cap_round_line':'dash_line',
    'cap_square_line':'dash_line',
    'cauchyd':'cauchy',
    'cauchyd_cdf':'cauchy_cdf',
    'cauchyd_icdf':'cauchy_icdf',
    'ceiling':'ceil',
    'cfactor':'cFactor',
    'charpoly':'pcar',
    'chisquared':'chisquare',
    'chisquared_cdf':'chisquare_cdf',
    'chisquared_icdf':'chisquare_icdf',
    'chr':'char',
    'close':'fclose',
    'coeffs':'coeff',
    'colDim':'coldim',
    'colnorm':'colNorm',
    'color':'display',
    'colswap':'colSwap',
    'complex':'DOM_COMPLEX',
    'cond':'COND',
    'contourplot':'plotcontour',
    'convertir':'convert',
    'courbe_parametrique':'plotparam',
    'courbe_polaire':'plotpolar',
    'crossP':'cross',
    'cross_entropy':'MSE',
    'cross_point':'rhombus_point',
    'crossproduct':'cross',
    'cumsum':'cumSum',
    'cyan':'white',
    'dashdot_line':'dash_line',
    'dashdotdot_line':'dash_line',
    'deSolve':'desolve',
    'del':'purge',
    'densityplot':'plotdensity',
    'derive':'diff',
    'deriver':'diff',
    'developper':'expand',
    'developper_transcendant':'texpand',
    'divide':'quorem',
    'divisors':'idivis',
    'divmod':'iquorem',
    'dotP':'dot',
    'dotprod':'dot',
    'double':'DOM_FLOAT',
    'draw_pixel':'set_pixel',
    'droit':'right',
    'dsolve':'desolve',
    'e2r':'symb2poly',
    'ecart_type':'stddev',
    'ecart_type_population':'stddevp',
    'eigVc':'egv',
    'eigVl':'egvl',
    'eigenvalues':'eigenvals',
    'eigenvectors':'egv',
    'eigenvects':'egv',
    'end_for':'end',
    'end_if':'end',
    'end_while':'end',
    'entry':'quest',
    'epaisseur':'thickness',
    'epaisseur_ligne_1':'line_width_1',
    'epaisseur_ligne_2':'line_width_1',
    'epaisseur_ligne_3':'line_width_1',
    'epaisseur_ligne_4':'line_width_1',
    'epaisseur_ligne_5':'line_width_1',
    'epaisseur_ligne_6':'line_width_1',
    'epaisseur_ligne_7':'line_width_1',
    'epaisseur_point_1':'point_width_1',
    'epaisseur_point_2':'point_width_1',
    'epaisseur_point_3':'point_width_1',
    'epaisseur_point_4':'point_width_1',
    'epaisseur_point_5':'point_width_1',
    'epaisseur_point_6':'point_width_1',
    'epaisseur_point_7':'point_width_1',
    'est_permu':'is_permu',
    'et':'and',
    'evala':'normal',
    'evalm':'eval',
    'exact':'float2rational',
    'execute':'expr',
    'exponentiald':'exponential',
    'exponentiald_cdf':'exponential_cdf',
    'exponentiald_icdf':'exponential_icdf',
    'expovariate':'randexp',
    'expression':'DOM_SYMBOLIC',
    'extend':'concat',
    'facteurs_premiers':'ifactors',
    'factoriser':'factor',
    'factoriser_entier':'ifactor',
    'factoriser_sur_C':'cFactor',
    'faire':'do',
    'falsepos_solver':'bisection_solver',
    'fdistrib':'expand',
    'ffaire':'end',
    'ffonction':'end',
    'ffunction':'end',
    'fi':'end',
    'fieldplot':'plotfield',
    'fisherd':'fisher',
    'fisherd_cdf':'fisher_cdf',
    'fisherd_icdf':'fisher_icdf',
    'float':'DOM_FLOAT',
    'fonction':'function',
    'fonction_derivee':'function_diff',
    'forward':'avance',
    'fpour':'end',
    'frac':'fPart',
    'from':'de',
    'fsi':'end',
    'ftantque':'end',
    'fullparfrac':'parfrac',
    'func':'DOM_FUNC',
    'funcplot':'plotfunc',
    'fxnd':'f2nd',
    'gammavariate':'randgammad',
    'gauche':'left',
    'gauss15':'simpson',
    'gaussjord':'rref',
    'gcdex':'egcd',
    'gl_y':'gl_x',
    'gl_y_axis_color':'gl_x_axis_color',
    'gl_y_axis_name':'gl_x_axis_name',
    'gl_y_axis_unit':'gl_x_axis_unit',
    'gl_ytick':'gl_xtick',
    'gl_z':'gl_x',
    'gl_z_axis_color':'gl_x_axis_color',
    'gl_z_axis_name':'gl_x_axis_name',
    'gl_z_axis_unit':'gl_x_axis_unit',
    'gl_ztick':'gl_xtick',
    'gold':'white',
    'graphe':'plot',
    'graphe3d':'plot3d',
    'graphe_suite':'plotseq',
    'green':'white',
    'grey':'white',
    'heading':'cap',
    'hold':'quote',
    'hybrid_solver':'dnewton_solver',
    'hybridj_solver':'dnewton_solver',
    'hybrids_solver':'dnewton_solver',
    'hybridsj_solver':'dnewton_solver',
    'ichrem':'ichinrem',
    'identifier':'DOM_IDENT',
    'idn':'identity',
    'igcd':'gcd',
    'igcdex':'iegcd',
    'imag':'im',
    'implicitplot':'plotimplicit',
    'indets':'lname',
    'inequationplot':'plotinequation',
    'inf':'+infinity',
    'intDiv':'iquo',
    'integer':'DOM_INT',
    'integrate':'int',
    'integrer':'int',
    'interactive_odeplot':'interactive_plotode',
    'inverse':'inv',
    'invisible_point':'rhombus_point',
    'invlaplace':'ilaplace',
    'iratrecon':'fracmod',
    'isPrime':'isprime',
    'jusqu_a':'repeat',
    'jusqua':'repeat',
    'kde':'kernel_density',
    'kernel':'ker',
    'l2norm':'norm',
    'ldegree':'valuation',
    'learning_rate':'MSE',
    'left_rectangle':'trapezoid',
    'len':'size',
    'length':'size',
    'lhs':'left',
    'ligne_chapeau_carre':'dash_line',
    'ligne_chapeau_plat':'dash_line',
    'ligne_chapeau_rond':'dash_line',
    'ligne_polygonale':'polygonplot',
    'ligne_polygonale_pointee':'polygonscatterplot',
    'ligne_tiret':'dash_line',
    'ligne_tiret_point':'dash_line',
    'ligne_tiret_pointpoint':'dash_line',
    'ligne_trait_plein':'dash_line',
    'limite':'limit',
    'line_inter':'single_inter',
    'line_width_2':'line_width_1',
    'line_width_3':'line_width_1',
    'line_width_4':'line_width_1',
    'line_width_5':'line_width_1',
    'line_width_6':'line_width_1',
    'line_width_7':'line_width_1',
    'lineariser':'lin',
    'lineariser_trigo':'tlin',
    'lis':'input',
    'lis_phrase':'InputStr',
    'log':'ln',
    'log_loss':'MSE',
    'lp_bestlocalbound':'lp_assume',
    'lp_bestprojection':'lp_assume',
    'lp_binary':'lp_assume',
    'lp_binaryvariables':'lp_assume',
    'lp_breadthfirst':'lp_assume',
    'lp_depthfirst':'lp_assume',
    'lp_depthlimit':'lp_assume',
    'lp_firstfractional':'lp_assume',
    'lp_gaptolerance':'lp_assume',
    'lp_heuristic':'lp_assume',
    'lp_hybrid':'lp_assume',
    'lp_integer':'lp_assume',
    'lp_integervariables':'lp_assume',
    'lp_interiorpoint':'lp_assume',
    'lp_iterationlimit':'lp_assume',
    'lp_lastfractional':'lp_assume',
    'lp_maxcuts':'lp_assume',
    'lp_maximize':'lp_assume',
    'lp_method':'lp_assume',
    'lp_mostfractional':'lp_assume',
    'lp_nodelimit':'lp_assume',
    'lp_nodeselect':'lp_assume',
    'lp_nonnegative':'lp_assume',
    'lp_nonnegint':'lp_assume',
    'lp_presolve':'lp_assume',
    'lp_pseudocost':'lp_assume',
    'lp_simplex':'lp_assume',
    'lp_timelimit':'lp_assume',
    'lp_varselect':'lp_assume',
    'lp_verbose':'lp_assume',
    'lsq':'LSQ',
    'magenta':'white',
    'maple_mode':'xcas_mode',
    'middle_point':'trapezoid',
    'mods':'smod',
    'momentum':'MSE',
    'moustache':'boxwhisker',
    'moyenne':'mean',
    'mul':'product',
    'multiplier_conjugue':'mult_conjugate',
    'multiplier_conjugue_complexe':'mult_c_conjugate',
    'nCr':'comb',
    'nInt':'romberg',
    'nPr':'perm',
    'navy':'white',
    'ncols':'coldim',
    'newton_solver':'bisection_solver',
    'newtonj_solver':'dnewton_solver',
    'nlp_binary':'nlp_initialpoint',
    'nlp_binaryvariables':'nlp_initialpoint',
    'nlp_integer':'nlp_initialpoint',
    'nlp_integervariables':'nlp_initialpoint',
    'nlp_iterationlimit':'nlp_initialpoint',
    'nlp_maximize':'nlp_initialpoint',
    'nlp_method':'nlp_initialpoint',
    'nlp_nonnegative':'nlp_initialpoint',
    'nlp_nonnegint':'nlp_initialpoint',
    'nlp_precision':'nlp_initialpoint',
    'nlp_presolve':'nlp_initialpoint',
    'nlp_tolerance':'nlp_initialpoint',
    'nlp_verbose':'nlp_initialpoint',
    'non':'not',
    'nonnegint':'lp_assume',
    'nops':'size',
    'normald_cdf':'normal_cdf',
    'normald_icdf':'normal_icdf',
    'normalvariate':'randnorm',
    'nrows':'rowdim',
    'nstep':'xstep',
    'nuage_points':'scatterplot',
    'nullspace':'ker',
    'od':'end',
    'odeplot':'plotode',
    'olive':'white',
    'op':'feuille',
    'orange':'white',
    'otherwise':'default',
    'ou':'or',
    'paramplot':'plotparam',
    'pas':'step',
    'pcoef':'pcoeff',
    'pencolor':'crayon',
    'pendown':'baisse_crayon',
    'penup':'leve_crayon',
    'pie':'camembert',
    'pink':'white',
    'plotimf':'imfplot',
    'plotlist':'listplot',
    'plus_point':'rhombus_point',
    'point_carre':'rhombus_point',
    'point_croix':'rhombus_point',
    'point_etoile':'rhombus_point',
    'point_invisible':'rhombus_point',
    'point_losange':'rhombus_point',
    'point_milieu':'trapezoid',
    'point_plus':'rhombus_point',
    'point_point':'rhombus_point',
    'point_triangle':'rhombus_point',
    'point_width_2':'point_width_1',
    'point_width_3':'point_width_1',
    'point_width_4':'point_width_1',
    'point_width_5':'point_width_1',
    'point_width_6':'point_width_1',
    'point_width_7':'point_width_1',
    'polarplot':'plotpolar',
    'polyEval':'peval',
    'powermod':'powmod',
    'propFrac':'propfrac',
    'purple':'white',
    'quadrant2':'quadrant1',
    'quadrant3':'quadrant1',
    'quadrant4':'quadrant1',
    'r2e':'poly2symb',
    'ramene':'read',
    'randMat':'ranm',
    'randNorm':'randnorm',
    'randPoly':'randpoly',
    'randmatrix':'ranm',
    'random':'rand',
    'randseed':'srand',
    'randvar':'random_variable',
    'ranv':'randvector',
    'rassembler_trigo':'tcollect',
    'rational':'DOM_RAT',
    'real':'re',
    'rectangle_droit':'trapezoid',
    'rectangle_gauche':'trapezoid',
    'red':'white',
    'redim':'REDIM',
    'remain':'irem',
    'repeter':'repeat',
    'replace':'REPLACE',
    'resoudre':'solve',
    'resoudre_dans_C':'csolve',
    'resoudre_systeme_lineaire':'linsolve',
    'reverse':'revlist',
    'rhs':'right',
    'right_rectangle':'trapezoid',
    'rombergm':'simpson',
    'rombergt':'simpson',
    'rowDim':'rowdim',
    'rownorm':'rowNorm',
    'rowswap':'rowSwap',
    'sans_factoriser':'unfactored',
    'sauve':'write',
    'scalarProduct':'dot',
    'scalar_product':'dot',
    'schur':'SCHUR',
    'secant_solver':'bisection_solver',
    'seqplot':'plotseq',
    'shuffle':'randperm',
    'simplifier':'simplify',
    'sinon':'si',
    'sleep':'Pause',
    'snedecor':'fisher',
    'snedecor_cdf':'fisher_cdf',
    'snedecor_icdf':'fisher_icdf',
    'snedecord':'fisher',
    'snedecord_cdf':'fisher_cdf',
    'snedecord_icdf':'fisher_icdf',
    'solid_line':'dash_line',
    'somme':'sum',
    'sorted':'sort',
    'square_point':'rhombus_point',
    'star_point':'rhombus_point',
    'stdDev':'stddevp',
    'steffenson_solver':'bisection_solver',
    'string':'str',
    'studentd':'student',
    'substituer':'subst',
    'swapcol':'colSwap',
    'swaprow':'rowSwap',
    'symbol':'DOM_SYMBOLIC',
    'tCollect':'tcollect',
    'tExpand':'texpand',
    'tangente':'tangent',
    'teal':'white',
    'tetrahedron':'pyramid',
    'textinput':'InputStr',
    'throw':'error',
    'titre':'title',
    'to':'jusque',
    'topological_sort':'topologic_sort',
    'topology':'MSE',
    'trames':'frames',
    'transpose':'tran',
    'trapeze':'trapezoid',
    'triangle_point':'rhombus_point',
    'tstep':'xstep',
    'tuer':'kill',
    'uniformd':'uniform',
    'uniformd_cdf':'uniform_cdf',
    'uniformd_icdf':'uniform_icdf',
    'unitV':'normalize',
    'until':'repeat',
    'ustep':'xstep',
    'var':'local',
    'vertices_abc':'vertices',
    'violet':'white',
    'vstep':'xstep',
    'weibulld':'weibull',
    'weibulld_cdf':'weibull_cdf',
    'weibulld_icdf':'weibull_icdf',
    'weibullvariate':'randweibulld',
    'weight_decay':'MSE',
    'yellow':'white',
    'ystep':'xstep',
    'zstep':'xstep',
    '||':'or'
  }
};
